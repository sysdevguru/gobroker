// Generated from parser/SQLBase.g4 by ANTLR 4.6.

package parser // SQLBase

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 1072, 54993, 33286, 44333, 17431, 44785, 36224, 43741, 3, 214, 1312,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 3, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 5, 3, 122, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 129, 10, 3, 12,
	3, 14, 3, 132, 11, 3, 3, 3, 3, 3, 3, 3, 5, 3, 137, 10, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 5, 3, 144, 10, 3, 3, 3, 3, 3, 3, 3, 5, 3, 149, 10, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 158, 10, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 5, 3, 165, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 5, 3, 174, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 202, 10, 3, 3, 3, 3, 3, 3, 3, 5,
	3, 207, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 216, 10,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 225, 10, 3, 12, 3, 14,
	3, 228, 11, 3, 5, 3, 230, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7,
	3, 238, 10, 3, 12, 3, 14, 3, 241, 11, 3, 3, 3, 3, 3, 5, 3, 245, 10, 3,
	3, 3, 3, 3, 5, 3, 249, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3,
	257, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 263, 10, 3, 3, 3, 3, 3, 3, 3,
	7, 3, 268, 10, 3, 12, 3, 14, 3, 271, 11, 3, 3, 3, 3, 3, 5, 3, 275, 10,
	3, 3, 3, 3, 3, 5, 3, 279, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5,
	3, 287, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 293, 10, 3, 12, 3, 14, 3,
	296, 11, 3, 3, 3, 3, 3, 5, 3, 300, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 315, 10, 3, 3, 3,
	3, 3, 5, 3, 319, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 325, 10, 3, 3, 3,
	3, 3, 5, 3, 329, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 335, 10, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3,
	361, 10, 3, 12, 3, 14, 3, 364, 11, 3, 5, 3, 366, 10, 3, 3, 3, 3, 3, 5,
	3, 370, 10, 3, 3, 3, 3, 3, 5, 3, 374, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 5, 3, 382, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 389, 10,
	3, 12, 3, 14, 3, 392, 11, 3, 5, 3, 394, 10, 3, 3, 3, 3, 3, 5, 3, 398, 10,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 7, 3, 414, 10, 3, 12, 3, 14, 3, 417, 11, 3, 5, 3, 419, 10,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 427, 10, 3, 3, 4, 5, 4, 430,
	10, 4, 3, 4, 3, 4, 3, 5, 3, 5, 5, 5, 436, 10, 5, 3, 5, 3, 5, 3, 5, 7, 5,
	441, 10, 5, 12, 5, 14, 5, 444, 11, 5, 3, 6, 3, 6, 5, 6, 448, 10, 6, 3,
	7, 3, 7, 3, 7, 3, 7, 5, 7, 454, 10, 7, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 460,
	10, 8, 3, 9, 3, 9, 3, 9, 3, 9, 7, 9, 466, 10, 9, 12, 9, 14, 9, 469, 11,
	9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 3, 11,
	3, 11, 3, 11, 7, 11, 483, 10, 11, 12, 11, 14, 11, 486, 11, 11, 5, 11, 488,
	10, 11, 3, 11, 3, 11, 5, 11, 492, 10, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3,
	12, 3, 12, 5, 12, 500, 10, 12, 3, 12, 7, 12, 503, 10, 12, 12, 12, 14, 12,
	506, 11, 12, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 7, 13, 515,
	10, 13, 12, 13, 14, 13, 518, 11, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13,
	524, 10, 13, 3, 14, 3, 14, 5, 14, 528, 10, 14, 3, 14, 3, 14, 5, 14, 532,
	10, 14, 3, 15, 3, 15, 5, 15, 536, 10, 15, 3, 15, 3, 15, 3, 15, 7, 15, 541,
	10, 15, 12, 15, 14, 15, 544, 11, 15, 3, 15, 3, 15, 3, 15, 3, 15, 7, 15,
	550, 10, 15, 12, 15, 14, 15, 553, 11, 15, 5, 15, 555, 10, 15, 3, 15, 3,
	15, 5, 15, 559, 10, 15, 3, 15, 3, 15, 3, 15, 5, 15, 564, 10, 15, 3, 15,
	3, 15, 5, 15, 568, 10, 15, 3, 16, 5, 16, 571, 10, 16, 3, 16, 3, 16, 3,
	16, 7, 16, 576, 10, 16, 12, 16, 14, 16, 579, 11, 16, 3, 17, 3, 17, 3, 17,
	3, 17, 3, 17, 3, 17, 7, 17, 587, 10, 17, 12, 17, 14, 17, 590, 11, 17, 5,
	17, 592, 10, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 7, 17, 600,
	10, 17, 12, 17, 14, 17, 603, 11, 17, 5, 17, 605, 10, 17, 3, 17, 3, 17,
	3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 7, 17, 614, 10, 17, 12, 17, 14, 17,
	617, 11, 17, 3, 17, 3, 17, 5, 17, 621, 10, 17, 3, 18, 3, 18, 3, 18, 3,
	18, 7, 18, 627, 10, 18, 12, 18, 14, 18, 630, 11, 18, 5, 18, 632, 10, 18,
	3, 18, 3, 18, 5, 18, 636, 10, 18, 3, 19, 3, 19, 3, 19, 3, 19, 7, 19, 642,
	10, 19, 12, 19, 14, 19, 645, 11, 19, 5, 19, 647, 10, 19, 3, 19, 3, 19,
	5, 19, 651, 10, 19, 3, 20, 3, 20, 5, 20, 655, 10, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 21, 3, 21, 3, 22, 3, 22, 5, 22, 666, 10, 22, 3, 22,
	5, 22, 669, 10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 676, 10,
	22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 683, 10, 23, 3, 23, 3, 23,
	3, 23, 5, 23, 688, 10, 23, 7, 23, 690, 10, 23, 12, 23, 14, 23, 693, 11,
	23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24,
	5, 24, 705, 10, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 7,
	25, 714, 10, 25, 12, 25, 14, 25, 717, 11, 25, 3, 25, 3, 25, 5, 25, 721,
	10, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 730, 10,
	26, 3, 27, 3, 27, 5, 27, 734, 10, 27, 3, 27, 3, 27, 5, 27, 738, 10, 27,
	5, 27, 740, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 7, 28, 746, 10, 28, 12,
	28, 14, 28, 749, 11, 28, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29,
	3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 7, 29, 763, 10, 29, 12, 29, 14, 29,
	766, 11, 29, 3, 29, 3, 29, 3, 29, 5, 29, 771, 10, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 5, 29, 777, 10, 29, 3, 30, 3, 30, 5, 30, 781, 10, 30, 3, 31,
	3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 790, 10, 31, 3, 31, 3,
	31, 3, 31, 7, 31, 795, 10, 31, 12, 31, 14, 31, 798, 11, 31, 3, 32, 3, 32,
	3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5,
	33, 812, 10, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 820,
	10, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 7, 33, 827, 10, 33, 12, 33,
	14, 33, 830, 11, 33, 3, 33, 3, 33, 3, 33, 5, 33, 835, 10, 33, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 843, 10, 33, 3, 33, 3, 33, 3, 33,
	3, 33, 5, 33, 849, 10, 33, 3, 33, 3, 33, 5, 33, 853, 10, 33, 3, 33, 3,
	33, 3, 33, 5, 33, 858, 10, 33, 3, 33, 3, 33, 3, 33, 5, 33, 863, 10, 33,
	3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 869, 10, 34, 3, 34, 3, 34, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 7, 34, 880, 10, 34, 12, 34, 14,
	34, 883, 11, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 899, 10, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	6, 35, 913, 10, 35, 13, 35, 14, 35, 914, 3, 35, 3, 35, 3, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 7, 35, 924, 10, 35, 12, 35, 14, 35, 927, 11, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 936, 10, 35, 3, 35, 5,
	35, 939, 10, 35, 3, 35, 3, 35, 3, 35, 5, 35, 944, 10, 35, 3, 35, 3, 35,
	3, 35, 7, 35, 949, 10, 35, 12, 35, 14, 35, 952, 11, 35, 5, 35, 954, 10,
	35, 3, 35, 3, 35, 5, 35, 958, 10, 35, 3, 35, 5, 35, 961, 10, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 7, 35, 971, 10, 35, 12,
	35, 14, 35, 974, 11, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 6, 35, 992,
	10, 35, 13, 35, 14, 35, 993, 3, 35, 3, 35, 5, 35, 998, 10, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 6, 35, 1004, 10, 35, 13, 35, 14, 35, 1005, 3, 35, 3,
	35, 5, 35, 1010, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 3, 35, 7, 35, 1033, 10, 35, 12, 35, 14, 35, 1036, 11,
	35, 5, 35, 1038, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	5, 35, 1047, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 1053, 10, 35, 3,
	35, 3, 35, 3, 35, 3, 35, 5, 35, 1059, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	5, 35, 1065, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5,
	35, 1074, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35,
	1083, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 1098, 10, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 7, 35, 1108, 10, 35, 12, 35, 14, 35,
	1111, 11, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 5, 36, 1119, 10,
	36, 3, 37, 3, 37, 3, 38, 3, 38, 3, 39, 3, 39, 5, 39, 1127, 10, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 5, 39, 1133, 10, 39, 3, 40, 3, 40, 3, 41, 3, 41, 3,
	41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41,
	3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 7, 41, 1158, 10,
	41, 12, 41, 14, 41, 1161, 11, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3,
	41, 3, 41, 7, 41, 1170, 10, 41, 12, 41, 14, 41, 1173, 11, 41, 3, 41, 3,
	41, 5, 41, 1177, 10, 41, 5, 41, 1179, 10, 41, 3, 41, 3, 41, 7, 41, 1183,
	10, 41, 12, 41, 14, 41, 1186, 11, 41, 3, 42, 3, 42, 5, 42, 1190, 10, 42,
	3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 1197, 10, 43, 3, 44, 3, 44, 3,
	44, 3, 44, 3, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 46, 3, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 7, 46, 1217, 10, 46, 12, 46, 14, 46,
	1220, 11, 46, 5, 46, 1222, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 7,
	46, 1229, 10, 46, 12, 46, 14, 46, 1232, 11, 46, 5, 46, 1234, 10, 46, 3,
	46, 5, 46, 1237, 10, 46, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47,
	3, 47, 3, 47, 3, 47, 5, 47, 1249, 10, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3,
	48, 3, 48, 3, 48, 5, 48, 1258, 10, 48, 3, 49, 3, 49, 3, 49, 3, 49, 5, 49,
	1264, 10, 49, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 1271, 10, 50, 3,
	51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 1280, 10, 51, 3, 52,
	3, 52, 3, 52, 3, 52, 3, 52, 5, 52, 1287, 10, 52, 3, 53, 3, 53, 3, 53, 3,
	53, 5, 53, 1293, 10, 53, 3, 54, 3, 54, 3, 54, 7, 54, 1298, 10, 54, 12,
	54, 14, 54, 1301, 11, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 5, 55, 1308,
	10, 55, 3, 56, 3, 56, 3, 56, 2, 8, 22, 44, 60, 66, 68, 80, 57, 2, 4, 6,
	8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 2,
	24, 4, 2, 13, 13, 33, 33, 4, 2, 48, 48, 110, 110, 3, 2, 177, 178, 3, 2,
	137, 139, 3, 2, 47, 48, 3, 2, 44, 45, 4, 2, 16, 16, 19, 19, 3, 2, 141,
	143, 3, 2, 31, 32, 3, 2, 41, 42, 3, 2, 197, 198, 3, 2, 197, 201, 3, 2,
	181, 184, 3, 2, 191, 196, 3, 2, 16, 18, 3, 2, 59, 64, 3, 2, 90, 91, 3,
	2, 93, 94, 3, 2, 120, 121, 3, 2, 122, 124, 3, 2, 167, 168, 18, 2, 14, 14,
	16, 18, 30, 30, 35, 35, 49, 50, 52, 65, 87, 91, 93, 96, 101, 101, 103,
	105, 111, 124, 127, 135, 140, 144, 149, 169, 173, 179, 181, 187, 1514,
	2, 112, 3, 2, 2, 2, 4, 426, 3, 2, 2, 2, 6, 429, 3, 2, 2, 2, 8, 433, 3,
	2, 2, 2, 10, 447, 3, 2, 2, 2, 12, 449, 3, 2, 2, 2, 14, 455, 3, 2, 2, 2,
	16, 461, 3, 2, 2, 2, 18, 472, 3, 2, 2, 2, 20, 476, 3, 2, 2, 2, 22, 493,
	3, 2, 2, 2, 24, 523, 3, 2, 2, 2, 26, 525, 3, 2, 2, 2, 28, 533, 3, 2, 2,
	2, 30, 570, 3, 2, 2, 2, 32, 620, 3, 2, 2, 2, 34, 635, 3, 2, 2, 2, 36, 650,
	3, 2, 2, 2, 38, 652, 3, 2, 2, 2, 40, 661, 3, 2, 2, 2, 42, 675, 3, 2, 2,
	2, 44, 677, 3, 2, 2, 2, 46, 704, 3, 2, 2, 2, 48, 720, 3, 2, 2, 2, 50, 722,
	3, 2, 2, 2, 52, 731, 3, 2, 2, 2, 54, 741, 3, 2, 2, 2, 56, 776, 3, 2, 2,
	2, 58, 780, 3, 2, 2, 2, 60, 789, 3, 2, 2, 2, 62, 799, 3, 2, 2, 2, 64, 862,
	3, 2, 2, 2, 66, 868, 3, 2, 2, 2, 68, 1097, 3, 2, 2, 2, 70, 1118, 3, 2,
	2, 2, 72, 1120, 3, 2, 2, 2, 74, 1122, 3, 2, 2, 2, 76, 1124, 3, 2, 2, 2,
	78, 1134, 3, 2, 2, 2, 80, 1178, 3, 2, 2, 2, 82, 1189, 3, 2, 2, 2, 84, 1196,
	3, 2, 2, 2, 86, 1198, 3, 2, 2, 2, 88, 1203, 3, 2, 2, 2, 90, 1209, 3, 2,
	2, 2, 92, 1248, 3, 2, 2, 2, 94, 1257, 3, 2, 2, 2, 96, 1263, 3, 2, 2, 2,
	98, 1270, 3, 2, 2, 2, 100, 1279, 3, 2, 2, 2, 102, 1286, 3, 2, 2, 2, 104,
	1292, 3, 2, 2, 2, 106, 1294, 3, 2, 2, 2, 108, 1307, 3, 2, 2, 2, 110, 1309,
	3, 2, 2, 2, 112, 113, 5, 4, 3, 2, 113, 114, 7, 11, 2, 2, 114, 3, 3, 2,
	2, 2, 115, 427, 5, 6, 4, 2, 116, 117, 7, 100, 2, 2, 117, 121, 7, 102, 2,
	2, 118, 119, 7, 185, 2, 2, 119, 120, 7, 34, 2, 2, 120, 122, 7, 36, 2, 2,
	121, 118, 3, 2, 2, 2, 121, 122, 3, 2, 2, 2, 122, 123, 3, 2, 2, 2, 123,
	124, 5, 106, 54, 2, 124, 125, 7, 3, 2, 2, 125, 130, 5, 10, 6, 2, 126, 127,
	7, 4, 2, 2, 127, 129, 5, 10, 6, 2, 128, 126, 3, 2, 2, 2, 129, 132, 3, 2,
	2, 2, 130, 128, 3, 2, 2, 2, 130, 131, 3, 2, 2, 2, 131, 133, 3, 2, 2, 2,
	132, 130, 3, 2, 2, 2, 133, 136, 7, 5, 2, 2, 134, 135, 7, 97, 2, 2, 135,
	137, 5, 16, 9, 2, 136, 134, 3, 2, 2, 2, 136, 137, 3, 2, 2, 2, 137, 427,
	3, 2, 2, 2, 138, 139, 7, 100, 2, 2, 139, 143, 7, 102, 2, 2, 140, 141, 7,
	185, 2, 2, 141, 142, 7, 34, 2, 2, 142, 144, 7, 36, 2, 2, 143, 140, 3, 2,
	2, 2, 143, 144, 3, 2, 2, 2, 144, 145, 3, 2, 2, 2, 145, 148, 5, 106, 54,
	2, 146, 147, 7, 97, 2, 2, 147, 149, 5, 16, 9, 2, 148, 146, 3, 2, 2, 2,
	148, 149, 3, 2, 2, 2, 149, 150, 3, 2, 2, 2, 150, 151, 7, 15, 2, 2, 151,
	152, 5, 6, 4, 2, 152, 427, 3, 2, 2, 2, 153, 154, 7, 136, 2, 2, 154, 157,
	7, 102, 2, 2, 155, 156, 7, 185, 2, 2, 156, 158, 7, 36, 2, 2, 157, 155,
	3, 2, 2, 2, 157, 158, 3, 2, 2, 2, 158, 159, 3, 2, 2, 2, 159, 427, 5, 106,
	54, 2, 160, 161, 7, 106, 2, 2, 161, 162, 7, 108, 2, 2, 162, 164, 5, 106,
	54, 2, 163, 165, 5, 54, 28, 2, 164, 163, 3, 2, 2, 2, 164, 165, 3, 2, 2,
	2, 165, 166, 3, 2, 2, 2, 166, 167, 5, 6, 4, 2, 167, 427, 3, 2, 2, 2, 168,
	169, 7, 107, 2, 2, 169, 170, 7, 13, 2, 2, 170, 173, 5, 106, 54, 2, 171,
	172, 7, 20, 2, 2, 172, 174, 5, 60, 31, 2, 173, 171, 3, 2, 2, 2, 173, 174,
	3, 2, 2, 2, 174, 427, 3, 2, 2, 2, 175, 176, 7, 145, 2, 2, 176, 177, 7,
	102, 2, 2, 177, 178, 5, 106, 54, 2, 178, 179, 7, 146, 2, 2, 179, 180, 7,
	140, 2, 2, 180, 181, 5, 106, 54, 2, 181, 427, 3, 2, 2, 2, 182, 183, 7,
	145, 2, 2, 183, 184, 7, 102, 2, 2, 184, 185, 5, 106, 54, 2, 185, 186, 7,
	146, 2, 2, 186, 187, 7, 132, 2, 2, 187, 188, 5, 108, 55, 2, 188, 189, 7,
	140, 2, 2, 189, 190, 5, 108, 55, 2, 190, 427, 3, 2, 2, 2, 191, 192, 7,
	145, 2, 2, 192, 193, 7, 102, 2, 2, 193, 194, 5, 106, 54, 2, 194, 195, 7,
	14, 2, 2, 195, 196, 7, 132, 2, 2, 196, 197, 5, 12, 7, 2, 197, 427, 3, 2,
	2, 2, 198, 201, 7, 100, 2, 2, 199, 200, 7, 31, 2, 2, 200, 202, 7, 105,
	2, 2, 201, 199, 3, 2, 2, 2, 201, 202, 3, 2, 2, 2, 202, 203, 3, 2, 2, 2,
	203, 204, 7, 104, 2, 2, 204, 206, 5, 106, 54, 2, 205, 207, 5, 54, 28, 2,
	206, 205, 3, 2, 2, 2, 206, 207, 3, 2, 2, 2, 207, 208, 3, 2, 2, 2, 208,
	209, 7, 15, 2, 2, 209, 210, 5, 6, 4, 2, 210, 427, 3, 2, 2, 2, 211, 212,
	7, 136, 2, 2, 212, 215, 7, 104, 2, 2, 213, 214, 7, 185, 2, 2, 214, 216,
	7, 36, 2, 2, 215, 213, 3, 2, 2, 2, 215, 216, 3, 2, 2, 2, 216, 217, 3, 2,
	2, 2, 217, 427, 5, 106, 54, 2, 218, 219, 7, 169, 2, 2, 219, 220, 5, 106,
	54, 2, 220, 229, 7, 3, 2, 2, 221, 226, 5, 102, 52, 2, 222, 223, 7, 4, 2,
	2, 223, 225, 5, 102, 52, 2, 224, 222, 3, 2, 2, 2, 225, 228, 3, 2, 2, 2,
	226, 224, 3, 2, 2, 2, 226, 227, 3, 2, 2, 2, 227, 230, 3, 2, 2, 2, 228,
	226, 3, 2, 2, 2, 229, 221, 3, 2, 2, 2, 229, 230, 3, 2, 2, 2, 230, 231,
	3, 2, 2, 2, 231, 232, 7, 5, 2, 2, 232, 427, 3, 2, 2, 2, 233, 244, 7, 111,
	2, 2, 234, 239, 5, 104, 53, 2, 235, 236, 7, 4, 2, 2, 236, 238, 5, 104,
	53, 2, 237, 235, 3, 2, 2, 2, 238, 241, 3, 2, 2, 2, 239, 237, 3, 2, 2, 2,
	239, 240, 3, 2, 2, 2, 240, 245, 3, 2, 2, 2, 241, 239, 3, 2, 2, 2, 242,
	243, 7, 16, 2, 2, 243, 245, 7, 113, 2, 2, 244, 234, 3, 2, 2, 2, 244, 242,
	3, 2, 2, 2, 245, 246, 3, 2, 2, 2, 246, 248, 7, 86, 2, 2, 247, 249, 7, 102,
	2, 2, 248, 247, 3, 2, 2, 2, 248, 249, 3, 2, 2, 2, 249, 250, 3, 2, 2, 2,
	250, 251, 5, 106, 54, 2, 251, 252, 7, 140, 2, 2, 252, 256, 5, 108, 55,
	2, 253, 254, 7, 97, 2, 2, 254, 255, 7, 111, 2, 2, 255, 257, 7, 115, 2,
	2, 256, 253, 3, 2, 2, 2, 256, 257, 3, 2, 2, 2, 257, 427, 3, 2, 2, 2, 258,
	262, 7, 112, 2, 2, 259, 260, 7, 111, 2, 2, 260, 261, 7, 115, 2, 2, 261,
	263, 7, 51, 2, 2, 262, 259, 3, 2, 2, 2, 262, 263, 3, 2, 2, 2, 263, 274,
	3, 2, 2, 2, 264, 269, 5, 104, 53, 2, 265, 266, 7, 4, 2, 2, 266, 268, 5,
	104, 53, 2, 267, 265, 3, 2, 2, 2, 268, 271, 3, 2, 2, 2, 269, 267, 3, 2,
	2, 2, 269, 270, 3, 2, 2, 2, 270, 275, 3, 2, 2, 2, 271, 269, 3, 2, 2, 2,
	272, 273, 7, 16, 2, 2, 273, 275, 7, 113, 2, 2, 274, 264, 3, 2, 2, 2, 274,
	272, 3, 2, 2, 2, 275, 276, 3, 2, 2, 2, 276, 278, 7, 86, 2, 2, 277, 279,
	7, 102, 2, 2, 278, 277, 3, 2, 2, 2, 278, 279, 3, 2, 2, 2, 279, 280, 3,
	2, 2, 2, 280, 281, 5, 106, 54, 2, 281, 282, 7, 13, 2, 2, 282, 283, 5, 108,
	55, 2, 283, 427, 3, 2, 2, 2, 284, 286, 7, 116, 2, 2, 285, 287, 7, 117,
	2, 2, 286, 285, 3, 2, 2, 2, 286, 287, 3, 2, 2, 2, 287, 299, 3, 2, 2, 2,
	288, 289, 7, 3, 2, 2, 289, 294, 5, 96, 49, 2, 290, 291, 7, 4, 2, 2, 291,
	293, 5, 96, 49, 2, 292, 290, 3, 2, 2, 2, 293, 296, 3, 2, 2, 2, 294, 292,
	3, 2, 2, 2, 294, 295, 3, 2, 2, 2, 295, 297, 3, 2, 2, 2, 296, 294, 3, 2,
	2, 2, 297, 298, 7, 5, 2, 2, 298, 300, 3, 2, 2, 2, 299, 288, 3, 2, 2, 2,
	299, 300, 3, 2, 2, 2, 300, 301, 3, 2, 2, 2, 301, 427, 5, 4, 3, 2, 302,
	303, 7, 127, 2, 2, 303, 304, 7, 100, 2, 2, 304, 305, 7, 102, 2, 2, 305,
	427, 5, 106, 54, 2, 306, 307, 7, 127, 2, 2, 307, 308, 7, 100, 2, 2, 308,
	309, 7, 104, 2, 2, 309, 427, 5, 106, 54, 2, 310, 311, 7, 127, 2, 2, 311,
	314, 7, 128, 2, 2, 312, 313, 9, 2, 2, 2, 313, 315, 5, 106, 54, 2, 314,
	312, 3, 2, 2, 2, 314, 315, 3, 2, 2, 2, 315, 318, 3, 2, 2, 2, 316, 317,
	7, 38, 2, 2, 317, 319, 7, 204, 2, 2, 318, 316, 3, 2, 2, 2, 318, 319, 3,
	2, 2, 2, 319, 427, 3, 2, 2, 2, 320, 321, 7, 127, 2, 2, 321, 324, 7, 129,
	2, 2, 322, 323, 9, 2, 2, 2, 323, 325, 5, 108, 55, 2, 324, 322, 3, 2, 2,
	2, 324, 325, 3, 2, 2, 2, 325, 328, 3, 2, 2, 2, 326, 327, 7, 38, 2, 2, 327,
	329, 7, 204, 2, 2, 328, 326, 3, 2, 2, 2, 328, 329, 3, 2, 2, 2, 329, 427,
	3, 2, 2, 2, 330, 331, 7, 127, 2, 2, 331, 334, 7, 130, 2, 2, 332, 333, 7,
	38, 2, 2, 333, 335, 7, 204, 2, 2, 334, 332, 3, 2, 2, 2, 334, 335, 3, 2,
	2, 2, 335, 427, 3, 2, 2, 2, 336, 337, 7, 127, 2, 2, 337, 338, 7, 131, 2,
	2, 338, 339, 9, 2, 2, 2, 339, 427, 5, 106, 54, 2, 340, 341, 9, 3, 2, 2,
	341, 427, 5, 106, 54, 2, 342, 343, 7, 127, 2, 2, 343, 427, 7, 135, 2, 2,
	344, 345, 7, 127, 2, 2, 345, 427, 7, 153, 2, 2, 346, 347, 7, 151, 2, 2,
	347, 348, 7, 153, 2, 2, 348, 349, 5, 106, 54, 2, 349, 350, 7, 191, 2, 2,
	350, 351, 5, 58, 30, 2, 351, 427, 3, 2, 2, 2, 352, 353, 7, 152, 2, 2, 353,
	354, 7, 153, 2, 2, 354, 427, 5, 106, 54, 2, 355, 356, 7, 155, 2, 2, 356,
	365, 7, 156, 2, 2, 357, 362, 5, 98, 50, 2, 358, 359, 7, 4, 2, 2, 359, 361,
	5, 98, 50, 2, 360, 358, 3, 2, 2, 2, 361, 364, 3, 2, 2, 2, 362, 360, 3,
	2, 2, 2, 362, 363, 3, 2, 2, 2, 363, 366, 3, 2, 2, 2, 364, 362, 3, 2, 2,
	2, 365, 357, 3, 2, 2, 2, 365, 366, 3, 2, 2, 2, 366, 427, 3, 2, 2, 2, 367,
	369, 7, 157, 2, 2, 368, 370, 7, 159, 2, 2, 369, 368, 3, 2, 2, 2, 369, 370,
	3, 2, 2, 2, 370, 427, 3, 2, 2, 2, 371, 373, 7, 158, 2, 2, 372, 374, 7,
	159, 2, 2, 373, 372, 3, 2, 2, 2, 373, 374, 3, 2, 2, 2, 374, 427, 3, 2,
	2, 2, 375, 376, 7, 127, 2, 2, 376, 377, 7, 134, 2, 2, 377, 378, 9, 2, 2,
	2, 378, 381, 5, 106, 54, 2, 379, 380, 7, 20, 2, 2, 380, 382, 5, 60, 31,
	2, 381, 379, 3, 2, 2, 2, 381, 382, 3, 2, 2, 2, 382, 393, 3, 2, 2, 2, 383,
	384, 7, 27, 2, 2, 384, 385, 7, 22, 2, 2, 385, 390, 5, 26, 14, 2, 386, 387,
	7, 4, 2, 2, 387, 389, 5, 26, 14, 2, 388, 386, 3, 2, 2, 2, 389, 392, 3,
	2, 2, 2, 390, 388, 3, 2, 2, 2, 390, 391, 3, 2, 2, 2, 391, 394, 3, 2, 2,
	2, 392, 390, 3, 2, 2, 2, 393, 383, 3, 2, 2, 2, 393, 394, 3, 2, 2, 2, 394,
	397, 3, 2, 2, 2, 395, 396, 7, 29, 2, 2, 396, 398, 7, 206, 2, 2, 397, 395,
	3, 2, 2, 2, 397, 398, 3, 2, 2, 2, 398, 427, 3, 2, 2, 2, 399, 400, 7, 170,
	2, 2, 400, 401, 5, 108, 55, 2, 401, 402, 7, 13, 2, 2, 402, 403, 5, 4, 3,
	2, 403, 427, 3, 2, 2, 2, 404, 405, 7, 171, 2, 2, 405, 406, 7, 170, 2, 2,
	406, 427, 5, 108, 55, 2, 407, 408, 7, 172, 2, 2, 408, 418, 5, 108, 55,
	2, 409, 410, 7, 85, 2, 2, 410, 415, 5, 58, 30, 2, 411, 412, 7, 4, 2, 2,
	412, 414, 5, 58, 30, 2, 413, 411, 3, 2, 2, 2, 414, 417, 3, 2, 2, 2, 415,
	413, 3, 2, 2, 2, 415, 416, 3, 2, 2, 2, 416, 419, 3, 2, 2, 2, 417, 415,
	3, 2, 2, 2, 418, 409, 3, 2, 2, 2, 418, 419, 3, 2, 2, 2, 419, 427, 3, 2,
	2, 2, 420, 421, 7, 110, 2, 2, 421, 422, 7, 173, 2, 2, 422, 427, 5, 108,
	55, 2, 423, 424, 7, 110, 2, 2, 424, 425, 7, 174, 2, 2, 425, 427, 5, 108,
	55, 2, 426, 115, 3, 2, 2, 2, 426, 116, 3, 2, 2, 2, 426, 138, 3, 2, 2, 2,
	426, 153, 3, 2, 2, 2, 426, 160, 3, 2, 2, 2, 426, 168, 3, 2, 2, 2, 426,
	175, 3, 2, 2, 2, 426, 182, 3, 2, 2, 2, 426, 191, 3, 2, 2, 2, 426, 198,
	3, 2, 2, 2, 426, 211, 3, 2, 2, 2, 426, 218, 3, 2, 2, 2, 426, 233, 3, 2,
	2, 2, 426, 258, 3, 2, 2, 2, 426, 284, 3, 2, 2, 2, 426, 302, 3, 2, 2, 2,
	426, 306, 3, 2, 2, 2, 426, 310, 3, 2, 2, 2, 426, 320, 3, 2, 2, 2, 426,
	330, 3, 2, 2, 2, 426, 336, 3, 2, 2, 2, 426, 340, 3, 2, 2, 2, 426, 342,
	3, 2, 2, 2, 426, 344, 3, 2, 2, 2, 426, 346, 3, 2, 2, 2, 426, 352, 3, 2,
	2, 2, 426, 355, 3, 2, 2, 2, 426, 367, 3, 2, 2, 2, 426, 371, 3, 2, 2, 2,
	426, 375, 3, 2, 2, 2, 426, 399, 3, 2, 2, 2, 426, 404, 3, 2, 2, 2, 426,
	407, 3, 2, 2, 2, 426, 420, 3, 2, 2, 2, 426, 423, 3, 2, 2, 2, 427, 5, 3,
	2, 2, 2, 428, 430, 5, 8, 5, 2, 429, 428, 3, 2, 2, 2, 429, 430, 3, 2, 2,
	2, 430, 431, 3, 2, 2, 2, 431, 432, 5, 20, 11, 2, 432, 7, 3, 2, 2, 2, 433,
	435, 7, 97, 2, 2, 434, 436, 7, 98, 2, 2, 435, 434, 3, 2, 2, 2, 435, 436,
	3, 2, 2, 2, 436, 437, 3, 2, 2, 2, 437, 442, 5, 38, 20, 2, 438, 439, 7,
	4, 2, 2, 439, 441, 5, 38, 20, 2, 440, 438, 3, 2, 2, 2, 441, 444, 3, 2,
	2, 2, 442, 440, 3, 2, 2, 2, 442, 443, 3, 2, 2, 2, 443, 9, 3, 2, 2, 2, 444,
	442, 3, 2, 2, 2, 445, 448, 5, 12, 7, 2, 446, 448, 5, 14, 8, 2, 447, 445,
	3, 2, 2, 2, 447, 446, 3, 2, 2, 2, 448, 11, 3, 2, 2, 2, 449, 450, 5, 108,
	55, 2, 450, 453, 5, 80, 41, 2, 451, 452, 7, 103, 2, 2, 452, 454, 7, 204,
	2, 2, 453, 451, 3, 2, 2, 2, 453, 454, 3, 2, 2, 2, 454, 13, 3, 2, 2, 2,
	455, 456, 7, 38, 2, 2, 456, 459, 5, 106, 54, 2, 457, 458, 9, 4, 2, 2, 458,
	460, 7, 179, 2, 2, 459, 457, 3, 2, 2, 2, 459, 460, 3, 2, 2, 2, 460, 15,
	3, 2, 2, 2, 461, 462, 7, 3, 2, 2, 462, 467, 5, 18, 10, 2, 463, 464, 7,
	4, 2, 2, 464, 466, 5, 18, 10, 2, 465, 463, 3, 2, 2, 2, 466, 469, 3, 2,
	2, 2, 467, 465, 3, 2, 2, 2, 467, 468, 3, 2, 2, 2, 468, 470, 3, 2, 2, 2,
	469, 467, 3, 2, 2, 2, 470, 471, 7, 5, 2, 2, 471, 17, 3, 2, 2, 2, 472, 473,
	5, 108, 55, 2, 473, 474, 7, 191, 2, 2, 474, 475, 5, 58, 30, 2, 475, 19,
	3, 2, 2, 2, 476, 487, 5, 22, 12, 2, 477, 478, 7, 27, 2, 2, 478, 479, 7,
	22, 2, 2, 479, 484, 5, 26, 14, 2, 480, 481, 7, 4, 2, 2, 481, 483, 5, 26,
	14, 2, 482, 480, 3, 2, 2, 2, 483, 486, 3, 2, 2, 2, 484, 482, 3, 2, 2, 2,
	484, 485, 3, 2, 2, 2, 485, 488, 3, 2, 2, 2, 486, 484, 3, 2, 2, 2, 487,
	477, 3, 2, 2, 2, 487, 488, 3, 2, 2, 2, 488, 491, 3, 2, 2, 2, 489, 490,
	7, 29, 2, 2, 490, 492, 7, 206, 2, 2, 491, 489, 3, 2, 2, 2, 491, 492, 3,
	2, 2, 2, 492, 21, 3, 2, 2, 2, 493, 494, 8, 12, 1, 2, 494, 495, 5, 24, 13,
	2, 495, 504, 3, 2, 2, 2, 496, 497, 12, 3, 2, 2, 497, 499, 9, 5, 2, 2, 498,
	500, 5, 40, 21, 2, 499, 498, 3, 2, 2, 2, 499, 500, 3, 2, 2, 2, 500, 501,
	3, 2, 2, 2, 501, 503, 5, 22, 12, 4, 502, 496, 3, 2, 2, 2, 503, 506, 3,
	2, 2, 2, 504, 502, 3, 2, 2, 2, 504, 505, 3, 2, 2, 2, 505, 23, 3, 2, 2,
	2, 506, 504, 3, 2, 2, 2, 507, 524, 5, 28, 15, 2, 508, 509, 7, 102, 2, 2,
	509, 524, 5, 106, 54, 2, 510, 511, 7, 99, 2, 2, 511, 516, 5, 58, 30, 2,
	512, 513, 7, 4, 2, 2, 513, 515, 5, 58, 30, 2, 514, 512, 3, 2, 2, 2, 515,
	518, 3, 2, 2, 2, 516, 514, 3, 2, 2, 2, 516, 517, 3, 2, 2, 2, 517, 524,
	3, 2, 2, 2, 518, 516, 3, 2, 2, 2, 519, 520, 7, 3, 2, 2, 520, 521, 5, 20,
	11, 2, 521, 522, 7, 5, 2, 2, 522, 524, 3, 2, 2, 2, 523, 507, 3, 2, 2, 2,
	523, 508, 3, 2, 2, 2, 523, 510, 3, 2, 2, 2, 523, 519, 3, 2, 2, 2, 524,
	25, 3, 2, 2, 2, 525, 527, 5, 58, 30, 2, 526, 528, 9, 6, 2, 2, 527, 526,
	3, 2, 2, 2, 527, 528, 3, 2, 2, 2, 528, 531, 3, 2, 2, 2, 529, 530, 7, 43,
	2, 2, 530, 532, 9, 7, 2, 2, 531, 529, 3, 2, 2, 2, 531, 532, 3, 2, 2, 2,
	532, 27, 3, 2, 2, 2, 533, 535, 7, 12, 2, 2, 534, 536, 5, 40, 21, 2, 535,
	534, 3, 2, 2, 2, 535, 536, 3, 2, 2, 2, 536, 537, 3, 2, 2, 2, 537, 542,
	5, 42, 22, 2, 538, 539, 7, 4, 2, 2, 539, 541, 5, 42, 22, 2, 540, 538, 3,
	2, 2, 2, 541, 544, 3, 2, 2, 2, 542, 540, 3, 2, 2, 2, 542, 543, 3, 2, 2,
	2, 543, 554, 3, 2, 2, 2, 544, 542, 3, 2, 2, 2, 545, 546, 7, 13, 2, 2, 546,
	551, 5, 44, 23, 2, 547, 548, 7, 4, 2, 2, 548, 550, 5, 44, 23, 2, 549, 547,
	3, 2, 2, 2, 550, 553, 3, 2, 2, 2, 551, 549, 3, 2, 2, 2, 551, 552, 3, 2,
	2, 2, 552, 555, 3, 2, 2, 2, 553, 551, 3, 2, 2, 2, 554, 545, 3, 2, 2, 2,
	554, 555, 3, 2, 2, 2, 555, 558, 3, 2, 2, 2, 556, 557, 7, 20, 2, 2, 557,
	559, 5, 60, 31, 2, 558, 556, 3, 2, 2, 2, 558, 559, 3, 2, 2, 2, 559, 563,
	3, 2, 2, 2, 560, 561, 7, 21, 2, 2, 561, 562, 7, 22, 2, 2, 562, 564, 5,
	30, 16, 2, 563, 560, 3, 2, 2, 2, 563, 564, 3, 2, 2, 2, 564, 567, 3, 2,
	2, 2, 565, 566, 7, 28, 2, 2, 566, 568, 5, 60, 31, 2, 567, 565, 3, 2, 2,
	2, 567, 568, 3, 2, 2, 2, 568, 29, 3, 2, 2, 2, 569, 571, 5, 40, 21, 2, 570,
	569, 3, 2, 2, 2, 570, 571, 3, 2, 2, 2, 571, 572, 3, 2, 2, 2, 572, 577,
	5, 32, 17, 2, 573, 574, 7, 4, 2, 2, 574, 576, 5, 32, 17, 2, 575, 573, 3,
	2, 2, 2, 576, 579, 3, 2, 2, 2, 577, 575, 3, 2, 2, 2, 577, 578, 3, 2, 2,
	2, 578, 31, 3, 2, 2, 2, 579, 577, 3, 2, 2, 2, 580, 621, 5, 34, 18, 2, 581,
	582, 7, 26, 2, 2, 582, 591, 7, 3, 2, 2, 583, 588, 5, 106, 54, 2, 584, 585,
	7, 4, 2, 2, 585, 587, 5, 106, 54, 2, 586, 584, 3, 2, 2, 2, 587, 590, 3,
	2, 2, 2, 588, 586, 3, 2, 2, 2, 588, 589, 3, 2, 2, 2, 589, 592, 3, 2, 2,
	2, 590, 588, 3, 2, 2, 2, 591, 583, 3, 2, 2, 2, 591, 592, 3, 2, 2, 2, 592,
	593, 3, 2, 2, 2, 593, 621, 7, 5, 2, 2, 594, 595, 7, 25, 2, 2, 595, 604,
	7, 3, 2, 2, 596, 601, 5, 106, 54, 2, 597, 598, 7, 4, 2, 2, 598, 600, 5,
	106, 54, 2, 599, 597, 3, 2, 2, 2, 600, 603, 3, 2, 2, 2, 601, 599, 3, 2,
	2, 2, 601, 602, 3, 2, 2, 2, 602, 605, 3, 2, 2, 2, 603, 601, 3, 2, 2, 2,
	604, 596, 3, 2, 2, 2, 604, 605, 3, 2, 2, 2, 605, 606, 3, 2, 2, 2, 606,
	621, 7, 5, 2, 2, 607, 608, 7, 23, 2, 2, 608, 609, 7, 24, 2, 2, 609, 610,
	7, 3, 2, 2, 610, 615, 5, 36, 19, 2, 611, 612, 7, 4, 2, 2, 612, 614, 5,
	36, 19, 2, 613, 611, 3, 2, 2, 2, 614, 617, 3, 2, 2, 2, 615, 613, 3, 2,
	2, 2, 615, 616, 3, 2, 2, 2, 616, 618, 3, 2, 2, 2, 617, 615, 3, 2, 2, 2,
	618, 619, 7, 5, 2, 2, 619, 621, 3, 2, 2, 2, 620, 580, 3, 2, 2, 2, 620,
	581, 3, 2, 2, 2, 620, 594, 3, 2, 2, 2, 620, 607, 3, 2, 2, 2, 621, 33, 3,
	2, 2, 2, 622, 631, 7, 3, 2, 2, 623, 628, 5, 58, 30, 2, 624, 625, 7, 4,
	2, 2, 625, 627, 5, 58, 30, 2, 626, 624, 3, 2, 2, 2, 627, 630, 3, 2, 2,
	2, 628, 626, 3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629, 632, 3, 2, 2, 2, 630,
	628, 3, 2, 2, 2, 631, 623, 3, 2, 2, 2, 631, 632, 3, 2, 2, 2, 632, 633,
	3, 2, 2, 2, 633, 636, 7, 5, 2, 2, 634, 636, 5, 58, 30, 2, 635, 622, 3,
	2, 2, 2, 635, 634, 3, 2, 2, 2, 636, 35, 3, 2, 2, 2, 637, 646, 7, 3, 2,
	2, 638, 643, 5, 106, 54, 2, 639, 640, 7, 4, 2, 2, 640, 642, 5, 106, 54,
	2, 641, 639, 3, 2, 2, 2, 642, 645, 3, 2, 2, 2, 643, 641, 3, 2, 2, 2, 643,
	644, 3, 2, 2, 2, 644, 647, 3, 2, 2, 2, 645, 643, 3, 2, 2, 2, 646, 638,
	3, 2, 2, 2, 646, 647, 3, 2, 2, 2, 647, 648, 3, 2, 2, 2, 648, 651, 7, 5,
	2, 2, 649, 651, 5, 106, 54, 2, 650, 637, 3, 2, 2, 2, 650, 649, 3, 2, 2,
	2, 651, 37, 3, 2, 2, 2, 652, 654, 5, 108, 55, 2, 653, 655, 5, 54, 28, 2,
	654, 653, 3, 2, 2, 2, 654, 655, 3, 2, 2, 2, 655, 656, 3, 2, 2, 2, 656,
	657, 7, 15, 2, 2, 657, 658, 7, 3, 2, 2, 658, 659, 5, 6, 4, 2, 659, 660,
	7, 5, 2, 2, 660, 39, 3, 2, 2, 2, 661, 662, 9, 8, 2, 2, 662, 41, 3, 2, 2,
	2, 663, 668, 5, 58, 30, 2, 664, 666, 7, 15, 2, 2, 665, 664, 3, 2, 2, 2,
	665, 666, 3, 2, 2, 2, 666, 667, 3, 2, 2, 2, 667, 669, 5, 108, 55, 2, 668,
	665, 3, 2, 2, 2, 668, 669, 3, 2, 2, 2, 669, 676, 3, 2, 2, 2, 670, 671,
	5, 106, 54, 2, 671, 672, 7, 203, 2, 2, 672, 673, 7, 199, 2, 2, 673, 676,
	3, 2, 2, 2, 674, 676, 7, 199, 2, 2, 675, 663, 3, 2, 2, 2, 675, 670, 3,
	2, 2, 2, 675, 674, 3, 2, 2, 2, 676, 43, 3, 2, 2, 2, 677, 678, 8, 23, 1,
	2, 678, 679, 5, 50, 26, 2, 679, 691, 3, 2, 2, 2, 680, 682, 12, 4, 2, 2,
	681, 683, 5, 46, 24, 2, 682, 681, 3, 2, 2, 2, 682, 683, 3, 2, 2, 2, 683,
	684, 3, 2, 2, 2, 684, 685, 7, 77, 2, 2, 685, 687, 5, 44, 23, 2, 686, 688,
	5, 48, 25, 2, 687, 686, 3, 2, 2, 2, 687, 688, 3, 2, 2, 2, 688, 690, 3,
	2, 2, 2, 689, 680, 3, 2, 2, 2, 690, 693, 3, 2, 2, 2, 691, 689, 3, 2, 2,
	2, 691, 692, 3, 2, 2, 2, 692, 45, 3, 2, 2, 2, 693, 691, 3, 2, 2, 2, 694,
	705, 7, 80, 2, 2, 695, 696, 7, 81, 2, 2, 696, 705, 7, 79, 2, 2, 697, 698,
	7, 82, 2, 2, 698, 705, 7, 79, 2, 2, 699, 700, 7, 83, 2, 2, 700, 705, 7,
	79, 2, 2, 701, 705, 7, 78, 2, 2, 702, 705, 7, 84, 2, 2, 703, 705, 7, 81,
	2, 2, 704, 694, 3, 2, 2, 2, 704, 695, 3, 2, 2, 2, 704, 697, 3, 2, 2, 2,
	704, 699, 3, 2, 2, 2, 704, 701, 3, 2, 2, 2, 704, 702, 3, 2, 2, 2, 704,
	703, 3, 2, 2, 2, 705, 47, 3, 2, 2, 2, 706, 707, 7, 86, 2, 2, 707, 721,
	5, 60, 31, 2, 708, 709, 7, 85, 2, 2, 709, 710, 7, 3, 2, 2, 710, 715, 5,
	108, 55, 2, 711, 712, 7, 4, 2, 2, 712, 714, 5, 108, 55, 2, 713, 711, 3,
	2, 2, 2, 714, 717, 3, 2, 2, 2, 715, 713, 3, 2, 2, 2, 715, 716, 3, 2, 2,
	2, 716, 718, 3, 2, 2, 2, 717, 715, 3, 2, 2, 2, 718, 719, 7, 5, 2, 2, 719,
	721, 3, 2, 2, 2, 720, 706, 3, 2, 2, 2, 720, 708, 3, 2, 2, 2, 721, 49, 3,
	2, 2, 2, 722, 729, 5, 52, 27, 2, 723, 724, 7, 144, 2, 2, 724, 725, 9, 9,
	2, 2, 725, 726, 7, 3, 2, 2, 726, 727, 5, 58, 30, 2, 727, 728, 7, 5, 2,
	2, 728, 730, 3, 2, 2, 2, 729, 723, 3, 2, 2, 2, 729, 730, 3, 2, 2, 2, 730,
	51, 3, 2, 2, 2, 731, 739, 5, 56, 29, 2, 732, 734, 7, 15, 2, 2, 733, 732,
	3, 2, 2, 2, 733, 734, 3, 2, 2, 2, 734, 735, 3, 2, 2, 2, 735, 737, 5, 108,
	55, 2, 736, 738, 5, 54, 28, 2, 737, 736, 3, 2, 2, 2, 737, 738, 3, 2, 2,
	2, 738, 740, 3, 2, 2, 2, 739, 733, 3, 2, 2, 2, 739, 740, 3, 2, 2, 2, 740,
	53, 3, 2, 2, 2, 741, 742, 7, 3, 2, 2, 742, 747, 5, 108, 55, 2, 743, 744,
	7, 4, 2, 2, 744, 746, 5, 108, 55, 2, 745, 743, 3, 2, 2, 2, 746, 749, 3,
	2, 2, 2, 747, 745, 3, 2, 2, 2, 747, 748, 3, 2, 2, 2, 748, 750, 3, 2, 2,
	2, 749, 747, 3, 2, 2, 2, 750, 751, 7, 5, 2, 2, 751, 55, 3, 2, 2, 2, 752,
	777, 5, 106, 54, 2, 753, 754, 7, 3, 2, 2, 754, 755, 5, 6, 4, 2, 755, 756,
	7, 5, 2, 2, 756, 777, 3, 2, 2, 2, 757, 758, 7, 147, 2, 2, 758, 759, 7,
	3, 2, 2, 759, 764, 5, 58, 30, 2, 760, 761, 7, 4, 2, 2, 761, 763, 5, 58,
	30, 2, 762, 760, 3, 2, 2, 2, 763, 766, 3, 2, 2, 2, 764, 762, 3, 2, 2, 2,
	764, 765, 3, 2, 2, 2, 765, 767, 3, 2, 2, 2, 766, 764, 3, 2, 2, 2, 767,
	770, 7, 5, 2, 2, 768, 769, 7, 97, 2, 2, 769, 771, 7, 148, 2, 2, 770, 768,
	3, 2, 2, 2, 770, 771, 3, 2, 2, 2, 771, 777, 3, 2, 2, 2, 772, 773, 7, 3,
	2, 2, 773, 774, 5, 44, 23, 2, 774, 775, 7, 5, 2, 2, 775, 777, 3, 2, 2,
	2, 776, 752, 3, 2, 2, 2, 776, 753, 3, 2, 2, 2, 776, 757, 3, 2, 2, 2, 776,
	772, 3, 2, 2, 2, 777, 57, 3, 2, 2, 2, 778, 781, 5, 60, 31, 2, 779, 781,
	5, 66, 34, 2, 780, 778, 3, 2, 2, 2, 780, 779, 3, 2, 2, 2, 781, 59, 3, 2,
	2, 2, 782, 783, 8, 31, 1, 2, 783, 784, 5, 66, 34, 2, 784, 785, 5, 64, 33,
	2, 785, 790, 3, 2, 2, 2, 786, 787, 7, 34, 2, 2, 787, 790, 5, 60, 31, 5,
	788, 790, 5, 62, 32, 2, 789, 782, 3, 2, 2, 2, 789, 786, 3, 2, 2, 2, 789,
	788, 3, 2, 2, 2, 790, 796, 3, 2, 2, 2, 791, 792, 12, 4, 2, 2, 792, 793,
	9, 10, 2, 2, 793, 795, 5, 58, 30, 2, 794, 791, 3, 2, 2, 2, 795, 798, 3,
	2, 2, 2, 796, 794, 3, 2, 2, 2, 796, 797, 3, 2, 2, 2, 797, 61, 3, 2, 2,
	2, 798, 796, 3, 2, 2, 2, 799, 800, 9, 11, 2, 2, 800, 63, 3, 2, 2, 2, 801,
	802, 5, 72, 37, 2, 802, 803, 5, 66, 34, 2, 803, 863, 3, 2, 2, 2, 804, 805,
	5, 72, 37, 2, 805, 806, 5, 74, 38, 2, 806, 807, 7, 3, 2, 2, 807, 808, 5,
	6, 4, 2, 808, 809, 7, 5, 2, 2, 809, 863, 3, 2, 2, 2, 810, 812, 7, 34, 2,
	2, 811, 810, 3, 2, 2, 2, 811, 812, 3, 2, 2, 2, 812, 813, 3, 2, 2, 2, 813,
	814, 7, 37, 2, 2, 814, 815, 5, 66, 34, 2, 815, 816, 7, 32, 2, 2, 816, 817,
	5, 66, 34, 2, 817, 863, 3, 2, 2, 2, 818, 820, 7, 34, 2, 2, 819, 818, 3,
	2, 2, 2, 819, 820, 3, 2, 2, 2, 820, 821, 3, 2, 2, 2, 821, 822, 7, 33, 2,
	2, 822, 823, 7, 3, 2, 2, 823, 828, 5, 66, 34, 2, 824, 825, 7, 4, 2, 2,
	825, 827, 5, 66, 34, 2, 826, 824, 3, 2, 2, 2, 827, 830, 3, 2, 2, 2, 828,
	826, 3, 2, 2, 2, 828, 829, 3, 2, 2, 2, 829, 831, 3, 2, 2, 2, 830, 828,
	3, 2, 2, 2, 831, 832, 7, 5, 2, 2, 832, 863, 3, 2, 2, 2, 833, 835, 7, 34,
	2, 2, 834, 833, 3, 2, 2, 2, 834, 835, 3, 2, 2, 2, 835, 836, 3, 2, 2, 2,
	836, 837, 7, 33, 2, 2, 837, 838, 7, 3, 2, 2, 838, 839, 5, 6, 4, 2, 839,
	840, 7, 5, 2, 2, 840, 863, 3, 2, 2, 2, 841, 843, 7, 34, 2, 2, 842, 841,
	3, 2, 2, 2, 842, 843, 3, 2, 2, 2, 843, 844, 3, 2, 2, 2, 844, 845, 7, 38,
	2, 2, 845, 848, 5, 66, 34, 2, 846, 847, 7, 46, 2, 2, 847, 849, 5, 66, 34,
	2, 848, 846, 3, 2, 2, 2, 848, 849, 3, 2, 2, 2, 849, 863, 3, 2, 2, 2, 850,
	852, 7, 39, 2, 2, 851, 853, 7, 34, 2, 2, 852, 851, 3, 2, 2, 2, 852, 853,
	3, 2, 2, 2, 853, 854, 3, 2, 2, 2, 854, 863, 7, 40, 2, 2, 855, 857, 7, 39,
	2, 2, 856, 858, 7, 34, 2, 2, 857, 856, 3, 2, 2, 2, 857, 858, 3, 2, 2, 2,
	858, 859, 3, 2, 2, 2, 859, 860, 7, 19, 2, 2, 860, 861, 7, 13, 2, 2, 861,
	863, 5, 66, 34, 2, 862, 801, 3, 2, 2, 2, 862, 804, 3, 2, 2, 2, 862, 811,
	3, 2, 2, 2, 862, 819, 3, 2, 2, 2, 862, 834, 3, 2, 2, 2, 862, 842, 3, 2,
	2, 2, 862, 850, 3, 2, 2, 2, 862, 855, 3, 2, 2, 2, 863, 65, 3, 2, 2, 2,
	864, 865, 8, 34, 1, 2, 865, 869, 5, 68, 35, 2, 866, 867, 9, 12, 2, 2, 867,
	869, 5, 66, 34, 5, 868, 864, 3, 2, 2, 2, 868, 866, 3, 2, 2, 2, 869, 881,
	3, 2, 2, 2, 870, 871, 12, 4, 2, 2, 871, 872, 9, 13, 2, 2, 872, 880, 5,
	66, 34, 5, 873, 874, 12, 3, 2, 2, 874, 875, 7, 202, 2, 2, 875, 880, 5,
	66, 34, 4, 876, 877, 12, 6, 2, 2, 877, 878, 7, 30, 2, 2, 878, 880, 5, 70,
	36, 2, 879, 870, 3, 2, 2, 2, 879, 873, 3, 2, 2, 2, 879, 876, 3, 2, 2, 2,
	880, 883, 3, 2, 2, 2, 881, 879, 3, 2, 2, 2, 881, 882, 3, 2, 2, 2, 882,
	67, 3, 2, 2, 2, 883, 881, 3, 2, 2, 2, 884, 885, 8, 35, 1, 2, 885, 1098,
	7, 40, 2, 2, 886, 1098, 7, 204, 2, 2, 887, 1098, 7, 205, 2, 2, 888, 1098,
	7, 207, 2, 2, 889, 1098, 7, 206, 2, 2, 890, 1098, 5, 62, 32, 2, 891, 892,
	5, 84, 43, 2, 892, 893, 7, 204, 2, 2, 893, 1098, 3, 2, 2, 2, 894, 1098,
	5, 76, 39, 2, 895, 1098, 7, 6, 2, 2, 896, 899, 5, 108, 55, 2, 897, 899,
	7, 190, 2, 2, 898, 896, 3, 2, 2, 2, 898, 897, 3, 2, 2, 2, 899, 900, 3,
	2, 2, 2, 900, 1098, 7, 204, 2, 2, 901, 902, 7, 50, 2, 2, 902, 903, 7, 3,
	2, 2, 903, 904, 5, 66, 34, 2, 904, 905, 7, 33, 2, 2, 905, 906, 5, 66, 34,
	2, 906, 907, 7, 5, 2, 2, 907, 1098, 3, 2, 2, 2, 908, 909, 7, 3, 2, 2, 909,
	912, 5, 58, 30, 2, 910, 911, 7, 4, 2, 2, 911, 913, 5, 58, 30, 2, 912, 910,
	3, 2, 2, 2, 913, 914, 3, 2, 2, 2, 914, 912, 3, 2, 2, 2, 914, 915, 3, 2,
	2, 2, 915, 916, 3, 2, 2, 2, 916, 917, 7, 5, 2, 2, 917, 1098, 3, 2, 2, 2,
	918, 919, 7, 96, 2, 2, 919, 920, 7, 3, 2, 2, 920, 925, 5, 58, 30, 2, 921,
	922, 7, 4, 2, 2, 922, 924, 5, 58, 30, 2, 923, 921, 3, 2, 2, 2, 924, 927,
	3, 2, 2, 2, 925, 923, 3, 2, 2, 2, 925, 926, 3, 2, 2, 2, 926, 928, 3, 2,
	2, 2, 927, 925, 3, 2, 2, 2, 928, 929, 7, 5, 2, 2, 929, 1098, 3, 2, 2, 2,
	930, 931, 5, 106, 54, 2, 931, 932, 7, 3, 2, 2, 932, 933, 7, 199, 2, 2,
	933, 935, 7, 5, 2, 2, 934, 936, 5, 88, 45, 2, 935, 934, 3, 2, 2, 2, 935,
	936, 3, 2, 2, 2, 936, 938, 3, 2, 2, 2, 937, 939, 5, 90, 46, 2, 938, 937,
	3, 2, 2, 2, 938, 939, 3, 2, 2, 2, 939, 1098, 3, 2, 2, 2, 940, 941, 5, 106,
	54, 2, 941, 953, 7, 3, 2, 2, 942, 944, 5, 40, 21, 2, 943, 942, 3, 2, 2,
	2, 943, 944, 3, 2, 2, 2, 944, 945, 3, 2, 2, 2, 945, 950, 5, 58, 30, 2,
	946, 947, 7, 4, 2, 2, 947, 949, 5, 58, 30, 2, 948, 946, 3, 2, 2, 2, 949,
	952, 3, 2, 2, 2, 950, 948, 3, 2, 2, 2, 950, 951, 3, 2, 2, 2, 951, 954,
	3, 2, 2, 2, 952, 950, 3, 2, 2, 2, 953, 943, 3, 2, 2, 2, 953, 954, 3, 2,
	2, 2, 954, 955, 3, 2, 2, 2, 955, 957, 7, 5, 2, 2, 956, 958, 5, 88, 45,
	2, 957, 956, 3, 2, 2, 2, 957, 958, 3, 2, 2, 2, 958, 960, 3, 2, 2, 2, 959,
	961, 5, 90, 46, 2, 960, 959, 3, 2, 2, 2, 960, 961, 3, 2, 2, 2, 961, 1098,
	3, 2, 2, 2, 962, 963, 5, 108, 55, 2, 963, 964, 7, 7, 2, 2, 964, 965, 5,
	58, 30, 2, 965, 1098, 3, 2, 2, 2, 966, 967, 7, 3, 2, 2, 967, 972, 5, 108,
	55, 2, 968, 969, 7, 4, 2, 2, 969, 971, 5, 108, 55, 2, 970, 968, 3, 2, 2,
	2, 971, 974, 3, 2, 2, 2, 972, 970, 3, 2, 2, 2, 972, 973, 3, 2, 2, 2, 973,
	975, 3, 2, 2, 2, 974, 972, 3, 2, 2, 2, 975, 976, 7, 5, 2, 2, 976, 977,
	7, 7, 2, 2, 977, 978, 5, 58, 30, 2, 978, 1098, 3, 2, 2, 2, 979, 980, 7,
	3, 2, 2, 980, 981, 5, 6, 4, 2, 981, 982, 7, 5, 2, 2, 982, 1098, 3, 2, 2,
	2, 983, 984, 7, 36, 2, 2, 984, 985, 7, 3, 2, 2, 985, 986, 5, 6, 4, 2, 986,
	987, 7, 5, 2, 2, 987, 1098, 3, 2, 2, 2, 988, 989, 7, 72, 2, 2, 989, 991,
	5, 66, 34, 2, 990, 992, 5, 86, 44, 2, 991, 990, 3, 2, 2, 2, 992, 993, 3,
	2, 2, 2, 993, 991, 3, 2, 2, 2, 993, 994, 3, 2, 2, 2, 994, 997, 3, 2, 2,
	2, 995, 996, 7, 75, 2, 2, 996, 998, 5, 58, 30, 2, 997, 995, 3, 2, 2, 2,
	997, 998, 3, 2, 2, 2, 998, 999, 3, 2, 2, 2, 999, 1000, 7, 76, 2, 2, 1000,
	1098, 3, 2, 2, 2, 1001, 1003, 7, 72, 2, 2, 1002, 1004, 5, 86, 44, 2, 1003,
	1002, 3, 2, 2, 2, 1004, 1005, 3, 2, 2, 2, 1005, 1003, 3, 2, 2, 2, 1005,
	1006, 3, 2, 2, 2, 1006, 1009, 3, 2, 2, 2, 1007, 1008, 7, 75, 2, 2, 1008,
	1010, 5, 58, 30, 2, 1009, 1007, 3, 2, 2, 2, 1009, 1010, 3, 2, 2, 2, 1010,
	1011, 3, 2, 2, 2, 1011, 1012, 7, 76, 2, 2, 1012, 1098, 3, 2, 2, 2, 1013,
	1014, 7, 125, 2, 2, 1014, 1015, 7, 3, 2, 2, 1015, 1016, 5, 58, 30, 2, 1016,
	1017, 7, 15, 2, 2, 1017, 1018, 5, 80, 41, 2, 1018, 1019, 7, 5, 2, 2, 1019,
	1098, 3, 2, 2, 2, 1020, 1021, 7, 126, 2, 2, 1021, 1022, 7, 3, 2, 2, 1022,
	1023, 5, 58, 30, 2, 1023, 1024, 7, 15, 2, 2, 1024, 1025, 5, 80, 41, 2,
	1025, 1026, 7, 5, 2, 2, 1026, 1098, 3, 2, 2, 2, 1027, 1028, 7, 149, 2,
	2, 1028, 1037, 7, 8, 2, 2, 1029, 1034, 5, 58, 30, 2, 1030, 1031, 7, 4,
	2, 2, 1031, 1033, 5, 58, 30, 2, 1032, 1030, 3, 2, 2, 2, 1033, 1036, 3,
	2, 2, 2, 1034, 1032, 3, 2, 2, 2, 1034, 1035, 3, 2, 2, 2, 1035, 1038, 3,
	2, 2, 2, 1036, 1034, 3, 2, 2, 2, 1037, 1029, 3, 2, 2, 2, 1037, 1038, 3,
	2, 2, 2, 1038, 1039, 3, 2, 2, 2, 1039, 1098, 7, 9, 2, 2, 1040, 1098, 5,
	108, 55, 2, 1041, 1098, 7, 66, 2, 2, 1042, 1046, 7, 67, 2, 2, 1043, 1044,
	7, 3, 2, 2, 1044, 1045, 7, 206, 2, 2, 1045, 1047, 7, 5, 2, 2, 1046, 1043,
	3, 2, 2, 2, 1046, 1047, 3, 2, 2, 2, 1047, 1098, 3, 2, 2, 2, 1048, 1052,
	7, 68, 2, 2, 1049, 1050, 7, 3, 2, 2, 1050, 1051, 7, 206, 2, 2, 1051, 1053,
	7, 5, 2, 2, 1052, 1049, 3, 2, 2, 2, 1052, 1053, 3, 2, 2, 2, 1053, 1098,
	3, 2, 2, 2, 1054, 1058, 7, 69, 2, 2, 1055, 1056, 7, 3, 2, 2, 1056, 1057,
	7, 206, 2, 2, 1057, 1059, 7, 5, 2, 2, 1058, 1055, 3, 2, 2, 2, 1058, 1059,
	3, 2, 2, 2, 1059, 1098, 3, 2, 2, 2, 1060, 1064, 7, 70, 2, 2, 1061, 1062,
	7, 3, 2, 2, 1062, 1063, 7, 206, 2, 2, 1063, 1065, 7, 5, 2, 2, 1064, 1061,
	3, 2, 2, 2, 1064, 1065, 3, 2, 2, 2, 1065, 1098, 3, 2, 2, 2, 1066, 1067,
	7, 49, 2, 2, 1067, 1068, 7, 3, 2, 2, 1068, 1069, 5, 66, 34, 2, 1069, 1070,
	7, 13, 2, 2, 1070, 1073, 5, 66, 34, 2, 1071, 1072, 7, 51, 2, 2, 1072, 1074,
	5, 66, 34, 2, 1073, 1071, 3, 2, 2, 2, 1073, 1074, 3, 2, 2, 2, 1074, 1075,
	3, 2, 2, 2, 1075, 1076, 7, 5, 2, 2, 1076, 1098, 3, 2, 2, 2, 1077, 1078,
	7, 180, 2, 2, 1078, 1079, 7, 3, 2, 2, 1079, 1082, 5, 66, 34, 2, 1080, 1081,
	7, 4, 2, 2, 1081, 1083, 9, 14, 2, 2, 1082, 1080, 3, 2, 2, 2, 1082, 1083,
	3, 2, 2, 2, 1083, 1084, 3, 2, 2, 2, 1084, 1085, 7, 5, 2, 2, 1085, 1098,
	3, 2, 2, 2, 1086, 1087, 7, 71, 2, 2, 1087, 1088, 7, 3, 2, 2, 1088, 1089,
	5, 108, 55, 2, 1089, 1090, 7, 13, 2, 2, 1090, 1091, 5, 66, 34, 2, 1091,
	1092, 7, 5, 2, 2, 1092, 1098, 3, 2, 2, 2, 1093, 1094, 7, 3, 2, 2, 1094,
	1095, 5, 58, 30, 2, 1095, 1096, 7, 5, 2, 2, 1096, 1098, 3, 2, 2, 2, 1097,
	884, 3, 2, 2, 2, 1097, 886, 3, 2, 2, 2, 1097, 887, 3, 2, 2, 2, 1097, 888,
	3, 2, 2, 2, 1097, 889, 3, 2, 2, 2, 1097, 890, 3, 2, 2, 2, 1097, 891, 3,
	2, 2, 2, 1097, 894, 3, 2, 2, 2, 1097, 895, 3, 2, 2, 2, 1097, 898, 3, 2,
	2, 2, 1097, 901, 3, 2, 2, 2, 1097, 908, 3, 2, 2, 2, 1097, 918, 3, 2, 2,
	2, 1097, 930, 3, 2, 2, 2, 1097, 940, 3, 2, 2, 2, 1097, 962, 3, 2, 2, 2,
	1097, 966, 3, 2, 2, 2, 1097, 979, 3, 2, 2, 2, 1097, 983, 3, 2, 2, 2, 1097,
	988, 3, 2, 2, 2, 1097, 1001, 3, 2, 2, 2, 1097, 1013, 3, 2, 2, 2, 1097,
	1020, 3, 2, 2, 2, 1097, 1027, 3, 2, 2, 2, 1097, 1040, 3, 2, 2, 2, 1097,
	1041, 3, 2, 2, 2, 1097, 1042, 3, 2, 2, 2, 1097, 1048, 3, 2, 2, 2, 1097,
	1054, 3, 2, 2, 2, 1097, 1060, 3, 2, 2, 2, 1097, 1066, 3, 2, 2, 2, 1097,
	1077, 3, 2, 2, 2, 1097, 1086, 3, 2, 2, 2, 1097, 1093, 3, 2, 2, 2, 1098,
	1109, 3, 2, 2, 2, 1099, 1100, 12, 14, 2, 2, 1100, 1101, 7, 8, 2, 2, 1101,
	1102, 5, 66, 34, 2, 1102, 1103, 7, 9, 2, 2, 1103, 1108, 3, 2, 2, 2, 1104,
	1105, 12, 12, 2, 2, 1105, 1106, 7, 203, 2, 2, 1106, 1108, 5, 108, 55, 2,
	1107, 1099, 3, 2, 2, 2, 1107, 1104, 3, 2, 2, 2, 1108, 1111, 3, 2, 2, 2,
	1109, 1107, 3, 2, 2, 2, 1109, 1110, 3, 2, 2, 2, 1110, 69, 3, 2, 2, 2, 1111,
	1109, 3, 2, 2, 2, 1112, 1113, 7, 56, 2, 2, 1113, 1114, 7, 65, 2, 2, 1114,
	1119, 5, 76, 39, 2, 1115, 1116, 7, 56, 2, 2, 1116, 1117, 7, 65, 2, 2, 1117,
	1119, 7, 204, 2, 2, 1118, 1112, 3, 2, 2, 2, 1118, 1115, 3, 2, 2, 2, 1119,
	71, 3, 2, 2, 2, 1120, 1121, 9, 15, 2, 2, 1121, 73, 3, 2, 2, 2, 1122, 1123,
	9, 16, 2, 2, 1123, 75, 3, 2, 2, 2, 1124, 1126, 7, 58, 2, 2, 1125, 1127,
	9, 12, 2, 2, 1126, 1125, 3, 2, 2, 2, 1126, 1127, 3, 2, 2, 2, 1127, 1128,
	3, 2, 2, 2, 1128, 1129, 7, 204, 2, 2, 1129, 1132, 5, 78, 40, 2, 1130, 1131,
	7, 140, 2, 2, 1131, 1133, 5, 78, 40, 2, 1132, 1130, 3, 2, 2, 2, 1132, 1133,
	3, 2, 2, 2, 1133, 77, 3, 2, 2, 2, 1134, 1135, 9, 17, 2, 2, 1135, 79, 3,
	2, 2, 2, 1136, 1137, 8, 41, 1, 2, 1137, 1138, 7, 149, 2, 2, 1138, 1139,
	7, 193, 2, 2, 1139, 1140, 5, 80, 41, 2, 1140, 1141, 7, 195, 2, 2, 1141,
	1179, 3, 2, 2, 2, 1142, 1143, 7, 150, 2, 2, 1143, 1144, 7, 193, 2, 2, 1144,
	1145, 5, 80, 41, 2, 1145, 1146, 7, 4, 2, 2, 1146, 1147, 5, 80, 41, 2, 1147,
	1148, 7, 195, 2, 2, 1148, 1179, 3, 2, 2, 2, 1149, 1150, 7, 96, 2, 2, 1150,
	1151, 7, 3, 2, 2, 1151, 1152, 5, 108, 55, 2, 1152, 1159, 5, 80, 41, 2,
	1153, 1154, 7, 4, 2, 2, 1154, 1155, 5, 108, 55, 2, 1155, 1156, 5, 80, 41,
	2, 1156, 1158, 3, 2, 2, 2, 1157, 1153, 3, 2, 2, 2, 1158, 1161, 3, 2, 2,
	2, 1159, 1157, 3, 2, 2, 2, 1159, 1160, 3, 2, 2, 2, 1160, 1162, 3, 2, 2,
	2, 1161, 1159, 3, 2, 2, 2, 1162, 1163, 7, 5, 2, 2, 1163, 1179, 3, 2, 2,
	2, 1164, 1176, 5, 84, 43, 2, 1165, 1166, 7, 3, 2, 2, 1166, 1171, 5, 82,
	42, 2, 1167, 1168, 7, 4, 2, 2, 1168, 1170, 5, 82, 42, 2, 1169, 1167, 3,
	2, 2, 2, 1170, 1173, 3, 2, 2, 2, 1171, 1169, 3, 2, 2, 2, 1171, 1172, 3,
	2, 2, 2, 1172, 1174, 3, 2, 2, 2, 1173, 1171, 3, 2, 2, 2, 1174, 1175, 7,
	5, 2, 2, 1175, 1177, 3, 2, 2, 2, 1176, 1165, 3, 2, 2, 2, 1176, 1177, 3,
	2, 2, 2, 1177, 1179, 3, 2, 2, 2, 1178, 1136, 3, 2, 2, 2, 1178, 1142, 3,
	2, 2, 2, 1178, 1149, 3, 2, 2, 2, 1178, 1164, 3, 2, 2, 2, 1179, 1184, 3,
	2, 2, 2, 1180, 1181, 12, 7, 2, 2, 1181, 1183, 7, 149, 2, 2, 1182, 1180,
	3, 2, 2, 2, 1183, 1186, 3, 2, 2, 2, 1184, 1182, 3, 2, 2, 2, 1184, 1185,
	3, 2, 2, 2, 1185, 81, 3, 2, 2, 2, 1186, 1184, 3, 2, 2, 2, 1187, 1190, 7,
	206, 2, 2, 1188, 1190, 5, 80, 41, 2, 1189, 1187, 3, 2, 2, 2, 1189, 1188,
	3, 2, 2, 2, 1190, 83, 3, 2, 2, 2, 1191, 1197, 7, 188, 2, 2, 1192, 1197,
	7, 189, 2, 2, 1193, 1197, 7, 55, 2, 2, 1194, 1197, 7, 190, 2, 2, 1195,
	1197, 5, 108, 55, 2, 1196, 1191, 3, 2, 2, 2, 1196, 1192, 3, 2, 2, 2, 1196,
	1193, 3, 2, 2, 2, 1196, 1194, 3, 2, 2, 2, 1196, 1195, 3, 2, 2, 2, 1197,
	85, 3, 2, 2, 2, 1198, 1199, 7, 73, 2, 2, 1199, 1200, 5, 58, 30, 2, 1200,
	1201, 7, 74, 2, 2, 1201, 1202, 5, 58, 30, 2, 1202, 87, 3, 2, 2, 2, 1203,
	1204, 7, 87, 2, 2, 1204, 1205, 7, 3, 2, 2, 1205, 1206, 7, 20, 2, 2, 1206,
	1207, 5, 60, 31, 2, 1207, 1208, 7, 5, 2, 2, 1208, 89, 3, 2, 2, 2, 1209,
	1210, 7, 88, 2, 2, 1210, 1221, 7, 3, 2, 2, 1211, 1212, 7, 89, 2, 2, 1212,
	1213, 7, 22, 2, 2, 1213, 1218, 5, 58, 30, 2, 1214, 1215, 7, 4, 2, 2, 1215,
	1217, 5, 58, 30, 2, 1216, 1214, 3, 2, 2, 2, 1217, 1220, 3, 2, 2, 2, 1218,
	1216, 3, 2, 2, 2, 1218, 1219, 3, 2, 2, 2, 1219, 1222, 3, 2, 2, 2, 1220,
	1218, 3, 2, 2, 2, 1221, 1211, 3, 2, 2, 2, 1221, 1222, 3, 2, 2, 2, 1222,
	1233, 3, 2, 2, 2, 1223, 1224, 7, 27, 2, 2, 1224, 1225, 7, 22, 2, 2, 1225,
	1230, 5, 26, 14, 2, 1226, 1227, 7, 4, 2, 2, 1227, 1229, 5, 26, 14, 2, 1228,
	1226, 3, 2, 2, 2, 1229, 1232, 3, 2, 2, 2, 1230, 1228, 3, 2, 2, 2, 1230,
	1231, 3, 2, 2, 2, 1231, 1234, 3, 2, 2, 2, 1232, 1230, 3, 2, 2, 2, 1233,
	1223, 3, 2, 2, 2, 1233, 1234, 3, 2, 2, 2, 1234, 1236, 3, 2, 2, 2, 1235,
	1237, 5, 92, 47, 2, 1236, 1235, 3, 2, 2, 2, 1236, 1237, 3, 2, 2, 2, 1237,
	1238, 3, 2, 2, 2, 1238, 1239, 7, 5, 2, 2, 1239, 91, 3, 2, 2, 2, 1240, 1241,
	9, 18, 2, 2, 1241, 1249, 5, 94, 48, 2, 1242, 1243, 9, 18, 2, 2, 1243, 1244,
	7, 37, 2, 2, 1244, 1245, 5, 94, 48, 2, 1245, 1246, 7, 32, 2, 2, 1246, 1247,
	5, 94, 48, 2, 1247, 1249, 3, 2, 2, 2, 1248, 1240, 3, 2, 2, 2, 1248, 1242,
	3, 2, 2, 2, 1249, 93, 3, 2, 2, 2, 1250, 1251, 7, 92, 2, 2, 1251, 1258,
	9, 19, 2, 2, 1252, 1253, 7, 95, 2, 2, 1253, 1258, 7, 96, 2, 2, 1254, 1255,
	5, 58, 30, 2, 1255, 1256, 9, 19, 2, 2, 1256, 1258, 3, 2, 2, 2, 1257, 1250,
	3, 2, 2, 2, 1257, 1252, 3, 2, 2, 2, 1257, 1254, 3, 2, 2, 2, 1258, 95, 3,
	2, 2, 2, 1259, 1260, 7, 118, 2, 2, 1260, 1264, 9, 20, 2, 2, 1261, 1262,
	7, 119, 2, 2, 1262, 1264, 9, 21, 2, 2, 1263, 1259, 3, 2, 2, 2, 1263, 1261,
	3, 2, 2, 2, 1264, 97, 3, 2, 2, 2, 1265, 1266, 7, 160, 2, 2, 1266, 1267,
	7, 161, 2, 2, 1267, 1271, 5, 100, 51, 2, 1268, 1269, 7, 166, 2, 2, 1269,
	1271, 9, 22, 2, 2, 1270, 1265, 3, 2, 2, 2, 1270, 1268, 3, 2, 2, 2, 1271,
	99, 3, 2, 2, 2, 1272, 1273, 7, 166, 2, 2, 1273, 1280, 7, 165, 2, 2, 1274,
	1275, 7, 166, 2, 2, 1275, 1280, 7, 164, 2, 2, 1276, 1277, 7, 163, 2, 2,
	1277, 1280, 7, 166, 2, 2, 1278, 1280, 7, 162, 2, 2, 1279, 1272, 3, 2, 2,
	2, 1279, 1274, 3, 2, 2, 2, 1279, 1276, 3, 2, 2, 2, 1279, 1278, 3, 2, 2,
	2, 1280, 101, 3, 2, 2, 2, 1281, 1287, 5, 58, 30, 2, 1282, 1283, 5, 108,
	55, 2, 1283, 1284, 7, 10, 2, 2, 1284, 1285, 5, 58, 30, 2, 1285, 1287, 3,
	2, 2, 2, 1286, 1281, 3, 2, 2, 2, 1286, 1282, 3, 2, 2, 2, 1287, 103, 3,
	2, 2, 2, 1288, 1293, 7, 12, 2, 2, 1289, 1293, 7, 107, 2, 2, 1290, 1293,
	7, 106, 2, 2, 1291, 1293, 5, 108, 55, 2, 1292, 1288, 3, 2, 2, 2, 1292,
	1289, 3, 2, 2, 2, 1292, 1290, 3, 2, 2, 2, 1292, 1291, 3, 2, 2, 2, 1293,
	105, 3, 2, 2, 2, 1294, 1299, 5, 108, 55, 2, 1295, 1296, 7, 203, 2, 2, 1296,
	1298, 5, 108, 55, 2, 1297, 1295, 3, 2, 2, 2, 1298, 1301, 3, 2, 2, 2, 1299,
	1297, 3, 2, 2, 2, 1299, 1300, 3, 2, 2, 2, 1300, 107, 3, 2, 2, 2, 1301,
	1299, 3, 2, 2, 2, 1302, 1308, 7, 208, 2, 2, 1303, 1308, 7, 209, 2, 2, 1304,
	1308, 7, 210, 2, 2, 1305, 1308, 7, 211, 2, 2, 1306, 1308, 5, 110, 56, 2,
	1307, 1302, 3, 2, 2, 2, 1307, 1303, 3, 2, 2, 2, 1307, 1304, 3, 2, 2, 2,
	1307, 1305, 3, 2, 2, 2, 1307, 1306, 3, 2, 2, 2, 1308, 109, 3, 2, 2, 2,
	1309, 1310, 9, 23, 2, 2, 1310, 111, 3, 2, 2, 2, 162, 121, 130, 136, 143,
	148, 157, 164, 173, 201, 206, 215, 226, 229, 239, 244, 248, 256, 262, 269,
	274, 278, 286, 294, 299, 314, 318, 324, 328, 334, 362, 365, 369, 373, 381,
	390, 393, 397, 415, 418, 426, 429, 435, 442, 447, 453, 459, 467, 484, 487,
	491, 499, 504, 516, 523, 527, 531, 535, 542, 551, 554, 558, 563, 567, 570,
	577, 588, 591, 601, 604, 615, 620, 628, 631, 635, 643, 646, 650, 654, 665,
	668, 675, 682, 687, 691, 704, 715, 720, 729, 733, 737, 739, 747, 764, 770,
	776, 780, 789, 796, 811, 819, 828, 834, 842, 848, 852, 857, 862, 868, 879,
	881, 898, 914, 925, 935, 938, 943, 950, 953, 957, 960, 972, 993, 997, 1005,
	1009, 1034, 1037, 1046, 1052, 1058, 1064, 1073, 1082, 1097, 1107, 1109,
	1118, 1126, 1132, 1159, 1171, 1176, 1178, 1184, 1189, 1196, 1218, 1221,
	1230, 1233, 1236, 1248, 1257, 1263, 1270, 1279, 1286, 1292, 1299, 1307,
}

var deserializer = antlr.NewATNDeserializer(nil)

var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'('", "','", "')'", "'?'", "'->'", "'['", "']'", "'=>'", "';'", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'='",
	"", "'<'", "'<='", "'>'", "'>='", "'+'", "'-'", "'*'", "'/'", "'%'", "'||'",
	"'.'",
}

var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "SEMICOLON", "SELECT", "FROM", "ADD",
	"AS", "ALL", "SOME", "ANY", "DISTINCT", "WHERE", "GROUP", "BY", "GROUPING",
	"SETS", "CUBE", "ROLLUP", "ORDER", "HAVING", "LIMIT", "AT", "OR", "AND",
	"IN", "NOT", "NO", "EXISTS", "BETWEEN", "LIKE", "IS", "NULL", "TRUE", "FALSE",
	"NULLS", "FIRST", "LAST", "ESCAPE", "ASC", "DESC", "SUBSTRING", "POSITION",
	"FOR", "TINYINT", "SMALLINT", "INTEGER", "DATE", "TIME", "TIMESTAMP", "INTERVAL",
	"YEAR", "MONTH", "DAY", "HOUR", "MINUTE", "SECOND", "ZONE", "CURRENT_DATE",
	"CURRENT_TIME", "CURRENT_TIMESTAMP", "LOCALTIME", "LOCALTIMESTAMP", "EXTRACT",
	"CASE", "WHEN", "THEN", "ELSE", "END", "JOIN", "CROSS", "OUTER", "INNER",
	"LEFT", "RIGHT", "FULL", "NATURAL", "USING", "ON", "FILTER", "OVER", "PARTITION",
	"RANGE", "ROWS", "UNBOUNDED", "PRECEDING", "FOLLOWING", "CURRENT", "ROW",
	"WITH", "RECURSIVE", "VALUES", "CREATE", "SCHEMA", "TABLE", "COMMENT",
	"VIEW", "REPLACE", "INSERT", "DELETE", "INTO", "CONSTRAINT", "DESCRIBE",
	"GRANT", "REVOKE", "PRIVILEGES", "PUBLIC", "OPTION", "EXPLAIN", "ANALYZE",
	"FORMAT", "TYPE", "TEXT", "GRAPHVIZ", "LOGICAL", "DISTRIBUTED", "VALIDATE",
	"CAST", "TRY_CAST", "SHOW", "TABLES", "SCHEMAS", "CATALOGS", "COLUMNS",
	"COLUMN", "USE", "PARTITIONS", "FUNCTIONS", "DROP", "UNION", "EXCEPT",
	"INTERSECT", "TO", "SYSTEM", "BERNOULLI", "POISSONIZED", "TABLESAMPLE",
	"ALTER", "RENAME", "UNNEST", "ORDINALITY", "ARRAY", "MAP", "SET", "RESET",
	"SESSION", "DATA", "START", "TRANSACTION", "COMMIT", "ROLLBACK", "WORK",
	"ISOLATION", "LEVEL", "SERIALIZABLE", "REPEATABLE", "COMMITTED", "UNCOMMITTED",
	"READ", "WRITE", "ONLY", "CALL", "PREPARE", "DEALLOCATE", "EXECUTE", "INPUT",
	"OUTPUT", "CASCADE", "RESTRICT", "INCLUDING", "EXCLUDING", "PROPERTIES",
	"NORMALIZE", "NFD", "NFC", "NFKD", "NFKC", "IF", "NULLIF", "COALESCE",
	"TIME_WITH_TIME_ZONE", "TIMESTAMP_WITH_TIME_ZONE", "DOUBLE_PRECISION",
	"EQ", "NEQ", "LT", "LTE", "GT", "GTE", "PLUS", "MINUS", "ASTERISK", "SLASH",
	"PERCENT", "CONCAT", "DOT", "STRING", "BINARY_LITERAL", "INTEGER_VALUE",
	"DECIMAL_VALUE", "IDENTIFIER", "DIGIT_IDENTIFIER", "QUOTED_IDENTIFIER",
	"BACKQUOTED_IDENTIFIER", "SIMPLE_COMMENT", "BRACKETED_COMMENT", "WS",
}

var ruleNames = []string{
	"statements", "statement", "query", "with", "tableElement", "columnDefinition",
	"likeClause", "tableProperties", "tableProperty", "queryNoWith", "queryTerm",
	"queryPrimary", "sortItem", "querySpecification", "groupBy", "groupingElement",
	"groupingExpressions", "groupingSet", "namedQuery", "setQuantifier", "selectItem",
	"relation", "joinType", "joinCriteria", "sampledRelation", "aliasedRelation",
	"columnAliases", "relationPrimary", "expression", "booleanExpression",
	"booleanliteral", "predicate", "valueExpression", "primaryExpression",
	"timeZoneSpecifier", "comparisonOperator", "comparisonQuantifier", "interval",
	"intervalField", "type_t", "typeParameter", "baseType", "whenClause", "filter",
	"over", "windowFrame", "frameBound", "explainOption", "transactionMode",
	"levelOfIsolation", "callArgument", "privilege", "qualifiedName", "identifier",
	"nonReserved",
}

type SQLBaseParser struct {
	*antlr.BaseParser
}

func NewSQLBaseParser(input antlr.TokenStream) *SQLBaseParser {
	var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	var sharedContextCache = antlr.NewPredictionContextCache()

	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}

	this := new(SQLBaseParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, sharedContextCache)
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SQLBase.g4"

	return this
}

// SQLBaseParser tokens.
const (
	SQLBaseParserEOF                      = antlr.TokenEOF
	SQLBaseParserT__0                     = 1
	SQLBaseParserT__1                     = 2
	SQLBaseParserT__2                     = 3
	SQLBaseParserT__3                     = 4
	SQLBaseParserT__4                     = 5
	SQLBaseParserT__5                     = 6
	SQLBaseParserT__6                     = 7
	SQLBaseParserT__7                     = 8
	SQLBaseParserSEMICOLON                = 9
	SQLBaseParserSELECT                   = 10
	SQLBaseParserFROM                     = 11
	SQLBaseParserADD                      = 12
	SQLBaseParserAS                       = 13
	SQLBaseParserALL                      = 14
	SQLBaseParserSOME                     = 15
	SQLBaseParserANY                      = 16
	SQLBaseParserDISTINCT                 = 17
	SQLBaseParserWHERE                    = 18
	SQLBaseParserGROUP                    = 19
	SQLBaseParserBY                       = 20
	SQLBaseParserGROUPING                 = 21
	SQLBaseParserSETS                     = 22
	SQLBaseParserCUBE                     = 23
	SQLBaseParserROLLUP                   = 24
	SQLBaseParserORDER                    = 25
	SQLBaseParserHAVING                   = 26
	SQLBaseParserLIMIT                    = 27
	SQLBaseParserAT                       = 28
	SQLBaseParserOR                       = 29
	SQLBaseParserAND                      = 30
	SQLBaseParserIN                       = 31
	SQLBaseParserNOT                      = 32
	SQLBaseParserNO                       = 33
	SQLBaseParserEXISTS                   = 34
	SQLBaseParserBETWEEN                  = 35
	SQLBaseParserLIKE                     = 36
	SQLBaseParserIS                       = 37
	SQLBaseParserNULL                     = 38
	SQLBaseParserTRUE                     = 39
	SQLBaseParserFALSE                    = 40
	SQLBaseParserNULLS                    = 41
	SQLBaseParserFIRST                    = 42
	SQLBaseParserLAST                     = 43
	SQLBaseParserESCAPE                   = 44
	SQLBaseParserASC                      = 45
	SQLBaseParserDESC                     = 46
	SQLBaseParserSUBSTRING                = 47
	SQLBaseParserPOSITION                 = 48
	SQLBaseParserFOR                      = 49
	SQLBaseParserTINYINT                  = 50
	SQLBaseParserSMALLINT                 = 51
	SQLBaseParserINTEGER                  = 52
	SQLBaseParserDATE                     = 53
	SQLBaseParserTIME                     = 54
	SQLBaseParserTIMESTAMP                = 55
	SQLBaseParserINTERVAL                 = 56
	SQLBaseParserYEAR                     = 57
	SQLBaseParserMONTH                    = 58
	SQLBaseParserDAY                      = 59
	SQLBaseParserHOUR                     = 60
	SQLBaseParserMINUTE                   = 61
	SQLBaseParserSECOND                   = 62
	SQLBaseParserZONE                     = 63
	SQLBaseParserCURRENT_DATE             = 64
	SQLBaseParserCURRENT_TIME             = 65
	SQLBaseParserCURRENT_TIMESTAMP        = 66
	SQLBaseParserLOCALTIME                = 67
	SQLBaseParserLOCALTIMESTAMP           = 68
	SQLBaseParserEXTRACT                  = 69
	SQLBaseParserCASE                     = 70
	SQLBaseParserWHEN                     = 71
	SQLBaseParserTHEN                     = 72
	SQLBaseParserELSE                     = 73
	SQLBaseParserEND                      = 74
	SQLBaseParserJOIN                     = 75
	SQLBaseParserCROSS                    = 76
	SQLBaseParserOUTER                    = 77
	SQLBaseParserINNER                    = 78
	SQLBaseParserLEFT                     = 79
	SQLBaseParserRIGHT                    = 80
	SQLBaseParserFULL                     = 81
	SQLBaseParserNATURAL                  = 82
	SQLBaseParserUSING                    = 83
	SQLBaseParserON                       = 84
	SQLBaseParserFILTER                   = 85
	SQLBaseParserOVER                     = 86
	SQLBaseParserPARTITION                = 87
	SQLBaseParserRANGE                    = 88
	SQLBaseParserROWS                     = 89
	SQLBaseParserUNBOUNDED                = 90
	SQLBaseParserPRECEDING                = 91
	SQLBaseParserFOLLOWING                = 92
	SQLBaseParserCURRENT                  = 93
	SQLBaseParserROW                      = 94
	SQLBaseParserWITH                     = 95
	SQLBaseParserRECURSIVE                = 96
	SQLBaseParserVALUES                   = 97
	SQLBaseParserCREATE                   = 98
	SQLBaseParserSCHEMA                   = 99
	SQLBaseParserTABLE                    = 100
	SQLBaseParserCOMMENT                  = 101
	SQLBaseParserVIEW                     = 102
	SQLBaseParserREPLACE                  = 103
	SQLBaseParserINSERT                   = 104
	SQLBaseParserDELETE                   = 105
	SQLBaseParserINTO                     = 106
	SQLBaseParserCONSTRAINT               = 107
	SQLBaseParserDESCRIBE                 = 108
	SQLBaseParserGRANT                    = 109
	SQLBaseParserREVOKE                   = 110
	SQLBaseParserPRIVILEGES               = 111
	SQLBaseParserPUBLIC                   = 112
	SQLBaseParserOPTION                   = 113
	SQLBaseParserEXPLAIN                  = 114
	SQLBaseParserANALYZE                  = 115
	SQLBaseParserFORMAT                   = 116
	SQLBaseParserTYPE                     = 117
	SQLBaseParserTEXT                     = 118
	SQLBaseParserGRAPHVIZ                 = 119
	SQLBaseParserLOGICAL                  = 120
	SQLBaseParserDISTRIBUTED              = 121
	SQLBaseParserVALIDATE                 = 122
	SQLBaseParserCAST                     = 123
	SQLBaseParserTRY_CAST                 = 124
	SQLBaseParserSHOW                     = 125
	SQLBaseParserTABLES                   = 126
	SQLBaseParserSCHEMAS                  = 127
	SQLBaseParserCATALOGS                 = 128
	SQLBaseParserCOLUMNS                  = 129
	SQLBaseParserCOLUMN                   = 130
	SQLBaseParserUSE                      = 131
	SQLBaseParserPARTITIONS               = 132
	SQLBaseParserFUNCTIONS                = 133
	SQLBaseParserDROP                     = 134
	SQLBaseParserUNION                    = 135
	SQLBaseParserEXCEPT                   = 136
	SQLBaseParserINTERSECT                = 137
	SQLBaseParserTO                       = 138
	SQLBaseParserSYSTEM                   = 139
	SQLBaseParserBERNOULLI                = 140
	SQLBaseParserPOISSONIZED              = 141
	SQLBaseParserTABLESAMPLE              = 142
	SQLBaseParserALTER                    = 143
	SQLBaseParserRENAME                   = 144
	SQLBaseParserUNNEST                   = 145
	SQLBaseParserORDINALITY               = 146
	SQLBaseParserARRAY                    = 147
	SQLBaseParserMAP                      = 148
	SQLBaseParserSET                      = 149
	SQLBaseParserRESET                    = 150
	SQLBaseParserSESSION                  = 151
	SQLBaseParserDATA                     = 152
	SQLBaseParserSTART                    = 153
	SQLBaseParserTRANSACTION              = 154
	SQLBaseParserCOMMIT                   = 155
	SQLBaseParserROLLBACK                 = 156
	SQLBaseParserWORK                     = 157
	SQLBaseParserISOLATION                = 158
	SQLBaseParserLEVEL                    = 159
	SQLBaseParserSERIALIZABLE             = 160
	SQLBaseParserREPEATABLE               = 161
	SQLBaseParserCOMMITTED                = 162
	SQLBaseParserUNCOMMITTED              = 163
	SQLBaseParserREAD                     = 164
	SQLBaseParserWRITE                    = 165
	SQLBaseParserONLY                     = 166
	SQLBaseParserCALL                     = 167
	SQLBaseParserPREPARE                  = 168
	SQLBaseParserDEALLOCATE               = 169
	SQLBaseParserEXECUTE                  = 170
	SQLBaseParserINPUT                    = 171
	SQLBaseParserOUTPUT                   = 172
	SQLBaseParserCASCADE                  = 173
	SQLBaseParserRESTRICT                 = 174
	SQLBaseParserINCLUDING                = 175
	SQLBaseParserEXCLUDING                = 176
	SQLBaseParserPROPERTIES               = 177
	SQLBaseParserNORMALIZE                = 178
	SQLBaseParserNFD                      = 179
	SQLBaseParserNFC                      = 180
	SQLBaseParserNFKD                     = 181
	SQLBaseParserNFKC                     = 182
	SQLBaseParserIF                       = 183
	SQLBaseParserNULLIF                   = 184
	SQLBaseParserCOALESCE                 = 185
	SQLBaseParserTIME_WITH_TIME_ZONE      = 186
	SQLBaseParserTIMESTAMP_WITH_TIME_ZONE = 187
	SQLBaseParserDOUBLE_PRECISION         = 188
	SQLBaseParserEQ                       = 189
	SQLBaseParserNEQ                      = 190
	SQLBaseParserLT                       = 191
	SQLBaseParserLTE                      = 192
	SQLBaseParserGT                       = 193
	SQLBaseParserGTE                      = 194
	SQLBaseParserPLUS                     = 195
	SQLBaseParserMINUS                    = 196
	SQLBaseParserASTERISK                 = 197
	SQLBaseParserSLASH                    = 198
	SQLBaseParserPERCENT                  = 199
	SQLBaseParserCONCAT                   = 200
	SQLBaseParserDOT                      = 201
	SQLBaseParserSTRING                   = 202
	SQLBaseParserBINARY_LITERAL           = 203
	SQLBaseParserINTEGER_VALUE            = 204
	SQLBaseParserDECIMAL_VALUE            = 205
	SQLBaseParserIDENTIFIER               = 206
	SQLBaseParserDIGIT_IDENTIFIER         = 207
	SQLBaseParserQUOTED_IDENTIFIER        = 208
	SQLBaseParserBACKQUOTED_IDENTIFIER    = 209
	SQLBaseParserSIMPLE_COMMENT           = 210
	SQLBaseParserBRACKETED_COMMENT        = 211
	SQLBaseParserWS                       = 212
)

// SQLBaseParser rules.
const (
	SQLBaseParserRULE_statements           = 0
	SQLBaseParserRULE_statement            = 1
	SQLBaseParserRULE_query                = 2
	SQLBaseParserRULE_with                 = 3
	SQLBaseParserRULE_tableElement         = 4
	SQLBaseParserRULE_columnDefinition     = 5
	SQLBaseParserRULE_likeClause           = 6
	SQLBaseParserRULE_tableProperties      = 7
	SQLBaseParserRULE_tableProperty        = 8
	SQLBaseParserRULE_queryNoWith          = 9
	SQLBaseParserRULE_queryTerm            = 10
	SQLBaseParserRULE_queryPrimary         = 11
	SQLBaseParserRULE_sortItem             = 12
	SQLBaseParserRULE_querySpecification   = 13
	SQLBaseParserRULE_groupBy              = 14
	SQLBaseParserRULE_groupingElement      = 15
	SQLBaseParserRULE_groupingExpressions  = 16
	SQLBaseParserRULE_groupingSet          = 17
	SQLBaseParserRULE_namedQuery           = 18
	SQLBaseParserRULE_setQuantifier        = 19
	SQLBaseParserRULE_selectItem           = 20
	SQLBaseParserRULE_relation             = 21
	SQLBaseParserRULE_joinType             = 22
	SQLBaseParserRULE_joinCriteria         = 23
	SQLBaseParserRULE_sampledRelation      = 24
	SQLBaseParserRULE_aliasedRelation      = 25
	SQLBaseParserRULE_columnAliases        = 26
	SQLBaseParserRULE_relationPrimary      = 27
	SQLBaseParserRULE_expression           = 28
	SQLBaseParserRULE_booleanExpression    = 29
	SQLBaseParserRULE_booleanliteral       = 30
	SQLBaseParserRULE_predicate            = 31
	SQLBaseParserRULE_valueExpression      = 32
	SQLBaseParserRULE_primaryExpression    = 33
	SQLBaseParserRULE_timeZoneSpecifier    = 34
	SQLBaseParserRULE_comparisonOperator   = 35
	SQLBaseParserRULE_comparisonQuantifier = 36
	SQLBaseParserRULE_interval             = 37
	SQLBaseParserRULE_intervalField        = 38
	SQLBaseParserRULE_type_t               = 39
	SQLBaseParserRULE_typeParameter        = 40
	SQLBaseParserRULE_baseType             = 41
	SQLBaseParserRULE_whenClause           = 42
	SQLBaseParserRULE_filter               = 43
	SQLBaseParserRULE_over                 = 44
	SQLBaseParserRULE_windowFrame          = 45
	SQLBaseParserRULE_frameBound           = 46
	SQLBaseParserRULE_explainOption        = 47
	SQLBaseParserRULE_transactionMode      = 48
	SQLBaseParserRULE_levelOfIsolation     = 49
	SQLBaseParserRULE_callArgument         = 50
	SQLBaseParserRULE_privilege            = 51
	SQLBaseParserRULE_qualifiedName        = 52
	SQLBaseParserRULE_identifier           = 53
	SQLBaseParserRULE_nonReserved          = 54
)

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSEMICOLON, 0)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *SQLBaseParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SQLBaseParserRULE_statements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(110)
		p.Statement()
	}
	{
		p.SetState(111)
		p.Match(SQLBaseParserSEMICOLON)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyFrom(ctx *StatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExplainContext struct {
	*StatementContext
}

func NewExplainContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainContext {
	var p = new(ExplainContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEXPLAIN, 0)
}

func (s *ExplainContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExplainContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserANALYZE, 0)
}

func (s *ExplainContext) AllExplainOption() []IExplainOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExplainOptionContext)(nil)).Elem())
	var tst = make([]IExplainOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExplainOptionContext)
		}
	}

	return tst
}

func (s *ExplainContext) ExplainOption(i int) IExplainOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplainOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExplainOptionContext)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitExplain(s)
	}
}

type PrepareContext struct {
	*StatementContext
}

func NewPrepareContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrepareContext {
	var p = new(PrepareContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *PrepareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPREPARE, 0)
}

func (s *PrepareContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrepareContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFROM, 0)
}

func (s *PrepareContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *PrepareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterPrepare(s)
	}
}

func (s *PrepareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitPrepare(s)
	}
}

type CreateTableContext struct {
	*StatementContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLE, 0)
}

func (s *CreateTableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableContext) AllTableElement() []ITableElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableElementContext)(nil)).Elem())
	var tst = make([]ITableElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableElementContext)
		}
	}

	return tst
}

func (s *CreateTableContext) TableElement(i int) ITableElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableElementContext)
}

func (s *CreateTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIF, 0)
}

func (s *CreateTableContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNOT, 0)
}

func (s *CreateTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEXISTS, 0)
}

func (s *CreateTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWITH, 0)
}

func (s *CreateTableContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

type StartTransactionContext struct {
	*StatementContext
}

func NewStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StartTransactionContext {
	var p = new(StartTransactionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *StartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSTART, 0)
}

func (s *StartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTRANSACTION, 0)
}

func (s *StartTransactionContext) AllTransactionMode() []ITransactionModeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITransactionModeContext)(nil)).Elem())
	var tst = make([]ITransactionModeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITransactionModeContext)
		}
	}

	return tst
}

func (s *StartTransactionContext) TransactionMode(i int) ITransactionModeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransactionModeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITransactionModeContext)
}

func (s *StartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterStartTransaction(s)
	}
}

func (s *StartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitStartTransaction(s)
	}
}

type CreateTableAsSelectContext struct {
	*StatementContext
}

func NewCreateTableAsSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableAsSelectContext {
	var p = new(CreateTableAsSelectContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTableAsSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsSelectContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCREATE, 0)
}

func (s *CreateTableAsSelectContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLE, 0)
}

func (s *CreateTableAsSelectContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableAsSelectContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserAS, 0)
}

func (s *CreateTableAsSelectContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableAsSelectContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIF, 0)
}

func (s *CreateTableAsSelectContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNOT, 0)
}

func (s *CreateTableAsSelectContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEXISTS, 0)
}

func (s *CreateTableAsSelectContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWITH, 0)
}

func (s *CreateTableAsSelectContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateTableAsSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterCreateTableAsSelect(s)
	}
}

func (s *CreateTableAsSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitCreateTableAsSelect(s)
	}
}

type DeallocateContext struct {
	*StatementContext
}

func NewDeallocateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeallocateContext {
	var p = new(DeallocateContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DeallocateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocateContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDEALLOCATE, 0)
}

func (s *DeallocateContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPREPARE, 0)
}

func (s *DeallocateContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DeallocateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterDeallocate(s)
	}
}

func (s *DeallocateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitDeallocate(s)
	}
}

type RenameTableContext struct {
	*StatementContext
	from IQualifiedNameContext
	to   IQualifiedNameContext
}

func NewRenameTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameTableContext {
	var p = new(RenameTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RenameTableContext) GetFrom() IQualifiedNameContext { return s.from }

func (s *RenameTableContext) GetTo() IQualifiedNameContext { return s.to }

func (s *RenameTableContext) SetFrom(v IQualifiedNameContext) { s.from = v }

func (s *RenameTableContext) SetTo(v IQualifiedNameContext) { s.to = v }

func (s *RenameTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserALTER, 0)
}

func (s *RenameTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLE, 0)
}

func (s *RenameTableContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserRENAME, 0)
}

func (s *RenameTableContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTO, 0)
}

func (s *RenameTableContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *RenameTableContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterRenameTable(s)
	}
}

func (s *RenameTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitRenameTable(s)
	}
}

type CommitContext struct {
	*StatementContext
}

func NewCommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommitContext {
	var p = new(CommitContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCOMMIT, 0)
}

func (s *CommitContext) WORK() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWORK, 0)
}

func (s *CommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterCommit(s)
	}
}

func (s *CommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitCommit(s)
	}
}

type RevokeContext struct {
	*StatementContext
	grantee IIdentifierContext
}

func NewRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeContext {
	var p = new(RevokeContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RevokeContext) GetGrantee() IIdentifierContext { return s.grantee }

func (s *RevokeContext) SetGrantee(v IIdentifierContext) { s.grantee = v }

func (s *RevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserREVOKE, 0)
}

func (s *RevokeContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserON, 0)
}

func (s *RevokeContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFROM, 0)
}

func (s *RevokeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RevokeContext) AllPrivilege() []IPrivilegeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrivilegeContext)(nil)).Elem())
	var tst = make([]IPrivilegeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrivilegeContext)
		}
	}

	return tst
}

func (s *RevokeContext) Privilege(i int) IPrivilegeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *RevokeContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserALL, 0)
}

func (s *RevokeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPRIVILEGES, 0)
}

func (s *RevokeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserGRANT, 0)
}

func (s *RevokeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserOPTION, 0)
}

func (s *RevokeContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFOR, 0)
}

func (s *RevokeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLE, 0)
}

func (s *RevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterRevoke(s)
	}
}

func (s *RevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitRevoke(s)
	}
}

type ShowPartitionsContext struct {
	*StatementContext
	limit antlr.Token
}

func NewShowPartitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPartitionsContext {
	var p = new(ShowPartitionsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowPartitionsContext) GetLimit() antlr.Token { return s.limit }

func (s *ShowPartitionsContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *ShowPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPartitionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSHOW, 0)
}

func (s *ShowPartitionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPARTITIONS, 0)
}

func (s *ShowPartitionsContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowPartitionsContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFROM, 0)
}

func (s *ShowPartitionsContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIN, 0)
}

func (s *ShowPartitionsContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWHERE, 0)
}

func (s *ShowPartitionsContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ShowPartitionsContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserORDER, 0)
}

func (s *ShowPartitionsContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserBY, 0)
}

func (s *ShowPartitionsContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *ShowPartitionsContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowPartitionsContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLIMIT, 0)
}

func (s *ShowPartitionsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINTEGER_VALUE, 0)
}

func (s *ShowPartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterShowPartitions(s)
	}
}

func (s *ShowPartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitShowPartitions(s)
	}
}

type DropViewContext struct {
	*StatementContext
}

func NewDropViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropViewContext {
	var p = new(DropViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserVIEW, 0)
}

func (s *DropViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropViewContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIF, 0)
}

func (s *DropViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEXISTS, 0)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitDropView(s)
	}
}

type DeleteContext struct {
	*StatementContext
}

func NewDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteContext {
	var p = new(DeleteContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDELETE, 0)
}

func (s *DeleteContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFROM, 0)
}

func (s *DeleteContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DeleteContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWHERE, 0)
}

func (s *DeleteContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterDelete(s)
	}
}

func (s *DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitDelete(s)
	}
}

type ShowTablesContext struct {
	*StatementContext
	pattern antlr.Token
}

func NewShowTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTablesContext {
	var p = new(ShowTablesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowTablesContext) GetPattern() antlr.Token { return s.pattern }

func (s *ShowTablesContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *ShowTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSHOW, 0)
}

func (s *ShowTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLES, 0)
}

func (s *ShowTablesContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTablesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLIKE, 0)
}

func (s *ShowTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFROM, 0)
}

func (s *ShowTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIN, 0)
}

func (s *ShowTablesContext) STRING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSTRING, 0)
}

func (s *ShowTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterShowTables(s)
	}
}

func (s *ShowTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitShowTables(s)
	}
}

type DescribeInputContext struct {
	*StatementContext
}

func NewDescribeInputContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeInputContext {
	var p = new(DescribeInputContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeInputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeInputContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDESCRIBE, 0)
}

func (s *DescribeInputContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINPUT, 0)
}

func (s *DescribeInputContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeInputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterDescribeInput(s)
	}
}

func (s *DescribeInputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitDescribeInput(s)
	}
}

type ShowCatalogsContext struct {
	*StatementContext
	pattern antlr.Token
}

func NewShowCatalogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogsContext {
	var p = new(ShowCatalogsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCatalogsContext) GetPattern() antlr.Token { return s.pattern }

func (s *ShowCatalogsContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *ShowCatalogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSHOW, 0)
}

func (s *ShowCatalogsContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCATALOGS, 0)
}

func (s *ShowCatalogsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLIKE, 0)
}

func (s *ShowCatalogsContext) STRING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSTRING, 0)
}

func (s *ShowCatalogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterShowCatalogs(s)
	}
}

func (s *ShowCatalogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitShowCatalogs(s)
	}
}

type StatementDefaultContext struct {
	*StatementContext
}

func NewStatementDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementDefaultContext {
	var p = new(StatementDefaultContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *StatementDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementDefaultContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterStatementDefault(s)
	}
}

func (s *StatementDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitStatementDefault(s)
	}
}

type RenameColumnContext struct {
	*StatementContext
	tableName IQualifiedNameContext
	from      IIdentifierContext
	to        IIdentifierContext
}

func NewRenameColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameColumnContext {
	var p = new(RenameColumnContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RenameColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *RenameColumnContext) GetFrom() IIdentifierContext { return s.from }

func (s *RenameColumnContext) GetTo() IIdentifierContext { return s.to }

func (s *RenameColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *RenameColumnContext) SetFrom(v IIdentifierContext) { s.from = v }

func (s *RenameColumnContext) SetTo(v IIdentifierContext) { s.to = v }

func (s *RenameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserALTER, 0)
}

func (s *RenameColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLE, 0)
}

func (s *RenameColumnContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserRENAME, 0)
}

func (s *RenameColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCOLUMN, 0)
}

func (s *RenameColumnContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTO, 0)
}

func (s *RenameColumnContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameColumnContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *RenameColumnContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterRenameColumn(s)
	}
}

func (s *RenameColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitRenameColumn(s)
	}
}

type SetSessionContext struct {
	*StatementContext
}

func NewSetSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSessionContext {
	var p = new(SetSessionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *SetSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSessionContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSET, 0)
}

func (s *SetSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSESSION, 0)
}

func (s *SetSessionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetSessionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEQ, 0)
}

func (s *SetSessionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSetSession(s)
	}
}

func (s *SetSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSetSession(s)
	}
}

type CreateViewContext struct {
	*StatementContext
}

func NewCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateViewContext {
	var p = new(CreateViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserVIEW, 0)
}

func (s *CreateViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserAS, 0)
}

func (s *CreateViewContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateViewContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserOR, 0)
}

func (s *CreateViewContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserREPLACE, 0)
}

func (s *CreateViewContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitCreateView(s)
	}
}

type ShowCreateTableContext struct {
	*StatementContext
}

func NewShowCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateTableContext {
	var p = new(ShowCreateTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSHOW, 0)
}

func (s *ShowCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCREATE, 0)
}

func (s *ShowCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLE, 0)
}

func (s *ShowCreateTableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterShowCreateTable(s)
	}
}

func (s *ShowCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitShowCreateTable(s)
	}
}

type ShowSchemasContext struct {
	*StatementContext
	pattern antlr.Token
}

func NewShowSchemasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSchemasContext {
	var p = new(ShowSchemasContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowSchemasContext) GetPattern() antlr.Token { return s.pattern }

func (s *ShowSchemasContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *ShowSchemasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemasContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSHOW, 0)
}

func (s *ShowSchemasContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSCHEMAS, 0)
}

func (s *ShowSchemasContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSchemasContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLIKE, 0)
}

func (s *ShowSchemasContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFROM, 0)
}

func (s *ShowSchemasContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIN, 0)
}

func (s *ShowSchemasContext) STRING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSTRING, 0)
}

func (s *ShowSchemasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterShowSchemas(s)
	}
}

func (s *ShowSchemasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitShowSchemas(s)
	}
}

type DropTableContext struct {
	*StatementContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLE, 0)
}

func (s *DropTableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEXISTS, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitDropTable(s)
	}
}

type ShowColumnsContext struct {
	*StatementContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSHOW, 0)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowColumnsContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFROM, 0)
}

func (s *ShowColumnsContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIN, 0)
}

func (s *ShowColumnsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDESCRIBE, 0)
}

func (s *ShowColumnsContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDESC, 0)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

type RollbackContext struct {
	*StatementContext
}

func NewRollbackContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollbackContext {
	var p = new(RollbackContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RollbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserROLLBACK, 0)
}

func (s *RollbackContext) WORK() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWORK, 0)
}

func (s *RollbackContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterRollback(s)
	}
}

func (s *RollbackContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitRollback(s)
	}
}

type AddColumnContext struct {
	*StatementContext
	tableName IQualifiedNameContext
	column    IColumnDefinitionContext
}

func NewAddColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnContext {
	var p = new(AddColumnContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *AddColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *AddColumnContext) GetColumn() IColumnDefinitionContext { return s.column }

func (s *AddColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *AddColumnContext) SetColumn(v IColumnDefinitionContext) { s.column = v }

func (s *AddColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserALTER, 0)
}

func (s *AddColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLE, 0)
}

func (s *AddColumnContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserADD, 0)
}

func (s *AddColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCOLUMN, 0)
}

func (s *AddColumnContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AddColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AddColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterAddColumn(s)
	}
}

func (s *AddColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitAddColumn(s)
	}
}

type ResetSessionContext struct {
	*StatementContext
}

func NewResetSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResetSessionContext {
	var p = new(ResetSessionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ResetSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetSessionContext) RESET() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserRESET, 0)
}

func (s *ResetSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSESSION, 0)
}

func (s *ResetSessionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ResetSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterResetSession(s)
	}
}

func (s *ResetSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitResetSession(s)
	}
}

type InsertIntoContext struct {
	*StatementContext
}

func NewInsertIntoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertIntoContext {
	var p = new(InsertIntoContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *InsertIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINSERT, 0)
}

func (s *InsertIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINTO, 0)
}

func (s *InsertIntoContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *InsertIntoContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertIntoContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *InsertIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterInsertInto(s)
	}
}

func (s *InsertIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitInsertInto(s)
	}
}

type ShowSessionContext struct {
	*StatementContext
}

func NewShowSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSessionContext {
	var p = new(ShowSessionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSessionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSHOW, 0)
}

func (s *ShowSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSESSION, 0)
}

func (s *ShowSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterShowSession(s)
	}
}

func (s *ShowSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitShowSession(s)
	}
}

type ExecuteContext struct {
	*StatementContext
}

func NewExecuteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExecuteContext {
	var p = new(ExecuteContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ExecuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEXECUTE, 0)
}

func (s *ExecuteContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExecuteContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserUSING, 0)
}

func (s *ExecuteContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExecuteContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExecuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterExecute(s)
	}
}

func (s *ExecuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitExecute(s)
	}
}

type CallContext struct {
	*StatementContext
}

func NewCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallContext {
	var p = new(CallContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallContext) CALL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCALL, 0)
}

func (s *CallContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CallContext) AllCallArgument() []ICallArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallArgumentContext)(nil)).Elem())
	var tst = make([]ICallArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallArgumentContext)
		}
	}

	return tst
}

func (s *CallContext) CallArgument(i int) ICallArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallArgumentContext)
}

func (s *CallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterCall(s)
	}
}

func (s *CallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitCall(s)
	}
}

type ShowFunctionsContext struct {
	*StatementContext
}

func NewShowFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFunctionsContext {
	var p = new(ShowFunctionsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSHOW, 0)
}

func (s *ShowFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFUNCTIONS, 0)
}

func (s *ShowFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterShowFunctions(s)
	}
}

func (s *ShowFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitShowFunctions(s)
	}
}

type DescribeOutputContext struct {
	*StatementContext
}

func NewDescribeOutputContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeOutputContext {
	var p = new(DescribeOutputContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeOutputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeOutputContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDESCRIBE, 0)
}

func (s *DescribeOutputContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserOUTPUT, 0)
}

func (s *DescribeOutputContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeOutputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterDescribeOutput(s)
	}
}

func (s *DescribeOutputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitDescribeOutput(s)
	}
}

type GrantContext struct {
	*StatementContext
	grantee IIdentifierContext
}

func NewGrantContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantContext {
	var p = new(GrantContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *GrantContext) GetGrantee() IIdentifierContext { return s.grantee }

func (s *GrantContext) SetGrantee(v IIdentifierContext) { s.grantee = v }

func (s *GrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(SQLBaseParserGRANT)
}

func (s *GrantContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(SQLBaseParserGRANT, i)
}

func (s *GrantContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserON, 0)
}

func (s *GrantContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *GrantContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTO, 0)
}

func (s *GrantContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GrantContext) AllPrivilege() []IPrivilegeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrivilegeContext)(nil)).Elem())
	var tst = make([]IPrivilegeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrivilegeContext)
		}
	}

	return tst
}

func (s *GrantContext) Privilege(i int) IPrivilegeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *GrantContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserALL, 0)
}

func (s *GrantContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPRIVILEGES, 0)
}

func (s *GrantContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLE, 0)
}

func (s *GrantContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWITH, 0)
}

func (s *GrantContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserOPTION, 0)
}

func (s *GrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterGrant(s)
	}
}

func (s *GrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitGrant(s)
	}
}

type ShowCreateViewContext struct {
	*StatementContext
}

func NewShowCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateViewContext {
	var p = new(ShowCreateViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSHOW, 0)
}

func (s *ShowCreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCREATE, 0)
}

func (s *ShowCreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserVIEW, 0)
}

func (s *ShowCreateViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterShowCreateView(s)
	}
}

func (s *ShowCreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitShowCreateView(s)
	}
}

func (p *SQLBaseParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SQLBaseParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(424)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(113)
			p.Query()
		}

	case 2:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(114)
			p.Match(SQLBaseParserCREATE)
		}
		{
			p.SetState(115)
			p.Match(SQLBaseParserTABLE)
		}
		p.SetState(119)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(116)
				p.Match(SQLBaseParserIF)
			}
			{
				p.SetState(117)
				p.Match(SQLBaseParserNOT)
			}
			{
				p.SetState(118)
				p.Match(SQLBaseParserEXISTS)
			}

		}
		{
			p.SetState(121)
			p.QualifiedName()
		}
		{
			p.SetState(122)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(123)
			p.TableElement()
		}
		p.SetState(128)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLBaseParserT__1 {
			{
				p.SetState(124)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(125)
				p.TableElement()
			}

			p.SetState(130)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(131)
			p.Match(SQLBaseParserT__2)
		}
		p.SetState(134)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserWITH {
			{
				p.SetState(132)
				p.Match(SQLBaseParserWITH)
			}
			{
				p.SetState(133)
				p.TableProperties()
			}

		}

	case 3:
		localctx = NewCreateTableAsSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(136)
			p.Match(SQLBaseParserCREATE)
		}
		{
			p.SetState(137)
			p.Match(SQLBaseParserTABLE)
		}
		p.SetState(141)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(138)
				p.Match(SQLBaseParserIF)
			}
			{
				p.SetState(139)
				p.Match(SQLBaseParserNOT)
			}
			{
				p.SetState(140)
				p.Match(SQLBaseParserEXISTS)
			}

		}
		{
			p.SetState(143)
			p.QualifiedName()
		}
		p.SetState(146)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserWITH {
			{
				p.SetState(144)
				p.Match(SQLBaseParserWITH)
			}
			{
				p.SetState(145)
				p.TableProperties()
			}

		}
		{
			p.SetState(148)
			p.Match(SQLBaseParserAS)
		}
		{
			p.SetState(149)
			p.Query()
		}

	case 4:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(151)
			p.Match(SQLBaseParserDROP)
		}
		{
			p.SetState(152)
			p.Match(SQLBaseParserTABLE)
		}
		p.SetState(155)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(153)
				p.Match(SQLBaseParserIF)
			}
			{
				p.SetState(154)
				p.Match(SQLBaseParserEXISTS)
			}

		}
		{
			p.SetState(157)
			p.QualifiedName()
		}

	case 5:
		localctx = NewInsertIntoContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(158)
			p.Match(SQLBaseParserINSERT)
		}
		{
			p.SetState(159)
			p.Match(SQLBaseParserINTO)
		}
		{
			p.SetState(160)
			p.QualifiedName()
		}
		p.SetState(162)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(161)
				p.ColumnAliases()
			}

		}
		{
			p.SetState(164)
			p.Query()
		}

	case 6:
		localctx = NewDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(166)
			p.Match(SQLBaseParserDELETE)
		}
		{
			p.SetState(167)
			p.Match(SQLBaseParserFROM)
		}
		{
			p.SetState(168)
			p.QualifiedName()
		}
		p.SetState(171)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserWHERE {
			{
				p.SetState(169)
				p.Match(SQLBaseParserWHERE)
			}
			{
				p.SetState(170)
				p.booleanExpression(0)
			}

		}

	case 7:
		localctx = NewRenameTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(173)
			p.Match(SQLBaseParserALTER)
		}
		{
			p.SetState(174)
			p.Match(SQLBaseParserTABLE)
		}
		{
			p.SetState(175)

			var _x = p.QualifiedName()

			localctx.(*RenameTableContext).from = _x
		}
		{
			p.SetState(176)
			p.Match(SQLBaseParserRENAME)
		}
		{
			p.SetState(177)
			p.Match(SQLBaseParserTO)
		}
		{
			p.SetState(178)

			var _x = p.QualifiedName()

			localctx.(*RenameTableContext).to = _x
		}

	case 8:
		localctx = NewRenameColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(180)
			p.Match(SQLBaseParserALTER)
		}
		{
			p.SetState(181)
			p.Match(SQLBaseParserTABLE)
		}
		{
			p.SetState(182)

			var _x = p.QualifiedName()

			localctx.(*RenameColumnContext).tableName = _x
		}
		{
			p.SetState(183)
			p.Match(SQLBaseParserRENAME)
		}
		{
			p.SetState(184)
			p.Match(SQLBaseParserCOLUMN)
		}
		{
			p.SetState(185)

			var _x = p.Identifier()

			localctx.(*RenameColumnContext).from = _x
		}
		{
			p.SetState(186)
			p.Match(SQLBaseParserTO)
		}
		{
			p.SetState(187)

			var _x = p.Identifier()

			localctx.(*RenameColumnContext).to = _x
		}

	case 9:
		localctx = NewAddColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(189)
			p.Match(SQLBaseParserALTER)
		}
		{
			p.SetState(190)
			p.Match(SQLBaseParserTABLE)
		}
		{
			p.SetState(191)

			var _x = p.QualifiedName()

			localctx.(*AddColumnContext).tableName = _x
		}
		{
			p.SetState(192)
			p.Match(SQLBaseParserADD)
		}
		{
			p.SetState(193)
			p.Match(SQLBaseParserCOLUMN)
		}
		{
			p.SetState(194)

			var _x = p.ColumnDefinition()

			localctx.(*AddColumnContext).column = _x
		}

	case 10:
		localctx = NewCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(196)
			p.Match(SQLBaseParserCREATE)
		}
		p.SetState(199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserOR {
			{
				p.SetState(197)
				p.Match(SQLBaseParserOR)
			}
			{
				p.SetState(198)
				p.Match(SQLBaseParserREPLACE)
			}

		}
		{
			p.SetState(201)
			p.Match(SQLBaseParserVIEW)
		}
		{
			p.SetState(202)
			p.QualifiedName()
		}
		p.SetState(204)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserT__0 {
			{
				p.SetState(203)
				p.ColumnAliases()
			}

		}
		{
			p.SetState(206)
			p.Match(SQLBaseParserAS)
		}
		{
			p.SetState(207)
			p.Query()
		}

	case 11:
		localctx = NewDropViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(209)
			p.Match(SQLBaseParserDROP)
		}
		{
			p.SetState(210)
			p.Match(SQLBaseParserVIEW)
		}
		p.SetState(213)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(211)
				p.Match(SQLBaseParserIF)
			}
			{
				p.SetState(212)
				p.Match(SQLBaseParserEXISTS)
			}

		}
		{
			p.SetState(215)
			p.QualifiedName()
		}

	case 12:
		localctx = NewCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(216)
			p.Match(SQLBaseParserCALL)
		}
		{
			p.SetState(217)
			p.QualifiedName()
		}
		{
			p.SetState(218)
			p.Match(SQLBaseParserT__0)
		}
		p.SetState(227)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQLBaseParserT__0)|(1<<SQLBaseParserT__3)|(1<<SQLBaseParserADD)|(1<<SQLBaseParserALL)|(1<<SQLBaseParserSOME)|(1<<SQLBaseParserANY)|(1<<SQLBaseParserAT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SQLBaseParserNOT-32))|(1<<(SQLBaseParserNO-32))|(1<<(SQLBaseParserEXISTS-32))|(1<<(SQLBaseParserNULL-32))|(1<<(SQLBaseParserTRUE-32))|(1<<(SQLBaseParserFALSE-32))|(1<<(SQLBaseParserSUBSTRING-32))|(1<<(SQLBaseParserPOSITION-32))|(1<<(SQLBaseParserTINYINT-32))|(1<<(SQLBaseParserSMALLINT-32))|(1<<(SQLBaseParserINTEGER-32))|(1<<(SQLBaseParserDATE-32))|(1<<(SQLBaseParserTIME-32))|(1<<(SQLBaseParserTIMESTAMP-32))|(1<<(SQLBaseParserINTERVAL-32))|(1<<(SQLBaseParserYEAR-32))|(1<<(SQLBaseParserMONTH-32))|(1<<(SQLBaseParserDAY-32))|(1<<(SQLBaseParserHOUR-32))|(1<<(SQLBaseParserMINUTE-32))|(1<<(SQLBaseParserSECOND-32))|(1<<(SQLBaseParserZONE-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SQLBaseParserCURRENT_DATE-64))|(1<<(SQLBaseParserCURRENT_TIME-64))|(1<<(SQLBaseParserCURRENT_TIMESTAMP-64))|(1<<(SQLBaseParserLOCALTIME-64))|(1<<(SQLBaseParserLOCALTIMESTAMP-64))|(1<<(SQLBaseParserEXTRACT-64))|(1<<(SQLBaseParserCASE-64))|(1<<(SQLBaseParserFILTER-64))|(1<<(SQLBaseParserOVER-64))|(1<<(SQLBaseParserPARTITION-64))|(1<<(SQLBaseParserRANGE-64))|(1<<(SQLBaseParserROWS-64))|(1<<(SQLBaseParserPRECEDING-64))|(1<<(SQLBaseParserFOLLOWING-64))|(1<<(SQLBaseParserCURRENT-64))|(1<<(SQLBaseParserROW-64)))) != 0) || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(SQLBaseParserSCHEMA-99))|(1<<(SQLBaseParserCOMMENT-99))|(1<<(SQLBaseParserVIEW-99))|(1<<(SQLBaseParserREPLACE-99))|(1<<(SQLBaseParserGRANT-99))|(1<<(SQLBaseParserREVOKE-99))|(1<<(SQLBaseParserPRIVILEGES-99))|(1<<(SQLBaseParserPUBLIC-99))|(1<<(SQLBaseParserOPTION-99))|(1<<(SQLBaseParserEXPLAIN-99))|(1<<(SQLBaseParserANALYZE-99))|(1<<(SQLBaseParserFORMAT-99))|(1<<(SQLBaseParserTYPE-99))|(1<<(SQLBaseParserTEXT-99))|(1<<(SQLBaseParserGRAPHVIZ-99))|(1<<(SQLBaseParserLOGICAL-99))|(1<<(SQLBaseParserDISTRIBUTED-99))|(1<<(SQLBaseParserVALIDATE-99))|(1<<(SQLBaseParserCAST-99))|(1<<(SQLBaseParserTRY_CAST-99))|(1<<(SQLBaseParserSHOW-99))|(1<<(SQLBaseParserTABLES-99))|(1<<(SQLBaseParserSCHEMAS-99))|(1<<(SQLBaseParserCATALOGS-99))|(1<<(SQLBaseParserCOLUMNS-99))|(1<<(SQLBaseParserCOLUMN-99)))) != 0) || (((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(SQLBaseParserUSE-131))|(1<<(SQLBaseParserPARTITIONS-131))|(1<<(SQLBaseParserFUNCTIONS-131))|(1<<(SQLBaseParserTO-131))|(1<<(SQLBaseParserSYSTEM-131))|(1<<(SQLBaseParserBERNOULLI-131))|(1<<(SQLBaseParserPOISSONIZED-131))|(1<<(SQLBaseParserTABLESAMPLE-131))|(1<<(SQLBaseParserARRAY-131))|(1<<(SQLBaseParserMAP-131))|(1<<(SQLBaseParserSET-131))|(1<<(SQLBaseParserRESET-131))|(1<<(SQLBaseParserSESSION-131))|(1<<(SQLBaseParserDATA-131))|(1<<(SQLBaseParserSTART-131))|(1<<(SQLBaseParserTRANSACTION-131))|(1<<(SQLBaseParserCOMMIT-131))|(1<<(SQLBaseParserROLLBACK-131))|(1<<(SQLBaseParserWORK-131))|(1<<(SQLBaseParserISOLATION-131))|(1<<(SQLBaseParserLEVEL-131))|(1<<(SQLBaseParserSERIALIZABLE-131))|(1<<(SQLBaseParserREPEATABLE-131))|(1<<(SQLBaseParserCOMMITTED-131)))) != 0) || (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQLBaseParserUNCOMMITTED-163))|(1<<(SQLBaseParserREAD-163))|(1<<(SQLBaseParserWRITE-163))|(1<<(SQLBaseParserONLY-163))|(1<<(SQLBaseParserCALL-163))|(1<<(SQLBaseParserINPUT-163))|(1<<(SQLBaseParserOUTPUT-163))|(1<<(SQLBaseParserCASCADE-163))|(1<<(SQLBaseParserRESTRICT-163))|(1<<(SQLBaseParserINCLUDING-163))|(1<<(SQLBaseParserEXCLUDING-163))|(1<<(SQLBaseParserPROPERTIES-163))|(1<<(SQLBaseParserNORMALIZE-163))|(1<<(SQLBaseParserNFD-163))|(1<<(SQLBaseParserNFC-163))|(1<<(SQLBaseParserNFKD-163))|(1<<(SQLBaseParserNFKC-163))|(1<<(SQLBaseParserIF-163))|(1<<(SQLBaseParserNULLIF-163))|(1<<(SQLBaseParserCOALESCE-163))|(1<<(SQLBaseParserTIME_WITH_TIME_ZONE-163))|(1<<(SQLBaseParserTIMESTAMP_WITH_TIME_ZONE-163))|(1<<(SQLBaseParserDOUBLE_PRECISION-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQLBaseParserPLUS-195))|(1<<(SQLBaseParserMINUS-195))|(1<<(SQLBaseParserSTRING-195))|(1<<(SQLBaseParserBINARY_LITERAL-195))|(1<<(SQLBaseParserINTEGER_VALUE-195))|(1<<(SQLBaseParserDECIMAL_VALUE-195))|(1<<(SQLBaseParserIDENTIFIER-195))|(1<<(SQLBaseParserDIGIT_IDENTIFIER-195))|(1<<(SQLBaseParserQUOTED_IDENTIFIER-195))|(1<<(SQLBaseParserBACKQUOTED_IDENTIFIER-195)))) != 0) {
			{
				p.SetState(219)
				p.CallArgument()
			}
			p.SetState(224)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(220)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(221)
					p.CallArgument()
				}

				p.SetState(226)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(229)
			p.Match(SQLBaseParserT__2)
		}

	case 13:
		localctx = NewGrantContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(231)
			p.Match(SQLBaseParserGRANT)
		}
		p.SetState(242)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(232)
				p.Privilege()
			}
			p.SetState(237)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(233)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(234)
					p.Privilege()
				}

				p.SetState(239)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		case 2:
			{
				p.SetState(240)
				p.Match(SQLBaseParserALL)
			}
			{
				p.SetState(241)
				p.Match(SQLBaseParserPRIVILEGES)
			}

		}
		{
			p.SetState(244)
			p.Match(SQLBaseParserON)
		}
		p.SetState(246)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserTABLE {
			{
				p.SetState(245)
				p.Match(SQLBaseParserTABLE)
			}

		}
		{
			p.SetState(248)
			p.QualifiedName()
		}
		{
			p.SetState(249)
			p.Match(SQLBaseParserTO)
		}
		{
			p.SetState(250)

			var _x = p.Identifier()

			localctx.(*GrantContext).grantee = _x
		}
		p.SetState(254)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserWITH {
			{
				p.SetState(251)
				p.Match(SQLBaseParserWITH)
			}
			{
				p.SetState(252)
				p.Match(SQLBaseParserGRANT)
			}
			{
				p.SetState(253)
				p.Match(SQLBaseParserOPTION)
			}

		}

	case 14:
		localctx = NewRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(256)
			p.Match(SQLBaseParserREVOKE)
		}
		p.SetState(260)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(257)
				p.Match(SQLBaseParserGRANT)
			}
			{
				p.SetState(258)
				p.Match(SQLBaseParserOPTION)
			}
			{
				p.SetState(259)
				p.Match(SQLBaseParserFOR)
			}

		}
		p.SetState(272)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(262)
				p.Privilege()
			}
			p.SetState(267)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(263)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(264)
					p.Privilege()
				}

				p.SetState(269)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		case 2:
			{
				p.SetState(270)
				p.Match(SQLBaseParserALL)
			}
			{
				p.SetState(271)
				p.Match(SQLBaseParserPRIVILEGES)
			}

		}
		{
			p.SetState(274)
			p.Match(SQLBaseParserON)
		}
		p.SetState(276)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserTABLE {
			{
				p.SetState(275)
				p.Match(SQLBaseParserTABLE)
			}

		}
		{
			p.SetState(278)
			p.QualifiedName()
		}
		{
			p.SetState(279)
			p.Match(SQLBaseParserFROM)
		}
		{
			p.SetState(280)

			var _x = p.Identifier()

			localctx.(*RevokeContext).grantee = _x
		}

	case 15:
		localctx = NewExplainContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(282)
			p.Match(SQLBaseParserEXPLAIN)
		}
		p.SetState(284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserANALYZE {
			{
				p.SetState(283)
				p.Match(SQLBaseParserANALYZE)
			}

		}
		p.SetState(297)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(286)
				p.Match(SQLBaseParserT__0)
			}
			{
				p.SetState(287)
				p.ExplainOption()
			}
			p.SetState(292)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(288)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(289)
					p.ExplainOption()
				}

				p.SetState(294)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(295)
				p.Match(SQLBaseParserT__2)
			}

		}
		{
			p.SetState(299)
			p.Statement()
		}

	case 16:
		localctx = NewShowCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(300)
			p.Match(SQLBaseParserSHOW)
		}
		{
			p.SetState(301)
			p.Match(SQLBaseParserCREATE)
		}
		{
			p.SetState(302)
			p.Match(SQLBaseParserTABLE)
		}
		{
			p.SetState(303)
			p.QualifiedName()
		}

	case 17:
		localctx = NewShowCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(304)
			p.Match(SQLBaseParserSHOW)
		}
		{
			p.SetState(305)
			p.Match(SQLBaseParserCREATE)
		}
		{
			p.SetState(306)
			p.Match(SQLBaseParserVIEW)
		}
		{
			p.SetState(307)
			p.QualifiedName()
		}

	case 18:
		localctx = NewShowTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(308)
			p.Match(SQLBaseParserSHOW)
		}
		{
			p.SetState(309)
			p.Match(SQLBaseParserTABLES)
		}
		p.SetState(312)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserFROM || _la == SQLBaseParserIN {
			p.SetState(310)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLBaseParserFROM || _la == SQLBaseParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			{
				p.SetState(311)
				p.QualifiedName()
			}

		}
		p.SetState(316)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserLIKE {
			{
				p.SetState(314)
				p.Match(SQLBaseParserLIKE)
			}
			{
				p.SetState(315)

				var _m = p.Match(SQLBaseParserSTRING)

				localctx.(*ShowTablesContext).pattern = _m
			}

		}

	case 19:
		localctx = NewShowSchemasContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(318)
			p.Match(SQLBaseParserSHOW)
		}
		{
			p.SetState(319)
			p.Match(SQLBaseParserSCHEMAS)
		}
		p.SetState(322)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserFROM || _la == SQLBaseParserIN {
			p.SetState(320)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLBaseParserFROM || _la == SQLBaseParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			{
				p.SetState(321)
				p.Identifier()
			}

		}
		p.SetState(326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserLIKE {
			{
				p.SetState(324)
				p.Match(SQLBaseParserLIKE)
			}
			{
				p.SetState(325)

				var _m = p.Match(SQLBaseParserSTRING)

				localctx.(*ShowSchemasContext).pattern = _m
			}

		}

	case 20:
		localctx = NewShowCatalogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(328)
			p.Match(SQLBaseParserSHOW)
		}
		{
			p.SetState(329)
			p.Match(SQLBaseParserCATALOGS)
		}
		p.SetState(332)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserLIKE {
			{
				p.SetState(330)
				p.Match(SQLBaseParserLIKE)
			}
			{
				p.SetState(331)

				var _m = p.Match(SQLBaseParserSTRING)

				localctx.(*ShowCatalogsContext).pattern = _m
			}

		}

	case 21:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(334)
			p.Match(SQLBaseParserSHOW)
		}
		{
			p.SetState(335)
			p.Match(SQLBaseParserCOLUMNS)
		}
		p.SetState(336)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserFROM || _la == SQLBaseParserIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(337)
			p.QualifiedName()
		}

	case 22:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		p.SetState(338)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserDESC || _la == SQLBaseParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(339)
			p.QualifiedName()
		}

	case 23:
		localctx = NewShowFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(340)
			p.Match(SQLBaseParserSHOW)
		}
		{
			p.SetState(341)
			p.Match(SQLBaseParserFUNCTIONS)
		}

	case 24:
		localctx = NewShowSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(342)
			p.Match(SQLBaseParserSHOW)
		}
		{
			p.SetState(343)
			p.Match(SQLBaseParserSESSION)
		}

	case 25:
		localctx = NewSetSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(344)
			p.Match(SQLBaseParserSET)
		}
		{
			p.SetState(345)
			p.Match(SQLBaseParserSESSION)
		}
		{
			p.SetState(346)
			p.QualifiedName()
		}
		{
			p.SetState(347)
			p.Match(SQLBaseParserEQ)
		}
		{
			p.SetState(348)
			p.Expression()
		}

	case 26:
		localctx = NewResetSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(350)
			p.Match(SQLBaseParserRESET)
		}
		{
			p.SetState(351)
			p.Match(SQLBaseParserSESSION)
		}
		{
			p.SetState(352)
			p.QualifiedName()
		}

	case 27:
		localctx = NewStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(353)
			p.Match(SQLBaseParserSTART)
		}
		{
			p.SetState(354)
			p.Match(SQLBaseParserTRANSACTION)
		}
		p.SetState(363)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserISOLATION || _la == SQLBaseParserREAD {
			{
				p.SetState(355)
				p.TransactionMode()
			}
			p.SetState(360)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(356)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(357)
					p.TransactionMode()
				}

				p.SetState(362)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 28:
		localctx = NewCommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(365)
			p.Match(SQLBaseParserCOMMIT)
		}
		p.SetState(367)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserWORK {
			{
				p.SetState(366)
				p.Match(SQLBaseParserWORK)
			}

		}

	case 29:
		localctx = NewRollbackContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(369)
			p.Match(SQLBaseParserROLLBACK)
		}
		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserWORK {
			{
				p.SetState(370)
				p.Match(SQLBaseParserWORK)
			}

		}

	case 30:
		localctx = NewShowPartitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(373)
			p.Match(SQLBaseParserSHOW)
		}
		{
			p.SetState(374)
			p.Match(SQLBaseParserPARTITIONS)
		}
		p.SetState(375)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserFROM || _la == SQLBaseParserIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(376)
			p.QualifiedName()
		}
		p.SetState(379)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserWHERE {
			{
				p.SetState(377)
				p.Match(SQLBaseParserWHERE)
			}
			{
				p.SetState(378)
				p.booleanExpression(0)
			}

		}
		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserORDER {
			{
				p.SetState(381)
				p.Match(SQLBaseParserORDER)
			}
			{
				p.SetState(382)
				p.Match(SQLBaseParserBY)
			}
			{
				p.SetState(383)
				p.SortItem()
			}
			p.SetState(388)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(384)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(385)
					p.SortItem()
				}

				p.SetState(390)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(395)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserLIMIT {
			{
				p.SetState(393)
				p.Match(SQLBaseParserLIMIT)
			}
			{
				p.SetState(394)

				var _m = p.Match(SQLBaseParserINTEGER_VALUE)

				localctx.(*ShowPartitionsContext).limit = _m
			}

		}

	case 31:
		localctx = NewPrepareContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(397)
			p.Match(SQLBaseParserPREPARE)
		}
		{
			p.SetState(398)
			p.Identifier()
		}
		{
			p.SetState(399)
			p.Match(SQLBaseParserFROM)
		}
		{
			p.SetState(400)
			p.Statement()
		}

	case 32:
		localctx = NewDeallocateContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(402)
			p.Match(SQLBaseParserDEALLOCATE)
		}
		{
			p.SetState(403)
			p.Match(SQLBaseParserPREPARE)
		}
		{
			p.SetState(404)
			p.Identifier()
		}

	case 33:
		localctx = NewExecuteContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(405)
			p.Match(SQLBaseParserEXECUTE)
		}
		{
			p.SetState(406)
			p.Identifier()
		}
		p.SetState(416)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserUSING {
			{
				p.SetState(407)
				p.Match(SQLBaseParserUSING)
			}
			{
				p.SetState(408)
				p.Expression()
			}
			p.SetState(413)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(409)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(410)
					p.Expression()
				}

				p.SetState(415)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 34:
		localctx = NewDescribeInputContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(418)
			p.Match(SQLBaseParserDESCRIBE)
		}
		{
			p.SetState(419)
			p.Match(SQLBaseParserINPUT)
		}
		{
			p.SetState(420)
			p.Identifier()
		}

	case 35:
		localctx = NewDescribeOutputContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(421)
			p.Match(SQLBaseParserDESCRIBE)
		}
		{
			p.SetState(422)
			p.Match(SQLBaseParserOUTPUT)
		}
		{
			p.SetState(423)
			p.Identifier()
		}

	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) QueryNoWith() IQueryNoWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryNoWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *QueryContext) With() IWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *SQLBaseParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SQLBaseParserRULE_query)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(427)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserWITH {
		{
			p.SetState(426)
			p.With()
		}

	}
	{
		p.SetState(429)
		p.QueryNoWith()
	}

	return localctx
}

// IWithContext is an interface to support dynamic dispatch.
type IWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithContext differentiates from other interfaces.
	IsWithContext()
}

type WithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithContext() *WithContext {
	var p = new(WithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_with
	return p
}

func (*WithContext) IsWithContext() {}

func NewWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithContext {
	var p = new(WithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_with

	return p
}

func (s *WithContext) GetParser() antlr.Parser { return s.parser }

func (s *WithContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWITH, 0)
}

func (s *WithContext) AllNamedQuery() []INamedQueryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedQueryContext)(nil)).Elem())
	var tst = make([]INamedQueryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedQueryContext)
		}
	}

	return tst
}

func (s *WithContext) NamedQuery(i int) INamedQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedQueryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedQueryContext)
}

func (s *WithContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserRECURSIVE, 0)
}

func (s *WithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterWith(s)
	}
}

func (s *WithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitWith(s)
	}
}

func (p *SQLBaseParser) With() (localctx IWithContext) {
	localctx = NewWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SQLBaseParserRULE_with)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(431)
		p.Match(SQLBaseParserWITH)
	}
	p.SetState(433)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserRECURSIVE {
		{
			p.SetState(432)
			p.Match(SQLBaseParserRECURSIVE)
		}

	}
	{
		p.SetState(435)
		p.NamedQuery()
	}
	p.SetState(440)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLBaseParserT__1 {
		{
			p.SetState(436)
			p.Match(SQLBaseParserT__1)
		}
		{
			p.SetState(437)
			p.NamedQuery()
		}

		p.SetState(442)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_tableElement
	return p
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *TableElementContext) LikeClause() ILikeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILikeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILikeClauseContext)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (p *SQLBaseParser) TableElement() (localctx ITableElementContext) {
	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SQLBaseParserRULE_tableElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(445)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLBaseParserADD, SQLBaseParserALL, SQLBaseParserSOME, SQLBaseParserANY, SQLBaseParserAT, SQLBaseParserNO, SQLBaseParserSUBSTRING, SQLBaseParserPOSITION, SQLBaseParserTINYINT, SQLBaseParserSMALLINT, SQLBaseParserINTEGER, SQLBaseParserDATE, SQLBaseParserTIME, SQLBaseParserTIMESTAMP, SQLBaseParserINTERVAL, SQLBaseParserYEAR, SQLBaseParserMONTH, SQLBaseParserDAY, SQLBaseParserHOUR, SQLBaseParserMINUTE, SQLBaseParserSECOND, SQLBaseParserZONE, SQLBaseParserFILTER, SQLBaseParserOVER, SQLBaseParserPARTITION, SQLBaseParserRANGE, SQLBaseParserROWS, SQLBaseParserPRECEDING, SQLBaseParserFOLLOWING, SQLBaseParserCURRENT, SQLBaseParserROW, SQLBaseParserSCHEMA, SQLBaseParserCOMMENT, SQLBaseParserVIEW, SQLBaseParserREPLACE, SQLBaseParserGRANT, SQLBaseParserREVOKE, SQLBaseParserPRIVILEGES, SQLBaseParserPUBLIC, SQLBaseParserOPTION, SQLBaseParserEXPLAIN, SQLBaseParserANALYZE, SQLBaseParserFORMAT, SQLBaseParserTYPE, SQLBaseParserTEXT, SQLBaseParserGRAPHVIZ, SQLBaseParserLOGICAL, SQLBaseParserDISTRIBUTED, SQLBaseParserVALIDATE, SQLBaseParserSHOW, SQLBaseParserTABLES, SQLBaseParserSCHEMAS, SQLBaseParserCATALOGS, SQLBaseParserCOLUMNS, SQLBaseParserCOLUMN, SQLBaseParserUSE, SQLBaseParserPARTITIONS, SQLBaseParserFUNCTIONS, SQLBaseParserTO, SQLBaseParserSYSTEM, SQLBaseParserBERNOULLI, SQLBaseParserPOISSONIZED, SQLBaseParserTABLESAMPLE, SQLBaseParserARRAY, SQLBaseParserMAP, SQLBaseParserSET, SQLBaseParserRESET, SQLBaseParserSESSION, SQLBaseParserDATA, SQLBaseParserSTART, SQLBaseParserTRANSACTION, SQLBaseParserCOMMIT, SQLBaseParserROLLBACK, SQLBaseParserWORK, SQLBaseParserISOLATION, SQLBaseParserLEVEL, SQLBaseParserSERIALIZABLE, SQLBaseParserREPEATABLE, SQLBaseParserCOMMITTED, SQLBaseParserUNCOMMITTED, SQLBaseParserREAD, SQLBaseParserWRITE, SQLBaseParserONLY, SQLBaseParserCALL, SQLBaseParserINPUT, SQLBaseParserOUTPUT, SQLBaseParserCASCADE, SQLBaseParserRESTRICT, SQLBaseParserINCLUDING, SQLBaseParserEXCLUDING, SQLBaseParserPROPERTIES, SQLBaseParserNFD, SQLBaseParserNFC, SQLBaseParserNFKD, SQLBaseParserNFKC, SQLBaseParserIF, SQLBaseParserNULLIF, SQLBaseParserCOALESCE, SQLBaseParserIDENTIFIER, SQLBaseParserDIGIT_IDENTIFIER, SQLBaseParserQUOTED_IDENTIFIER, SQLBaseParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(443)
			p.ColumnDefinition()
		}

	case SQLBaseParserLIKE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(444)
			p.LikeClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_columnDefinition
	return p
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDefinitionContext) Type_t() IType_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_tContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_tContext)
}

func (s *ColumnDefinitionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCOMMENT, 0)
}

func (s *ColumnDefinitionContext) STRING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSTRING, 0)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (p *SQLBaseParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SQLBaseParserRULE_columnDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Identifier()
	}
	{
		p.SetState(448)
		p.type_t(0)
	}
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserCOMMENT {
		{
			p.SetState(449)
			p.Match(SQLBaseParserCOMMENT)
		}
		{
			p.SetState(450)
			p.Match(SQLBaseParserSTRING)
		}

	}

	return localctx
}

// ILikeClauseContext is an interface to support dynamic dispatch.
type ILikeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOptionType returns the optionType token.
	GetOptionType() antlr.Token

	// SetOptionType sets the optionType token.
	SetOptionType(antlr.Token)

	// IsLikeClauseContext differentiates from other interfaces.
	IsLikeClauseContext()
}

type LikeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	optionType antlr.Token
}

func NewEmptyLikeClauseContext() *LikeClauseContext {
	var p = new(LikeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_likeClause
	return p
}

func (*LikeClauseContext) IsLikeClauseContext() {}

func NewLikeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeClauseContext {
	var p = new(LikeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_likeClause

	return p
}

func (s *LikeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeClauseContext) GetOptionType() antlr.Token { return s.optionType }

func (s *LikeClauseContext) SetOptionType(v antlr.Token) { s.optionType = v }

func (s *LikeClauseContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLIKE, 0)
}

func (s *LikeClauseContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *LikeClauseContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPROPERTIES, 0)
}

func (s *LikeClauseContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINCLUDING, 0)
}

func (s *LikeClauseContext) EXCLUDING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEXCLUDING, 0)
}

func (s *LikeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterLikeClause(s)
	}
}

func (s *LikeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitLikeClause(s)
	}
}

func (p *SQLBaseParser) LikeClause() (localctx ILikeClauseContext) {
	localctx = NewLikeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SQLBaseParserRULE_likeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.Match(SQLBaseParserLIKE)
	}
	{
		p.SetState(454)
		p.QualifiedName()
	}
	p.SetState(457)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserINCLUDING || _la == SQLBaseParserEXCLUDING {
		p.SetState(455)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*LikeClauseContext).optionType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserINCLUDING || _la == SQLBaseParserEXCLUDING) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*LikeClauseContext).optionType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(456)
			p.Match(SQLBaseParserPROPERTIES)
		}

	}

	return localctx
}

// ITablePropertiesContext is an interface to support dynamic dispatch.
type ITablePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTablePropertiesContext differentiates from other interfaces.
	IsTablePropertiesContext()
}

type TablePropertiesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertiesContext() *TablePropertiesContext {
	var p = new(TablePropertiesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_tableProperties
	return p
}

func (*TablePropertiesContext) IsTablePropertiesContext() {}

func NewTablePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertiesContext {
	var p = new(TablePropertiesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_tableProperties

	return p
}

func (s *TablePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertiesContext) AllTableProperty() []ITablePropertyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITablePropertyContext)(nil)).Elem())
	var tst = make([]ITablePropertyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITablePropertyContext)
		}
	}

	return tst
}

func (s *TablePropertiesContext) TableProperty(i int) ITablePropertyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITablePropertyContext)
}

func (s *TablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterTableProperties(s)
	}
}

func (s *TablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitTableProperties(s)
	}
}

func (p *SQLBaseParser) TableProperties() (localctx ITablePropertiesContext) {
	localctx = NewTablePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SQLBaseParserRULE_tableProperties)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(459)
		p.Match(SQLBaseParserT__0)
	}
	{
		p.SetState(460)
		p.TableProperty()
	}
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLBaseParserT__1 {
		{
			p.SetState(461)
			p.Match(SQLBaseParserT__1)
		}
		{
			p.SetState(462)
			p.TableProperty()
		}

		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(468)
		p.Match(SQLBaseParserT__2)
	}

	return localctx
}

// ITablePropertyContext is an interface to support dynamic dispatch.
type ITablePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTablePropertyContext differentiates from other interfaces.
	IsTablePropertyContext()
}

type TablePropertyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertyContext() *TablePropertyContext {
	var p = new(TablePropertyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_tableProperty
	return p
}

func (*TablePropertyContext) IsTablePropertyContext() {}

func NewTablePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertyContext {
	var p = new(TablePropertyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_tableProperty

	return p
}

func (s *TablePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertyContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablePropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEQ, 0)
}

func (s *TablePropertyContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TablePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterTableProperty(s)
	}
}

func (s *TablePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitTableProperty(s)
	}
}

func (p *SQLBaseParser) TableProperty() (localctx ITablePropertyContext) {
	localctx = NewTablePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SQLBaseParserRULE_tableProperty)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(470)
		p.Identifier()
	}
	{
		p.SetState(471)
		p.Match(SQLBaseParserEQ)
	}
	{
		p.SetState(472)
		p.Expression()
	}

	return localctx
}

// IQueryNoWithContext is an interface to support dynamic dispatch.
type IQueryNoWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// IsQueryNoWithContext differentiates from other interfaces.
	IsQueryNoWithContext()
}

type QueryNoWithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
}

func NewEmptyQueryNoWithContext() *QueryNoWithContext {
	var p = new(QueryNoWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_queryNoWith
	return p
}

func (*QueryNoWithContext) IsQueryNoWithContext() {}

func NewQueryNoWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryNoWithContext {
	var p = new(QueryNoWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_queryNoWith

	return p
}

func (s *QueryNoWithContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryNoWithContext) GetLimit() antlr.Token { return s.limit }

func (s *QueryNoWithContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *QueryNoWithContext) QueryTerm() IQueryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryNoWithContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserORDER, 0)
}

func (s *QueryNoWithContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserBY, 0)
}

func (s *QueryNoWithContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *QueryNoWithContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryNoWithContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLIMIT, 0)
}

func (s *QueryNoWithContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINTEGER_VALUE, 0)
}

func (s *QueryNoWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryNoWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryNoWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitQueryNoWith(s)
	}
}

func (p *SQLBaseParser) QueryNoWith() (localctx IQueryNoWithContext) {
	localctx = NewQueryNoWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SQLBaseParserRULE_queryNoWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(474)
		p.queryTerm(0)
	}
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserORDER {
		{
			p.SetState(475)
			p.Match(SQLBaseParserORDER)
		}
		{
			p.SetState(476)
			p.Match(SQLBaseParserBY)
		}
		{
			p.SetState(477)
			p.SortItem()
		}
		p.SetState(482)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLBaseParserT__1 {
			{
				p.SetState(478)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(479)
				p.SortItem()
			}

			p.SetState(484)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserLIMIT {
		{
			p.SetState(487)
			p.Match(SQLBaseParserLIMIT)
		}
		{
			p.SetState(488)

			var _m = p.Match(SQLBaseParserINTEGER_VALUE)

			localctx.(*QueryNoWithContext).limit = _m
		}

	}

	return localctx
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_queryTerm
	return p
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyFrom(ctx *QueryTermContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryTermDefaultContext struct {
	*QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	p.QueryTermContext = NewEmptyQueryTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitQueryTermDefault(s)
	}
}

type SetOperationContext struct {
	*QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	p.QueryTermContext = NewEmptyQueryTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryTermContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryTerm() []IQueryTermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQueryTermContext)(nil)).Elem())
	var tst = make([]IQueryTermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQueryTermContext)
		}
	}

	return tst
}

func (s *SetOperationContext) QueryTerm(i int) IQueryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryTermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINTERSECT, 0)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEXCEPT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (p *SQLBaseParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *SQLBaseParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 20
	p.EnterRecursionRule(localctx, 20, SQLBaseParserRULE_queryTerm, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(492)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(502)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
			localctx.(*SetOperationContext).left = _prevctx

			p.PushNewRecursionContext(localctx, _startState, SQLBaseParserRULE_queryTerm)
			p.SetState(494)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			p.SetState(495)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SetOperationContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(SQLBaseParserUNION-135))|(1<<(SQLBaseParserEXCEPT-135))|(1<<(SQLBaseParserINTERSECT-135)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SetOperationContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			p.SetState(497)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQLBaseParserALL || _la == SQLBaseParserDISTINCT {
				{
					p.SetState(496)
					p.SetQuantifier()
				}

			}
			{
				p.SetState(499)

				var _x = p.queryTerm(2)

				localctx.(*SetOperationContext).right = _x
			}

		}
		p.SetState(504)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())
	}

	return localctx
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_queryPrimary
	return p
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyFrom(ctx *QueryPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	*QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) QueryNoWith() IQueryNoWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryNoWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSubquery(s)
	}
}

type QueryPrimaryDefaultContext struct {
	*QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

type TableContext struct {
	*QueryPrimaryContext
}

func NewTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableContext {
	var p = new(TableContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLE, 0)
}

func (s *TableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitTable(s)
	}
}

type InlineTableContext struct {
	*QueryPrimaryContext
}

func NewInlineTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableContext {
	var p = new(InlineTableContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserVALUES, 0)
}

func (s *InlineTableContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *InlineTableContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (p *SQLBaseParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SQLBaseParserRULE_queryPrimary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(521)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLBaseParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(505)
			p.QuerySpecification()
		}

	case SQLBaseParserTABLE:
		localctx = NewTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(506)
			p.Match(SQLBaseParserTABLE)
		}
		{
			p.SetState(507)
			p.QualifiedName()
		}

	case SQLBaseParserVALUES:
		localctx = NewInlineTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(508)
			p.Match(SQLBaseParserVALUES)
		}
		{
			p.SetState(509)
			p.Expression()
		}
		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(510)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(511)
					p.Expression()
				}

			}
			p.SetState(516)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
		}

	case SQLBaseParserT__0:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(517)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(518)
			p.QueryNoWith()
		}
		{
			p.SetState(519)
			p.Match(SQLBaseParserT__2)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrdering returns the nullOrdering token.
	GetNullOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrdering sets the nullOrdering token.
	SetNullOrdering(antlr.Token)

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	ordering     antlr.Token
	nullOrdering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_sortItem
	return p
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetNullOrdering() antlr.Token { return s.nullOrdering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetNullOrdering(v antlr.Token) { s.nullOrdering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNULLS, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDESC, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLAST, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (p *SQLBaseParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SQLBaseParserRULE_sortItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(523)
		p.Expression()
	}
	p.SetState(525)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserASC || _la == SQLBaseParserDESC {
		p.SetState(524)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SortItemContext).ordering = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserASC || _la == SQLBaseParserDESC) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SortItemContext).ordering = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserNULLS {
		{
			p.SetState(527)
			p.Match(SQLBaseParserNULLS)
		}
		p.SetState(528)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SortItemContext).nullOrdering = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserFIRST || _la == SQLBaseParserLAST) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SortItemContext).nullOrdering = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IBooleanExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IBooleanExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IBooleanExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IBooleanExpressionContext)

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IBooleanExpressionContext
	having IBooleanExpressionContext
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_querySpecification
	return p
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *QuerySpecificationContext) GetHaving() IBooleanExpressionContext { return s.having }

func (s *QuerySpecificationContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *QuerySpecificationContext) SetHaving(v IBooleanExpressionContext) { s.having = v }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSELECT, 0)
}

func (s *QuerySpecificationContext) AllSelectItem() []ISelectItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectItemContext)(nil)).Elem())
	var tst = make([]ISelectItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectItemContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectItem(i int) ISelectItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QuerySpecificationContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *QuerySpecificationContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFROM, 0)
}

func (s *QuerySpecificationContext) AllRelation() []IRelationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationContext)(nil)).Elem())
	var tst = make([]IRelationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) Relation(i int) IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *QuerySpecificationContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWHERE, 0)
}

func (s *QuerySpecificationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserGROUP, 0)
}

func (s *QuerySpecificationContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserBY, 0)
}

func (s *QuerySpecificationContext) GroupBy() IGroupByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupByContext)
}

func (s *QuerySpecificationContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserHAVING, 0)
}

func (s *QuerySpecificationContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (p *SQLBaseParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SQLBaseParserRULE_querySpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(531)
		p.Match(SQLBaseParserSELECT)
	}
	p.SetState(533)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(532)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(535)
		p.SelectItem()
	}
	p.SetState(540)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(536)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(537)
				p.SelectItem()
			}

		}
		p.SetState(542)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())
	}
	p.SetState(552)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(543)
			p.Match(SQLBaseParserFROM)
		}
		{
			p.SetState(544)
			p.relation(0)
		}
		p.SetState(549)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(545)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(546)
					p.relation(0)
				}

			}
			p.SetState(551)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext())
		}

	}
	p.SetState(556)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(554)
			p.Match(SQLBaseParserWHERE)
		}
		{
			p.SetState(555)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).where = _x
		}

	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(558)
			p.Match(SQLBaseParserGROUP)
		}
		{
			p.SetState(559)
			p.Match(SQLBaseParserBY)
		}
		{
			p.SetState(560)
			p.GroupBy()
		}

	}
	p.SetState(565)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(563)
			p.Match(SQLBaseParserHAVING)
		}
		{
			p.SetState(564)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).having = _x
		}

	}

	return localctx
}

// IGroupByContext is an interface to support dynamic dispatch.
type IGroupByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupByContext differentiates from other interfaces.
	IsGroupByContext()
}

type GroupByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByContext() *GroupByContext {
	var p = new(GroupByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_groupBy
	return p
}

func (*GroupByContext) IsGroupByContext() {}

func NewGroupByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByContext {
	var p = new(GroupByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_groupBy

	return p
}

func (s *GroupByContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByContext) AllGroupingElement() []IGroupingElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupingElementContext)(nil)).Elem())
	var tst = make([]IGroupingElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroupingElementContext)
		}
	}

	return tst
}

func (s *GroupByContext) GroupingElement(i int) IGroupingElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *GroupByContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *GroupByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterGroupBy(s)
	}
}

func (s *GroupByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitGroupBy(s)
	}
}

func (p *SQLBaseParser) GroupBy() (localctx IGroupByContext) {
	localctx = NewGroupByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SQLBaseParserRULE_groupBy)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(568)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(567)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(570)
		p.GroupingElement()
	}
	p.SetState(575)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(571)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(572)
				p.GroupingElement()
			}

		}
		p.SetState(577)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())
	}

	return localctx
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_groupingElement
	return p
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) CopyFrom(ctx *GroupingElementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MultipleGroupingSetsContext struct {
	*GroupingElementContext
}

func NewMultipleGroupingSetsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleGroupingSetsContext {
	var p = new(MultipleGroupingSetsContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *MultipleGroupingSetsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleGroupingSetsContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserGROUPING, 0)
}

func (s *MultipleGroupingSetsContext) SETS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSETS, 0)
}

func (s *MultipleGroupingSetsContext) AllGroupingSet() []IGroupingSetContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupingSetContext)(nil)).Elem())
	var tst = make([]IGroupingSetContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroupingSetContext)
		}
	}

	return tst
}

func (s *MultipleGroupingSetsContext) GroupingSet(i int) IGroupingSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingSetContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *MultipleGroupingSetsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitMultipleGroupingSets(s)
	}
}

type SingleGroupingSetContext struct {
	*GroupingElementContext
}

func NewSingleGroupingSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleGroupingSetContext {
	var p = new(SingleGroupingSetContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *SingleGroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleGroupingSetContext) GroupingExpressions() IGroupingExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupingExpressionsContext)
}

func (s *SingleGroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSingleGroupingSet(s)
	}
}

type CubeContext struct {
	*GroupingElementContext
}

func NewCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CubeContext {
	var p = new(CubeContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *CubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCUBE, 0)
}

func (s *CubeContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *CubeContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterCube(s)
	}
}

func (s *CubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitCube(s)
	}
}

type RollupContext struct {
	*GroupingElementContext
}

func NewRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollupContext {
	var p = new(RollupContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *RollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserROLLUP, 0)
}

func (s *RollupContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *RollupContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterRollup(s)
	}
}

func (s *RollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitRollup(s)
	}
}

func (p *SQLBaseParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SQLBaseParserRULE_groupingElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(618)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLBaseParserT__0, SQLBaseParserT__3, SQLBaseParserADD, SQLBaseParserALL, SQLBaseParserSOME, SQLBaseParserANY, SQLBaseParserAT, SQLBaseParserNOT, SQLBaseParserNO, SQLBaseParserEXISTS, SQLBaseParserNULL, SQLBaseParserTRUE, SQLBaseParserFALSE, SQLBaseParserSUBSTRING, SQLBaseParserPOSITION, SQLBaseParserTINYINT, SQLBaseParserSMALLINT, SQLBaseParserINTEGER, SQLBaseParserDATE, SQLBaseParserTIME, SQLBaseParserTIMESTAMP, SQLBaseParserINTERVAL, SQLBaseParserYEAR, SQLBaseParserMONTH, SQLBaseParserDAY, SQLBaseParserHOUR, SQLBaseParserMINUTE, SQLBaseParserSECOND, SQLBaseParserZONE, SQLBaseParserCURRENT_DATE, SQLBaseParserCURRENT_TIME, SQLBaseParserCURRENT_TIMESTAMP, SQLBaseParserLOCALTIME, SQLBaseParserLOCALTIMESTAMP, SQLBaseParserEXTRACT, SQLBaseParserCASE, SQLBaseParserFILTER, SQLBaseParserOVER, SQLBaseParserPARTITION, SQLBaseParserRANGE, SQLBaseParserROWS, SQLBaseParserPRECEDING, SQLBaseParserFOLLOWING, SQLBaseParserCURRENT, SQLBaseParserROW, SQLBaseParserSCHEMA, SQLBaseParserCOMMENT, SQLBaseParserVIEW, SQLBaseParserREPLACE, SQLBaseParserGRANT, SQLBaseParserREVOKE, SQLBaseParserPRIVILEGES, SQLBaseParserPUBLIC, SQLBaseParserOPTION, SQLBaseParserEXPLAIN, SQLBaseParserANALYZE, SQLBaseParserFORMAT, SQLBaseParserTYPE, SQLBaseParserTEXT, SQLBaseParserGRAPHVIZ, SQLBaseParserLOGICAL, SQLBaseParserDISTRIBUTED, SQLBaseParserVALIDATE, SQLBaseParserCAST, SQLBaseParserTRY_CAST, SQLBaseParserSHOW, SQLBaseParserTABLES, SQLBaseParserSCHEMAS, SQLBaseParserCATALOGS, SQLBaseParserCOLUMNS, SQLBaseParserCOLUMN, SQLBaseParserUSE, SQLBaseParserPARTITIONS, SQLBaseParserFUNCTIONS, SQLBaseParserTO, SQLBaseParserSYSTEM, SQLBaseParserBERNOULLI, SQLBaseParserPOISSONIZED, SQLBaseParserTABLESAMPLE, SQLBaseParserARRAY, SQLBaseParserMAP, SQLBaseParserSET, SQLBaseParserRESET, SQLBaseParserSESSION, SQLBaseParserDATA, SQLBaseParserSTART, SQLBaseParserTRANSACTION, SQLBaseParserCOMMIT, SQLBaseParserROLLBACK, SQLBaseParserWORK, SQLBaseParserISOLATION, SQLBaseParserLEVEL, SQLBaseParserSERIALIZABLE, SQLBaseParserREPEATABLE, SQLBaseParserCOMMITTED, SQLBaseParserUNCOMMITTED, SQLBaseParserREAD, SQLBaseParserWRITE, SQLBaseParserONLY, SQLBaseParserCALL, SQLBaseParserINPUT, SQLBaseParserOUTPUT, SQLBaseParserCASCADE, SQLBaseParserRESTRICT, SQLBaseParserINCLUDING, SQLBaseParserEXCLUDING, SQLBaseParserPROPERTIES, SQLBaseParserNORMALIZE, SQLBaseParserNFD, SQLBaseParserNFC, SQLBaseParserNFKD, SQLBaseParserNFKC, SQLBaseParserIF, SQLBaseParserNULLIF, SQLBaseParserCOALESCE, SQLBaseParserTIME_WITH_TIME_ZONE, SQLBaseParserTIMESTAMP_WITH_TIME_ZONE, SQLBaseParserDOUBLE_PRECISION, SQLBaseParserPLUS, SQLBaseParserMINUS, SQLBaseParserSTRING, SQLBaseParserBINARY_LITERAL, SQLBaseParserINTEGER_VALUE, SQLBaseParserDECIMAL_VALUE, SQLBaseParserIDENTIFIER, SQLBaseParserDIGIT_IDENTIFIER, SQLBaseParserQUOTED_IDENTIFIER, SQLBaseParserBACKQUOTED_IDENTIFIER:
		localctx = NewSingleGroupingSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(578)
			p.GroupingExpressions()
		}

	case SQLBaseParserROLLUP:
		localctx = NewRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(579)
			p.Match(SQLBaseParserROLLUP)
		}
		{
			p.SetState(580)
			p.Match(SQLBaseParserT__0)
		}
		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQLBaseParserADD)|(1<<SQLBaseParserALL)|(1<<SQLBaseParserSOME)|(1<<SQLBaseParserANY)|(1<<SQLBaseParserAT))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(SQLBaseParserNO-33))|(1<<(SQLBaseParserSUBSTRING-33))|(1<<(SQLBaseParserPOSITION-33))|(1<<(SQLBaseParserTINYINT-33))|(1<<(SQLBaseParserSMALLINT-33))|(1<<(SQLBaseParserINTEGER-33))|(1<<(SQLBaseParserDATE-33))|(1<<(SQLBaseParserTIME-33))|(1<<(SQLBaseParserTIMESTAMP-33))|(1<<(SQLBaseParserINTERVAL-33))|(1<<(SQLBaseParserYEAR-33))|(1<<(SQLBaseParserMONTH-33))|(1<<(SQLBaseParserDAY-33))|(1<<(SQLBaseParserHOUR-33))|(1<<(SQLBaseParserMINUTE-33))|(1<<(SQLBaseParserSECOND-33))|(1<<(SQLBaseParserZONE-33)))) != 0) || (((_la-85)&-(0x1f+1)) == 0 && ((1<<uint((_la-85)))&((1<<(SQLBaseParserFILTER-85))|(1<<(SQLBaseParserOVER-85))|(1<<(SQLBaseParserPARTITION-85))|(1<<(SQLBaseParserRANGE-85))|(1<<(SQLBaseParserROWS-85))|(1<<(SQLBaseParserPRECEDING-85))|(1<<(SQLBaseParserFOLLOWING-85))|(1<<(SQLBaseParserCURRENT-85))|(1<<(SQLBaseParserROW-85))|(1<<(SQLBaseParserSCHEMA-85))|(1<<(SQLBaseParserCOMMENT-85))|(1<<(SQLBaseParserVIEW-85))|(1<<(SQLBaseParserREPLACE-85))|(1<<(SQLBaseParserGRANT-85))|(1<<(SQLBaseParserREVOKE-85))|(1<<(SQLBaseParserPRIVILEGES-85))|(1<<(SQLBaseParserPUBLIC-85))|(1<<(SQLBaseParserOPTION-85))|(1<<(SQLBaseParserEXPLAIN-85))|(1<<(SQLBaseParserANALYZE-85))|(1<<(SQLBaseParserFORMAT-85)))) != 0) || (((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(SQLBaseParserTYPE-117))|(1<<(SQLBaseParserTEXT-117))|(1<<(SQLBaseParserGRAPHVIZ-117))|(1<<(SQLBaseParserLOGICAL-117))|(1<<(SQLBaseParserDISTRIBUTED-117))|(1<<(SQLBaseParserVALIDATE-117))|(1<<(SQLBaseParserSHOW-117))|(1<<(SQLBaseParserTABLES-117))|(1<<(SQLBaseParserSCHEMAS-117))|(1<<(SQLBaseParserCATALOGS-117))|(1<<(SQLBaseParserCOLUMNS-117))|(1<<(SQLBaseParserCOLUMN-117))|(1<<(SQLBaseParserUSE-117))|(1<<(SQLBaseParserPARTITIONS-117))|(1<<(SQLBaseParserFUNCTIONS-117))|(1<<(SQLBaseParserTO-117))|(1<<(SQLBaseParserSYSTEM-117))|(1<<(SQLBaseParserBERNOULLI-117))|(1<<(SQLBaseParserPOISSONIZED-117))|(1<<(SQLBaseParserTABLESAMPLE-117))|(1<<(SQLBaseParserARRAY-117))|(1<<(SQLBaseParserMAP-117)))) != 0) || (((_la-149)&-(0x1f+1)) == 0 && ((1<<uint((_la-149)))&((1<<(SQLBaseParserSET-149))|(1<<(SQLBaseParserRESET-149))|(1<<(SQLBaseParserSESSION-149))|(1<<(SQLBaseParserDATA-149))|(1<<(SQLBaseParserSTART-149))|(1<<(SQLBaseParserTRANSACTION-149))|(1<<(SQLBaseParserCOMMIT-149))|(1<<(SQLBaseParserROLLBACK-149))|(1<<(SQLBaseParserWORK-149))|(1<<(SQLBaseParserISOLATION-149))|(1<<(SQLBaseParserLEVEL-149))|(1<<(SQLBaseParserSERIALIZABLE-149))|(1<<(SQLBaseParserREPEATABLE-149))|(1<<(SQLBaseParserCOMMITTED-149))|(1<<(SQLBaseParserUNCOMMITTED-149))|(1<<(SQLBaseParserREAD-149))|(1<<(SQLBaseParserWRITE-149))|(1<<(SQLBaseParserONLY-149))|(1<<(SQLBaseParserCALL-149))|(1<<(SQLBaseParserINPUT-149))|(1<<(SQLBaseParserOUTPUT-149))|(1<<(SQLBaseParserCASCADE-149))|(1<<(SQLBaseParserRESTRICT-149))|(1<<(SQLBaseParserINCLUDING-149))|(1<<(SQLBaseParserEXCLUDING-149))|(1<<(SQLBaseParserPROPERTIES-149))|(1<<(SQLBaseParserNFD-149))|(1<<(SQLBaseParserNFC-149)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(SQLBaseParserNFKD-181))|(1<<(SQLBaseParserNFKC-181))|(1<<(SQLBaseParserIF-181))|(1<<(SQLBaseParserNULLIF-181))|(1<<(SQLBaseParserCOALESCE-181))|(1<<(SQLBaseParserIDENTIFIER-181))|(1<<(SQLBaseParserDIGIT_IDENTIFIER-181))|(1<<(SQLBaseParserQUOTED_IDENTIFIER-181))|(1<<(SQLBaseParserBACKQUOTED_IDENTIFIER-181)))) != 0) {
			{
				p.SetState(581)
				p.QualifiedName()
			}
			p.SetState(586)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(582)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(583)
					p.QualifiedName()
				}

				p.SetState(588)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(591)
			p.Match(SQLBaseParserT__2)
		}

	case SQLBaseParserCUBE:
		localctx = NewCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(592)
			p.Match(SQLBaseParserCUBE)
		}
		{
			p.SetState(593)
			p.Match(SQLBaseParserT__0)
		}
		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQLBaseParserADD)|(1<<SQLBaseParserALL)|(1<<SQLBaseParserSOME)|(1<<SQLBaseParserANY)|(1<<SQLBaseParserAT))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(SQLBaseParserNO-33))|(1<<(SQLBaseParserSUBSTRING-33))|(1<<(SQLBaseParserPOSITION-33))|(1<<(SQLBaseParserTINYINT-33))|(1<<(SQLBaseParserSMALLINT-33))|(1<<(SQLBaseParserINTEGER-33))|(1<<(SQLBaseParserDATE-33))|(1<<(SQLBaseParserTIME-33))|(1<<(SQLBaseParserTIMESTAMP-33))|(1<<(SQLBaseParserINTERVAL-33))|(1<<(SQLBaseParserYEAR-33))|(1<<(SQLBaseParserMONTH-33))|(1<<(SQLBaseParserDAY-33))|(1<<(SQLBaseParserHOUR-33))|(1<<(SQLBaseParserMINUTE-33))|(1<<(SQLBaseParserSECOND-33))|(1<<(SQLBaseParserZONE-33)))) != 0) || (((_la-85)&-(0x1f+1)) == 0 && ((1<<uint((_la-85)))&((1<<(SQLBaseParserFILTER-85))|(1<<(SQLBaseParserOVER-85))|(1<<(SQLBaseParserPARTITION-85))|(1<<(SQLBaseParserRANGE-85))|(1<<(SQLBaseParserROWS-85))|(1<<(SQLBaseParserPRECEDING-85))|(1<<(SQLBaseParserFOLLOWING-85))|(1<<(SQLBaseParserCURRENT-85))|(1<<(SQLBaseParserROW-85))|(1<<(SQLBaseParserSCHEMA-85))|(1<<(SQLBaseParserCOMMENT-85))|(1<<(SQLBaseParserVIEW-85))|(1<<(SQLBaseParserREPLACE-85))|(1<<(SQLBaseParserGRANT-85))|(1<<(SQLBaseParserREVOKE-85))|(1<<(SQLBaseParserPRIVILEGES-85))|(1<<(SQLBaseParserPUBLIC-85))|(1<<(SQLBaseParserOPTION-85))|(1<<(SQLBaseParserEXPLAIN-85))|(1<<(SQLBaseParserANALYZE-85))|(1<<(SQLBaseParserFORMAT-85)))) != 0) || (((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(SQLBaseParserTYPE-117))|(1<<(SQLBaseParserTEXT-117))|(1<<(SQLBaseParserGRAPHVIZ-117))|(1<<(SQLBaseParserLOGICAL-117))|(1<<(SQLBaseParserDISTRIBUTED-117))|(1<<(SQLBaseParserVALIDATE-117))|(1<<(SQLBaseParserSHOW-117))|(1<<(SQLBaseParserTABLES-117))|(1<<(SQLBaseParserSCHEMAS-117))|(1<<(SQLBaseParserCATALOGS-117))|(1<<(SQLBaseParserCOLUMNS-117))|(1<<(SQLBaseParserCOLUMN-117))|(1<<(SQLBaseParserUSE-117))|(1<<(SQLBaseParserPARTITIONS-117))|(1<<(SQLBaseParserFUNCTIONS-117))|(1<<(SQLBaseParserTO-117))|(1<<(SQLBaseParserSYSTEM-117))|(1<<(SQLBaseParserBERNOULLI-117))|(1<<(SQLBaseParserPOISSONIZED-117))|(1<<(SQLBaseParserTABLESAMPLE-117))|(1<<(SQLBaseParserARRAY-117))|(1<<(SQLBaseParserMAP-117)))) != 0) || (((_la-149)&-(0x1f+1)) == 0 && ((1<<uint((_la-149)))&((1<<(SQLBaseParserSET-149))|(1<<(SQLBaseParserRESET-149))|(1<<(SQLBaseParserSESSION-149))|(1<<(SQLBaseParserDATA-149))|(1<<(SQLBaseParserSTART-149))|(1<<(SQLBaseParserTRANSACTION-149))|(1<<(SQLBaseParserCOMMIT-149))|(1<<(SQLBaseParserROLLBACK-149))|(1<<(SQLBaseParserWORK-149))|(1<<(SQLBaseParserISOLATION-149))|(1<<(SQLBaseParserLEVEL-149))|(1<<(SQLBaseParserSERIALIZABLE-149))|(1<<(SQLBaseParserREPEATABLE-149))|(1<<(SQLBaseParserCOMMITTED-149))|(1<<(SQLBaseParserUNCOMMITTED-149))|(1<<(SQLBaseParserREAD-149))|(1<<(SQLBaseParserWRITE-149))|(1<<(SQLBaseParserONLY-149))|(1<<(SQLBaseParserCALL-149))|(1<<(SQLBaseParserINPUT-149))|(1<<(SQLBaseParserOUTPUT-149))|(1<<(SQLBaseParserCASCADE-149))|(1<<(SQLBaseParserRESTRICT-149))|(1<<(SQLBaseParserINCLUDING-149))|(1<<(SQLBaseParserEXCLUDING-149))|(1<<(SQLBaseParserPROPERTIES-149))|(1<<(SQLBaseParserNFD-149))|(1<<(SQLBaseParserNFC-149)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(SQLBaseParserNFKD-181))|(1<<(SQLBaseParserNFKC-181))|(1<<(SQLBaseParserIF-181))|(1<<(SQLBaseParserNULLIF-181))|(1<<(SQLBaseParserCOALESCE-181))|(1<<(SQLBaseParserIDENTIFIER-181))|(1<<(SQLBaseParserDIGIT_IDENTIFIER-181))|(1<<(SQLBaseParserQUOTED_IDENTIFIER-181))|(1<<(SQLBaseParserBACKQUOTED_IDENTIFIER-181)))) != 0) {
			{
				p.SetState(594)
				p.QualifiedName()
			}
			p.SetState(599)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(595)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(596)
					p.QualifiedName()
				}

				p.SetState(601)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(604)
			p.Match(SQLBaseParserT__2)
		}

	case SQLBaseParserGROUPING:
		localctx = NewMultipleGroupingSetsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(605)
			p.Match(SQLBaseParserGROUPING)
		}
		{
			p.SetState(606)
			p.Match(SQLBaseParserSETS)
		}
		{
			p.SetState(607)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(608)
			p.GroupingSet()
		}
		p.SetState(613)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLBaseParserT__1 {
			{
				p.SetState(609)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(610)
				p.GroupingSet()
			}

			p.SetState(615)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(616)
			p.Match(SQLBaseParserT__2)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGroupingExpressionsContext is an interface to support dynamic dispatch.
type IGroupingExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupingExpressionsContext differentiates from other interfaces.
	IsGroupingExpressionsContext()
}

type GroupingExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingExpressionsContext() *GroupingExpressionsContext {
	var p = new(GroupingExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_groupingExpressions
	return p
}

func (*GroupingExpressionsContext) IsGroupingExpressionsContext() {}

func NewGroupingExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingExpressionsContext {
	var p = new(GroupingExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_groupingExpressions

	return p
}

func (s *GroupingExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingExpressionsContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *GroupingExpressionsContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterGroupingExpressions(s)
	}
}

func (s *GroupingExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitGroupingExpressions(s)
	}
}

func (p *SQLBaseParser) GroupingExpressions() (localctx IGroupingExpressionsContext) {
	localctx = NewGroupingExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SQLBaseParserRULE_groupingExpressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(620)
			p.Match(SQLBaseParserT__0)
		}
		p.SetState(629)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQLBaseParserT__0)|(1<<SQLBaseParserT__3)|(1<<SQLBaseParserADD)|(1<<SQLBaseParserALL)|(1<<SQLBaseParserSOME)|(1<<SQLBaseParserANY)|(1<<SQLBaseParserAT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SQLBaseParserNOT-32))|(1<<(SQLBaseParserNO-32))|(1<<(SQLBaseParserEXISTS-32))|(1<<(SQLBaseParserNULL-32))|(1<<(SQLBaseParserTRUE-32))|(1<<(SQLBaseParserFALSE-32))|(1<<(SQLBaseParserSUBSTRING-32))|(1<<(SQLBaseParserPOSITION-32))|(1<<(SQLBaseParserTINYINT-32))|(1<<(SQLBaseParserSMALLINT-32))|(1<<(SQLBaseParserINTEGER-32))|(1<<(SQLBaseParserDATE-32))|(1<<(SQLBaseParserTIME-32))|(1<<(SQLBaseParserTIMESTAMP-32))|(1<<(SQLBaseParserINTERVAL-32))|(1<<(SQLBaseParserYEAR-32))|(1<<(SQLBaseParserMONTH-32))|(1<<(SQLBaseParserDAY-32))|(1<<(SQLBaseParserHOUR-32))|(1<<(SQLBaseParserMINUTE-32))|(1<<(SQLBaseParserSECOND-32))|(1<<(SQLBaseParserZONE-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SQLBaseParserCURRENT_DATE-64))|(1<<(SQLBaseParserCURRENT_TIME-64))|(1<<(SQLBaseParserCURRENT_TIMESTAMP-64))|(1<<(SQLBaseParserLOCALTIME-64))|(1<<(SQLBaseParserLOCALTIMESTAMP-64))|(1<<(SQLBaseParserEXTRACT-64))|(1<<(SQLBaseParserCASE-64))|(1<<(SQLBaseParserFILTER-64))|(1<<(SQLBaseParserOVER-64))|(1<<(SQLBaseParserPARTITION-64))|(1<<(SQLBaseParserRANGE-64))|(1<<(SQLBaseParserROWS-64))|(1<<(SQLBaseParserPRECEDING-64))|(1<<(SQLBaseParserFOLLOWING-64))|(1<<(SQLBaseParserCURRENT-64))|(1<<(SQLBaseParserROW-64)))) != 0) || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(SQLBaseParserSCHEMA-99))|(1<<(SQLBaseParserCOMMENT-99))|(1<<(SQLBaseParserVIEW-99))|(1<<(SQLBaseParserREPLACE-99))|(1<<(SQLBaseParserGRANT-99))|(1<<(SQLBaseParserREVOKE-99))|(1<<(SQLBaseParserPRIVILEGES-99))|(1<<(SQLBaseParserPUBLIC-99))|(1<<(SQLBaseParserOPTION-99))|(1<<(SQLBaseParserEXPLAIN-99))|(1<<(SQLBaseParserANALYZE-99))|(1<<(SQLBaseParserFORMAT-99))|(1<<(SQLBaseParserTYPE-99))|(1<<(SQLBaseParserTEXT-99))|(1<<(SQLBaseParserGRAPHVIZ-99))|(1<<(SQLBaseParserLOGICAL-99))|(1<<(SQLBaseParserDISTRIBUTED-99))|(1<<(SQLBaseParserVALIDATE-99))|(1<<(SQLBaseParserCAST-99))|(1<<(SQLBaseParserTRY_CAST-99))|(1<<(SQLBaseParserSHOW-99))|(1<<(SQLBaseParserTABLES-99))|(1<<(SQLBaseParserSCHEMAS-99))|(1<<(SQLBaseParserCATALOGS-99))|(1<<(SQLBaseParserCOLUMNS-99))|(1<<(SQLBaseParserCOLUMN-99)))) != 0) || (((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(SQLBaseParserUSE-131))|(1<<(SQLBaseParserPARTITIONS-131))|(1<<(SQLBaseParserFUNCTIONS-131))|(1<<(SQLBaseParserTO-131))|(1<<(SQLBaseParserSYSTEM-131))|(1<<(SQLBaseParserBERNOULLI-131))|(1<<(SQLBaseParserPOISSONIZED-131))|(1<<(SQLBaseParserTABLESAMPLE-131))|(1<<(SQLBaseParserARRAY-131))|(1<<(SQLBaseParserMAP-131))|(1<<(SQLBaseParserSET-131))|(1<<(SQLBaseParserRESET-131))|(1<<(SQLBaseParserSESSION-131))|(1<<(SQLBaseParserDATA-131))|(1<<(SQLBaseParserSTART-131))|(1<<(SQLBaseParserTRANSACTION-131))|(1<<(SQLBaseParserCOMMIT-131))|(1<<(SQLBaseParserROLLBACK-131))|(1<<(SQLBaseParserWORK-131))|(1<<(SQLBaseParserISOLATION-131))|(1<<(SQLBaseParserLEVEL-131))|(1<<(SQLBaseParserSERIALIZABLE-131))|(1<<(SQLBaseParserREPEATABLE-131))|(1<<(SQLBaseParserCOMMITTED-131)))) != 0) || (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQLBaseParserUNCOMMITTED-163))|(1<<(SQLBaseParserREAD-163))|(1<<(SQLBaseParserWRITE-163))|(1<<(SQLBaseParserONLY-163))|(1<<(SQLBaseParserCALL-163))|(1<<(SQLBaseParserINPUT-163))|(1<<(SQLBaseParserOUTPUT-163))|(1<<(SQLBaseParserCASCADE-163))|(1<<(SQLBaseParserRESTRICT-163))|(1<<(SQLBaseParserINCLUDING-163))|(1<<(SQLBaseParserEXCLUDING-163))|(1<<(SQLBaseParserPROPERTIES-163))|(1<<(SQLBaseParserNORMALIZE-163))|(1<<(SQLBaseParserNFD-163))|(1<<(SQLBaseParserNFC-163))|(1<<(SQLBaseParserNFKD-163))|(1<<(SQLBaseParserNFKC-163))|(1<<(SQLBaseParserIF-163))|(1<<(SQLBaseParserNULLIF-163))|(1<<(SQLBaseParserCOALESCE-163))|(1<<(SQLBaseParserTIME_WITH_TIME_ZONE-163))|(1<<(SQLBaseParserTIMESTAMP_WITH_TIME_ZONE-163))|(1<<(SQLBaseParserDOUBLE_PRECISION-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQLBaseParserPLUS-195))|(1<<(SQLBaseParserMINUS-195))|(1<<(SQLBaseParserSTRING-195))|(1<<(SQLBaseParserBINARY_LITERAL-195))|(1<<(SQLBaseParserINTEGER_VALUE-195))|(1<<(SQLBaseParserDECIMAL_VALUE-195))|(1<<(SQLBaseParserIDENTIFIER-195))|(1<<(SQLBaseParserDIGIT_IDENTIFIER-195))|(1<<(SQLBaseParserQUOTED_IDENTIFIER-195))|(1<<(SQLBaseParserBACKQUOTED_IDENTIFIER-195)))) != 0) {
			{
				p.SetState(621)
				p.Expression()
			}
			p.SetState(626)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(622)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(623)
					p.Expression()
				}

				p.SetState(628)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(631)
			p.Match(SQLBaseParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(632)
			p.Expression()
		}

	}

	return localctx
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_groupingSet
	return p
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *GroupingSetContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (p *SQLBaseParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SQLBaseParserRULE_groupingSet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(648)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLBaseParserT__0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(635)
			p.Match(SQLBaseParserT__0)
		}
		p.SetState(644)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQLBaseParserADD)|(1<<SQLBaseParserALL)|(1<<SQLBaseParserSOME)|(1<<SQLBaseParserANY)|(1<<SQLBaseParserAT))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(SQLBaseParserNO-33))|(1<<(SQLBaseParserSUBSTRING-33))|(1<<(SQLBaseParserPOSITION-33))|(1<<(SQLBaseParserTINYINT-33))|(1<<(SQLBaseParserSMALLINT-33))|(1<<(SQLBaseParserINTEGER-33))|(1<<(SQLBaseParserDATE-33))|(1<<(SQLBaseParserTIME-33))|(1<<(SQLBaseParserTIMESTAMP-33))|(1<<(SQLBaseParserINTERVAL-33))|(1<<(SQLBaseParserYEAR-33))|(1<<(SQLBaseParserMONTH-33))|(1<<(SQLBaseParserDAY-33))|(1<<(SQLBaseParserHOUR-33))|(1<<(SQLBaseParserMINUTE-33))|(1<<(SQLBaseParserSECOND-33))|(1<<(SQLBaseParserZONE-33)))) != 0) || (((_la-85)&-(0x1f+1)) == 0 && ((1<<uint((_la-85)))&((1<<(SQLBaseParserFILTER-85))|(1<<(SQLBaseParserOVER-85))|(1<<(SQLBaseParserPARTITION-85))|(1<<(SQLBaseParserRANGE-85))|(1<<(SQLBaseParserROWS-85))|(1<<(SQLBaseParserPRECEDING-85))|(1<<(SQLBaseParserFOLLOWING-85))|(1<<(SQLBaseParserCURRENT-85))|(1<<(SQLBaseParserROW-85))|(1<<(SQLBaseParserSCHEMA-85))|(1<<(SQLBaseParserCOMMENT-85))|(1<<(SQLBaseParserVIEW-85))|(1<<(SQLBaseParserREPLACE-85))|(1<<(SQLBaseParserGRANT-85))|(1<<(SQLBaseParserREVOKE-85))|(1<<(SQLBaseParserPRIVILEGES-85))|(1<<(SQLBaseParserPUBLIC-85))|(1<<(SQLBaseParserOPTION-85))|(1<<(SQLBaseParserEXPLAIN-85))|(1<<(SQLBaseParserANALYZE-85))|(1<<(SQLBaseParserFORMAT-85)))) != 0) || (((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(SQLBaseParserTYPE-117))|(1<<(SQLBaseParserTEXT-117))|(1<<(SQLBaseParserGRAPHVIZ-117))|(1<<(SQLBaseParserLOGICAL-117))|(1<<(SQLBaseParserDISTRIBUTED-117))|(1<<(SQLBaseParserVALIDATE-117))|(1<<(SQLBaseParserSHOW-117))|(1<<(SQLBaseParserTABLES-117))|(1<<(SQLBaseParserSCHEMAS-117))|(1<<(SQLBaseParserCATALOGS-117))|(1<<(SQLBaseParserCOLUMNS-117))|(1<<(SQLBaseParserCOLUMN-117))|(1<<(SQLBaseParserUSE-117))|(1<<(SQLBaseParserPARTITIONS-117))|(1<<(SQLBaseParserFUNCTIONS-117))|(1<<(SQLBaseParserTO-117))|(1<<(SQLBaseParserSYSTEM-117))|(1<<(SQLBaseParserBERNOULLI-117))|(1<<(SQLBaseParserPOISSONIZED-117))|(1<<(SQLBaseParserTABLESAMPLE-117))|(1<<(SQLBaseParserARRAY-117))|(1<<(SQLBaseParserMAP-117)))) != 0) || (((_la-149)&-(0x1f+1)) == 0 && ((1<<uint((_la-149)))&((1<<(SQLBaseParserSET-149))|(1<<(SQLBaseParserRESET-149))|(1<<(SQLBaseParserSESSION-149))|(1<<(SQLBaseParserDATA-149))|(1<<(SQLBaseParserSTART-149))|(1<<(SQLBaseParserTRANSACTION-149))|(1<<(SQLBaseParserCOMMIT-149))|(1<<(SQLBaseParserROLLBACK-149))|(1<<(SQLBaseParserWORK-149))|(1<<(SQLBaseParserISOLATION-149))|(1<<(SQLBaseParserLEVEL-149))|(1<<(SQLBaseParserSERIALIZABLE-149))|(1<<(SQLBaseParserREPEATABLE-149))|(1<<(SQLBaseParserCOMMITTED-149))|(1<<(SQLBaseParserUNCOMMITTED-149))|(1<<(SQLBaseParserREAD-149))|(1<<(SQLBaseParserWRITE-149))|(1<<(SQLBaseParserONLY-149))|(1<<(SQLBaseParserCALL-149))|(1<<(SQLBaseParserINPUT-149))|(1<<(SQLBaseParserOUTPUT-149))|(1<<(SQLBaseParserCASCADE-149))|(1<<(SQLBaseParserRESTRICT-149))|(1<<(SQLBaseParserINCLUDING-149))|(1<<(SQLBaseParserEXCLUDING-149))|(1<<(SQLBaseParserPROPERTIES-149))|(1<<(SQLBaseParserNFD-149))|(1<<(SQLBaseParserNFC-149)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(SQLBaseParserNFKD-181))|(1<<(SQLBaseParserNFKC-181))|(1<<(SQLBaseParserIF-181))|(1<<(SQLBaseParserNULLIF-181))|(1<<(SQLBaseParserCOALESCE-181))|(1<<(SQLBaseParserIDENTIFIER-181))|(1<<(SQLBaseParserDIGIT_IDENTIFIER-181))|(1<<(SQLBaseParserQUOTED_IDENTIFIER-181))|(1<<(SQLBaseParserBACKQUOTED_IDENTIFIER-181)))) != 0) {
			{
				p.SetState(636)
				p.QualifiedName()
			}
			p.SetState(641)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(637)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(638)
					p.QualifiedName()
				}

				p.SetState(643)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(646)
			p.Match(SQLBaseParserT__2)
		}

	case SQLBaseParserADD, SQLBaseParserALL, SQLBaseParserSOME, SQLBaseParserANY, SQLBaseParserAT, SQLBaseParserNO, SQLBaseParserSUBSTRING, SQLBaseParserPOSITION, SQLBaseParserTINYINT, SQLBaseParserSMALLINT, SQLBaseParserINTEGER, SQLBaseParserDATE, SQLBaseParserTIME, SQLBaseParserTIMESTAMP, SQLBaseParserINTERVAL, SQLBaseParserYEAR, SQLBaseParserMONTH, SQLBaseParserDAY, SQLBaseParserHOUR, SQLBaseParserMINUTE, SQLBaseParserSECOND, SQLBaseParserZONE, SQLBaseParserFILTER, SQLBaseParserOVER, SQLBaseParserPARTITION, SQLBaseParserRANGE, SQLBaseParserROWS, SQLBaseParserPRECEDING, SQLBaseParserFOLLOWING, SQLBaseParserCURRENT, SQLBaseParserROW, SQLBaseParserSCHEMA, SQLBaseParserCOMMENT, SQLBaseParserVIEW, SQLBaseParserREPLACE, SQLBaseParserGRANT, SQLBaseParserREVOKE, SQLBaseParserPRIVILEGES, SQLBaseParserPUBLIC, SQLBaseParserOPTION, SQLBaseParserEXPLAIN, SQLBaseParserANALYZE, SQLBaseParserFORMAT, SQLBaseParserTYPE, SQLBaseParserTEXT, SQLBaseParserGRAPHVIZ, SQLBaseParserLOGICAL, SQLBaseParserDISTRIBUTED, SQLBaseParserVALIDATE, SQLBaseParserSHOW, SQLBaseParserTABLES, SQLBaseParserSCHEMAS, SQLBaseParserCATALOGS, SQLBaseParserCOLUMNS, SQLBaseParserCOLUMN, SQLBaseParserUSE, SQLBaseParserPARTITIONS, SQLBaseParserFUNCTIONS, SQLBaseParserTO, SQLBaseParserSYSTEM, SQLBaseParserBERNOULLI, SQLBaseParserPOISSONIZED, SQLBaseParserTABLESAMPLE, SQLBaseParserARRAY, SQLBaseParserMAP, SQLBaseParserSET, SQLBaseParserRESET, SQLBaseParserSESSION, SQLBaseParserDATA, SQLBaseParserSTART, SQLBaseParserTRANSACTION, SQLBaseParserCOMMIT, SQLBaseParserROLLBACK, SQLBaseParserWORK, SQLBaseParserISOLATION, SQLBaseParserLEVEL, SQLBaseParserSERIALIZABLE, SQLBaseParserREPEATABLE, SQLBaseParserCOMMITTED, SQLBaseParserUNCOMMITTED, SQLBaseParserREAD, SQLBaseParserWRITE, SQLBaseParserONLY, SQLBaseParserCALL, SQLBaseParserINPUT, SQLBaseParserOUTPUT, SQLBaseParserCASCADE, SQLBaseParserRESTRICT, SQLBaseParserINCLUDING, SQLBaseParserEXCLUDING, SQLBaseParserPROPERTIES, SQLBaseParserNFD, SQLBaseParserNFC, SQLBaseParserNFKD, SQLBaseParserNFKC, SQLBaseParserIF, SQLBaseParserNULLIF, SQLBaseParserCOALESCE, SQLBaseParserIDENTIFIER, SQLBaseParserDIGIT_IDENTIFIER, SQLBaseParserQUOTED_IDENTIFIER, SQLBaseParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(647)
			p.QualifiedName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INamedQueryContext is an interface to support dynamic dispatch.
type INamedQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// IsNamedQueryContext differentiates from other interfaces.
	IsNamedQueryContext()
}

type NamedQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyNamedQueryContext() *NamedQueryContext {
	var p = new(NamedQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_namedQuery
	return p
}

func (*NamedQueryContext) IsNamedQueryContext() {}

func NewNamedQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedQueryContext {
	var p = new(NamedQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_namedQuery

	return p
}

func (s *NamedQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedQueryContext) GetName() IIdentifierContext { return s.name }

func (s *NamedQueryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *NamedQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserAS, 0)
}

func (s *NamedQueryContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *NamedQueryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedQueryContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NamedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterNamedQuery(s)
	}
}

func (s *NamedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitNamedQuery(s)
	}
}

func (p *SQLBaseParser) NamedQuery() (localctx INamedQueryContext) {
	localctx = NewNamedQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SQLBaseParserRULE_namedQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)

		var _x = p.Identifier()

		localctx.(*NamedQueryContext).name = _x
	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserT__0 {
		{
			p.SetState(651)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(654)
		p.Match(SQLBaseParserAS)
	}
	{
		p.SetState(655)
		p.Match(SQLBaseParserT__0)
	}
	{
		p.SetState(656)
		p.Query()
	}
	{
		p.SetState(657)
		p.Match(SQLBaseParserT__2)
	}

	return localctx
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_setQuantifier
	return p
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (p *SQLBaseParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SQLBaseParserRULE_setQuantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(659)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SQLBaseParserALL || _la == SQLBaseParserDISTINCT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_selectItem
	return p
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyFrom(ctx *SelectItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	*SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SelectAllContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserASTERISK, 0)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

type SelectSingleContext struct {
	*SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (p *SQLBaseParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SQLBaseParserRULE_selectItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(673)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(661)
			p.Expression()
		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
			p.SetState(663)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQLBaseParserAS {
				{
					p.SetState(662)
					p.Match(SQLBaseParserAS)
				}

			}
			{
				p.SetState(665)
				p.Identifier()
			}

		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(668)
			p.QualifiedName()
		}
		{
			p.SetState(669)
			p.Match(SQLBaseParserDOT)
		}
		{
			p.SetState(670)
			p.Match(SQLBaseParserASTERISK)
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(672)
			p.Match(SQLBaseParserASTERISK)
		}

	}

	return localctx
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_relation
	return p
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyFrom(ctx *RelationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RelationDefaultContext struct {
	*RelationContext
}

func NewRelationDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationDefaultContext {
	var p = new(RelationDefaultContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *RelationDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationDefaultContext) SampledRelation() ISampledRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampledRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *RelationDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterRelationDefault(s)
	}
}

func (s *RelationDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitRelationDefault(s)
	}
}

type JoinRelationContext struct {
	*RelationContext
	left  IRelationContext
	right IRelationContext
}

func NewJoinRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinRelationContext {
	var p = new(JoinRelationContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *JoinRelationContext) GetLeft() IRelationContext { return s.left }

func (s *JoinRelationContext) GetRight() IRelationContext { return s.right }

func (s *JoinRelationContext) SetLeft(v IRelationContext) { s.left = v }

func (s *JoinRelationContext) SetRight(v IRelationContext) { s.right = v }

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) AllRelation() []IRelationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationContext)(nil)).Elem())
	var tst = make([]IRelationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationContext)
		}
	}

	return tst
}

func (s *JoinRelationContext) Relation(i int) IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *JoinRelationContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserJOIN, 0)
}

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinCriteriaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *SQLBaseParser) Relation() (localctx IRelationContext) {
	return p.relation(0)
}

func (p *SQLBaseParser) relation(_p int) (localctx IRelationContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRelationContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelationContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 42
	p.EnterRecursionRule(localctx, 42, SQLBaseParserRULE_relation, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewRelationDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(676)
		p.SampledRelation()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(689)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewJoinRelationContext(p, NewRelationContext(p, _parentctx, _parentState))
			localctx.(*JoinRelationContext).left = _prevctx

			p.PushNewRecursionContext(localctx, _startState, SQLBaseParserRULE_relation)
			p.SetState(678)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}

			p.SetState(680)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(SQLBaseParserCROSS-76))|(1<<(SQLBaseParserINNER-76))|(1<<(SQLBaseParserLEFT-76))|(1<<(SQLBaseParserRIGHT-76))|(1<<(SQLBaseParserFULL-76))|(1<<(SQLBaseParserNATURAL-76)))) != 0 {
				{
					p.SetState(679)
					p.JoinType()
				}

			}
			{
				p.SetState(682)
				p.Match(SQLBaseParserJOIN)
			}
			{
				p.SetState(683)

				var _x = p.relation(0)

				localctx.(*JoinRelationContext).right = _x
			}
			p.SetState(685)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(684)
					p.JoinCriteria()
				}

			}

		}
		p.SetState(691)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())
	}

	return localctx
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_joinType
	return p
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINNER, 0)
}

func (s *JoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLEFT, 0)
}

func (s *JoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserOUTER, 0)
}

func (s *JoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserRIGHT, 0)
}

func (s *JoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFULL, 0)
}

func (s *JoinTypeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCROSS, 0)
}

func (s *JoinTypeContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNATURAL, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (p *SQLBaseParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SQLBaseParserRULE_joinType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(692)
			p.Match(SQLBaseParserINNER)
		}

	case 2:
		{
			p.SetState(693)
			p.Match(SQLBaseParserLEFT)
		}
		{
			p.SetState(694)
			p.Match(SQLBaseParserOUTER)
		}

	case 3:
		{
			p.SetState(695)
			p.Match(SQLBaseParserRIGHT)
		}
		{
			p.SetState(696)
			p.Match(SQLBaseParserOUTER)
		}

	case 4:
		{
			p.SetState(697)
			p.Match(SQLBaseParserFULL)
		}
		{
			p.SetState(698)
			p.Match(SQLBaseParserOUTER)
		}

	case 5:
		{
			p.SetState(699)
			p.Match(SQLBaseParserCROSS)
		}

	case 6:
		{
			p.SetState(700)
			p.Match(SQLBaseParserNATURAL)
		}

	case 7:
		{
			p.SetState(701)
			p.Match(SQLBaseParserLEFT)
		}

	}

	return localctx
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_joinCriteria
	return p
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserUSING, 0)
}

func (s *JoinCriteriaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *JoinCriteriaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (p *SQLBaseParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SQLBaseParserRULE_joinCriteria)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(718)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLBaseParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(704)
			p.Match(SQLBaseParserON)
		}
		{
			p.SetState(705)
			p.booleanExpression(0)
		}

	case SQLBaseParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(706)
			p.Match(SQLBaseParserUSING)
		}
		{
			p.SetState(707)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(708)
			p.Identifier()
		}
		p.SetState(713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLBaseParserT__1 {
			{
				p.SetState(709)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(710)
				p.Identifier()
			}

			p.SetState(715)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(716)
			p.Match(SQLBaseParserT__2)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISampledRelationContext is an interface to support dynamic dispatch.
type ISampledRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSampletype returns the sampletype token.
	GetSampletype() antlr.Token

	// SetSampletype sets the sampletype token.
	SetSampletype(antlr.Token)

	// GetPercentage returns the percentage rule contexts.
	GetPercentage() IExpressionContext

	// SetPercentage sets the percentage rule contexts.
	SetPercentage(IExpressionContext)

	// IsSampledRelationContext differentiates from other interfaces.
	IsSampledRelationContext()
}

type SampledRelationContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	sampletype antlr.Token
	percentage IExpressionContext
}

func NewEmptySampledRelationContext() *SampledRelationContext {
	var p = new(SampledRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_sampledRelation
	return p
}

func (*SampledRelationContext) IsSampledRelationContext() {}

func NewSampledRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampledRelationContext {
	var p = new(SampledRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_sampledRelation

	return p
}

func (s *SampledRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *SampledRelationContext) GetSampletype() antlr.Token { return s.sampletype }

func (s *SampledRelationContext) SetSampletype(v antlr.Token) { s.sampletype = v }

func (s *SampledRelationContext) GetPercentage() IExpressionContext { return s.percentage }

func (s *SampledRelationContext) SetPercentage(v IExpressionContext) { s.percentage = v }

func (s *SampledRelationContext) AliasedRelation() IAliasedRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasedRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *SampledRelationContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLESAMPLE, 0)
}

func (s *SampledRelationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampledRelationContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserBERNOULLI, 0)
}

func (s *SampledRelationContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSYSTEM, 0)
}

func (s *SampledRelationContext) POISSONIZED() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPOISSONIZED, 0)
}

func (s *SampledRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampledRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampledRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSampledRelation(s)
	}
}

func (s *SampledRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSampledRelation(s)
	}
}

func (p *SQLBaseParser) SampledRelation() (localctx ISampledRelationContext) {
	localctx = NewSampledRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SQLBaseParserRULE_sampledRelation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(720)
		p.AliasedRelation()
	}
	p.SetState(727)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(721)
			p.Match(SQLBaseParserTABLESAMPLE)
		}
		p.SetState(722)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SampledRelationContext).sampletype = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(SQLBaseParserSYSTEM-139))|(1<<(SQLBaseParserBERNOULLI-139))|(1<<(SQLBaseParserPOISSONIZED-139)))) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SampledRelationContext).sampletype = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(723)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(724)

			var _x = p.Expression()

			localctx.(*SampledRelationContext).percentage = _x
		}
		{
			p.SetState(725)
			p.Match(SQLBaseParserT__2)
		}

	}

	return localctx
}

// IAliasedRelationContext is an interface to support dynamic dispatch.
type IAliasedRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasedRelationContext differentiates from other interfaces.
	IsAliasedRelationContext()
}

type AliasedRelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedRelationContext() *AliasedRelationContext {
	var p = new(AliasedRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_aliasedRelation
	return p
}

func (*AliasedRelationContext) IsAliasedRelationContext() {}

func NewAliasedRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedRelationContext {
	var p = new(AliasedRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_aliasedRelation

	return p
}

func (s *AliasedRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *AliasedRelationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasedRelationContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserAS, 0)
}

func (s *AliasedRelationContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *AliasedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitAliasedRelation(s)
	}
}

func (p *SQLBaseParser) AliasedRelation() (localctx IAliasedRelationContext) {
	localctx = NewAliasedRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SQLBaseParserRULE_aliasedRelation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.RelationPrimary()
	}
	p.SetState(737)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
		p.SetState(731)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserAS {
			{
				p.SetState(730)
				p.Match(SQLBaseParserAS)
			}

		}
		{
			p.SetState(733)
			p.Identifier()
		}
		p.SetState(735)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(734)
				p.ColumnAliases()
			}

		}

	}

	return localctx
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_columnAliases
	return p
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (p *SQLBaseParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SQLBaseParserRULE_columnAliases)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.Match(SQLBaseParserT__0)
	}
	{
		p.SetState(740)
		p.Identifier()
	}
	p.SetState(745)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLBaseParserT__1 {
		{
			p.SetState(741)
			p.Match(SQLBaseParserT__1)
		}
		{
			p.SetState(742)
			p.Identifier()
		}

		p.SetState(747)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(748)
		p.Match(SQLBaseParserT__2)
	}

	return localctx
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_relationPrimary
	return p
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyFrom(ctx *RelationPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryRelationContext struct {
	*RelationPrimaryContext
}

func NewSubqueryRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryRelationContext {
	var p = new(SubqueryRelationContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *SubqueryRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryRelationContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSubqueryRelation(s)
	}
}

func (s *SubqueryRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSubqueryRelation(s)
	}
}

type ParenthesizedRelationContext struct {
	*RelationPrimaryContext
}

func NewParenthesizedRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedRelationContext {
	var p = new(ParenthesizedRelationContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *ParenthesizedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedRelationContext) Relation() IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *ParenthesizedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitParenthesizedRelation(s)
	}
}

type UnnestContext struct {
	*RelationPrimaryContext
}

func NewUnnestContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnnestContext {
	var p = new(UnnestContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *UnnestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnnestContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserUNNEST, 0)
}

func (s *UnnestContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *UnnestContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnnestContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWITH, 0)
}

func (s *UnnestContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserORDINALITY, 0)
}

func (s *UnnestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterUnnest(s)
	}
}

func (s *UnnestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitUnnest(s)
	}
}

type TableNameContext struct {
	*RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *SQLBaseParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SQLBaseParserRULE_relationPrimary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(750)
			p.QualifiedName()
		}

	case 2:
		localctx = NewSubqueryRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(751)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(752)
			p.Query()
		}
		{
			p.SetState(753)
			p.Match(SQLBaseParserT__2)
		}

	case 3:
		localctx = NewUnnestContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(755)
			p.Match(SQLBaseParserUNNEST)
		}
		{
			p.SetState(756)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(757)
			p.Expression()
		}
		p.SetState(762)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLBaseParserT__1 {
			{
				p.SetState(758)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(759)
				p.Expression()
			}

			p.SetState(764)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(765)
			p.Match(SQLBaseParserT__2)
		}
		p.SetState(768)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(766)
				p.Match(SQLBaseParserWITH)
			}
			{
				p.SetState(767)
				p.Match(SQLBaseParserORDINALITY)
			}

		}

	case 4:
		localctx = NewParenthesizedRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(770)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(771)
			p.relation(0)
		}
		{
			p.SetState(772)
			p.Match(SQLBaseParserT__2)
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *SQLBaseParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SQLBaseParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(776)
			p.booleanExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(777)
			p.valueExpression(0)
		}

	}

	return localctx
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_booleanExpression
	return p
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyFrom(ctx *BooleanExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	*BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type BooleanDefaultContext struct {
	*BooleanExpressionContext
}

func NewBooleanDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanDefaultContext {
	var p = new(BooleanDefaultContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *BooleanDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanDefaultContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BooleanDefaultContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BooleanDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterBooleanDefault(s)
	}
}

func (s *BooleanDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitBooleanDefault(s)
	}
}

type BoolLiteralTooContext struct {
	*BooleanExpressionContext
}

func NewBoolLiteralTooContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoolLiteralTooContext {
	var p = new(BoolLiteralTooContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *BoolLiteralTooContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolLiteralTooContext) Booleanliteral() IBooleanliteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanliteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanliteralContext)
}

func (s *BoolLiteralTooContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterBoolLiteralToo(s)
	}
}

func (s *BoolLiteralTooContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitBoolLiteralToo(s)
	}
}

type LogicalBinaryContext struct {
	*BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserAND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (p *SQLBaseParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *SQLBaseParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 58
	p.EnterRecursionRule(localctx, 58, SQLBaseParserRULE_booleanExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		localctx = NewBooleanDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(781)
			p.valueExpression(0)
		}
		{
			p.SetState(782)
			p.Predicate()
		}

	case 2:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(784)
			p.Match(SQLBaseParserNOT)
		}
		{
			p.SetState(785)
			p.booleanExpression(3)
		}

	case 3:
		localctx = NewBoolLiteralTooContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(786)
			p.Booleanliteral()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(794)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
			localctx.(*LogicalBinaryContext).left = _prevctx

			p.PushNewRecursionContext(localctx, _startState, SQLBaseParserRULE_booleanExpression)
			p.SetState(789)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			p.SetState(790)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LogicalBinaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLBaseParserOR || _la == SQLBaseParserAND) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LogicalBinaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			{
				p.SetState(791)

				var _x = p.Expression()

				localctx.(*LogicalBinaryContext).right = _x
			}

		}
		p.SetState(796)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())
	}

	return localctx
}

// IBooleanliteralContext is an interface to support dynamic dispatch.
type IBooleanliteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanliteralContext differentiates from other interfaces.
	IsBooleanliteralContext()
}

type BooleanliteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanliteralContext() *BooleanliteralContext {
	var p = new(BooleanliteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_booleanliteral
	return p
}

func (*BooleanliteralContext) IsBooleanliteralContext() {}

func NewBooleanliteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanliteralContext {
	var p = new(BooleanliteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_booleanliteral

	return p
}

func (s *BooleanliteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanliteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTRUE, 0)
}

func (s *BooleanliteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFALSE, 0)
}

func (s *BooleanliteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanliteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanliteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterBooleanliteral(s)
	}
}

func (s *BooleanliteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitBooleanliteral(s)
	}
}

func (p *SQLBaseParser) Booleanliteral() (localctx IBooleanliteralContext) {
	localctx = NewBooleanliteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SQLBaseParserRULE_booleanliteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(797)
	_la = p.GetTokenStream().LA(1)

	if !(_la == SQLBaseParserTRUE || _la == SQLBaseParserFALSE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitComparison(s)
	}
}

type LikeContext struct {
	*PredicateContext
	pattern IValueExpressionContext
	escape  IValueExpressionContext
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) GetEscape() IValueExpressionContext { return s.escape }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) SetEscape(v IValueExpressionContext) { s.escape = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLIKE, 0)
}

func (s *LikeContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *LikeContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNOT, 0)
}

func (s *LikeContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserESCAPE, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitLike(s)
	}
}

type InSubqueryContext struct {
	*PredicateContext
}

func NewInSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InSubqueryContext {
	var p = new(InSubqueryContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIN, 0)
}

func (s *InSubqueryContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNOT, 0)
}

func (s *InSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterInSubquery(s)
	}
}

func (s *InSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitInSubquery(s)
	}
}

type DistinctFromContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewDistinctFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DistinctFromContext {
	var p = new(DistinctFromContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *DistinctFromContext) GetRight() IValueExpressionContext { return s.right }

func (s *DistinctFromContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *DistinctFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctFromContext) IS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIS, 0)
}

func (s *DistinctFromContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDISTINCT, 0)
}

func (s *DistinctFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFROM, 0)
}

func (s *DistinctFromContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DistinctFromContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNOT, 0)
}

func (s *DistinctFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterDistinctFrom(s)
	}
}

func (s *DistinctFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitDistinctFrom(s)
	}
}

type InListContext struct {
	*PredicateContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIN, 0)
}

func (s *InListContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *InListContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitInList(s)
	}
}

type NullPredicateContext struct {
	*PredicateContext
}

func NewNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullPredicateContext {
	var p = new(NullPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *NullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIS, 0)
}

func (s *NullPredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNULL, 0)
}

func (s *NullPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNOT, 0)
}

func (s *NullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterNullPredicate(s)
	}
}

func (s *NullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitNullPredicate(s)
	}
}

type BetweenContext struct {
	*PredicateContext
	lower IValueExpressionContext
	upper IValueExpressionContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserAND, 0)
}

func (s *BetweenContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *BetweenContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitBetween(s)
	}
}

type QuantifiedComparisonContext struct {
	*PredicateContext
}

func NewQuantifiedComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuantifiedComparisonContext {
	var p = new(QuantifiedComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *QuantifiedComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *QuantifiedComparisonContext) ComparisonQuantifier() IComparisonQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonQuantifierContext)
}

func (s *QuantifiedComparisonContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QuantifiedComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterQuantifiedComparison(s)
	}
}

func (s *QuantifiedComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitQuantifiedComparison(s)
	}
}

func (p *SQLBaseParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SQLBaseParserRULE_predicate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(799)
			p.ComparisonOperator()
		}
		{
			p.SetState(800)

			var _x = p.valueExpression(0)

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		localctx = NewQuantifiedComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(802)
			p.ComparisonOperator()
		}
		{
			p.SetState(803)
			p.ComparisonQuantifier()
		}
		{
			p.SetState(804)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(805)
			p.Query()
		}
		{
			p.SetState(806)
			p.Match(SQLBaseParserT__2)
		}

	case 3:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(809)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserNOT {
			{
				p.SetState(808)
				p.Match(SQLBaseParserNOT)
			}

		}
		{
			p.SetState(811)
			p.Match(SQLBaseParserBETWEEN)
		}
		{
			p.SetState(812)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(813)
			p.Match(SQLBaseParserAND)
		}
		{
			p.SetState(814)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).upper = _x
		}

	case 4:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserNOT {
			{
				p.SetState(816)
				p.Match(SQLBaseParserNOT)
			}

		}
		{
			p.SetState(819)
			p.Match(SQLBaseParserIN)
		}
		{
			p.SetState(820)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(821)
			p.valueExpression(0)
		}
		p.SetState(826)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLBaseParserT__1 {
			{
				p.SetState(822)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(823)
				p.valueExpression(0)
			}

			p.SetState(828)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(829)
			p.Match(SQLBaseParserT__2)
		}

	case 5:
		localctx = NewInSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(832)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserNOT {
			{
				p.SetState(831)
				p.Match(SQLBaseParserNOT)
			}

		}
		{
			p.SetState(834)
			p.Match(SQLBaseParserIN)
		}
		{
			p.SetState(835)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(836)
			p.Query()
		}
		{
			p.SetState(837)
			p.Match(SQLBaseParserT__2)
		}

	case 6:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(840)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserNOT {
			{
				p.SetState(839)
				p.Match(SQLBaseParserNOT)
			}

		}
		{
			p.SetState(842)
			p.Match(SQLBaseParserLIKE)
		}
		{
			p.SetState(843)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}
		p.SetState(846)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(844)
				p.Match(SQLBaseParserESCAPE)
			}
			{
				p.SetState(845)

				var _x = p.valueExpression(0)

				localctx.(*LikeContext).escape = _x
			}

		}

	case 7:
		localctx = NewNullPredicateContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(848)
			p.Match(SQLBaseParserIS)
		}
		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserNOT {
			{
				p.SetState(849)
				p.Match(SQLBaseParserNOT)
			}

		}
		{
			p.SetState(852)
			p.Match(SQLBaseParserNULL)
		}

	case 8:
		localctx = NewDistinctFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(853)
			p.Match(SQLBaseParserIS)
		}
		p.SetState(855)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserNOT {
			{
				p.SetState(854)
				p.Match(SQLBaseParserNOT)
			}

		}
		{
			p.SetState(857)
			p.Match(SQLBaseParserDISTINCT)
		}
		{
			p.SetState(858)
			p.Match(SQLBaseParserFROM)
		}
		{
			p.SetState(859)

			var _x = p.valueExpression(0)

			localctx.(*DistinctFromContext).right = _x
		}

	}

	return localctx
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_valueExpression
	return p
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyFrom(ctx *ValueExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	*ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ConcatenationContext struct {
	*ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConcatenationContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ConcatenationContext) GetRight() IValueExpressionContext { return s.right }

func (s *ConcatenationContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ConcatenationContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCONCAT, 0)
}

func (s *ConcatenationContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ConcatenationContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

type ArithmeticBinaryContext struct {
	*ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPERCENT, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserMINUS, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type ArithmeticUnaryContext struct {
	*ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserMINUS, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

type AtTimeZoneContext struct {
	*ValueExpressionContext
}

func NewAtTimeZoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtTimeZoneContext {
	var p = new(AtTimeZoneContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *AtTimeZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtTimeZoneContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AtTimeZoneContext) AT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserAT, 0)
}

func (s *AtTimeZoneContext) TimeZoneSpecifier() ITimeZoneSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeZoneSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeZoneSpecifierContext)
}

func (s *AtTimeZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitAtTimeZone(s)
	}
}

func (p *SQLBaseParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *SQLBaseParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 64
	p.EnterRecursionRule(localctx, 64, SQLBaseParserRULE_valueExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(866)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLBaseParserT__0, SQLBaseParserT__3, SQLBaseParserADD, SQLBaseParserALL, SQLBaseParserSOME, SQLBaseParserANY, SQLBaseParserAT, SQLBaseParserNO, SQLBaseParserEXISTS, SQLBaseParserNULL, SQLBaseParserTRUE, SQLBaseParserFALSE, SQLBaseParserSUBSTRING, SQLBaseParserPOSITION, SQLBaseParserTINYINT, SQLBaseParserSMALLINT, SQLBaseParserINTEGER, SQLBaseParserDATE, SQLBaseParserTIME, SQLBaseParserTIMESTAMP, SQLBaseParserINTERVAL, SQLBaseParserYEAR, SQLBaseParserMONTH, SQLBaseParserDAY, SQLBaseParserHOUR, SQLBaseParserMINUTE, SQLBaseParserSECOND, SQLBaseParserZONE, SQLBaseParserCURRENT_DATE, SQLBaseParserCURRENT_TIME, SQLBaseParserCURRENT_TIMESTAMP, SQLBaseParserLOCALTIME, SQLBaseParserLOCALTIMESTAMP, SQLBaseParserEXTRACT, SQLBaseParserCASE, SQLBaseParserFILTER, SQLBaseParserOVER, SQLBaseParserPARTITION, SQLBaseParserRANGE, SQLBaseParserROWS, SQLBaseParserPRECEDING, SQLBaseParserFOLLOWING, SQLBaseParserCURRENT, SQLBaseParserROW, SQLBaseParserSCHEMA, SQLBaseParserCOMMENT, SQLBaseParserVIEW, SQLBaseParserREPLACE, SQLBaseParserGRANT, SQLBaseParserREVOKE, SQLBaseParserPRIVILEGES, SQLBaseParserPUBLIC, SQLBaseParserOPTION, SQLBaseParserEXPLAIN, SQLBaseParserANALYZE, SQLBaseParserFORMAT, SQLBaseParserTYPE, SQLBaseParserTEXT, SQLBaseParserGRAPHVIZ, SQLBaseParserLOGICAL, SQLBaseParserDISTRIBUTED, SQLBaseParserVALIDATE, SQLBaseParserCAST, SQLBaseParserTRY_CAST, SQLBaseParserSHOW, SQLBaseParserTABLES, SQLBaseParserSCHEMAS, SQLBaseParserCATALOGS, SQLBaseParserCOLUMNS, SQLBaseParserCOLUMN, SQLBaseParserUSE, SQLBaseParserPARTITIONS, SQLBaseParserFUNCTIONS, SQLBaseParserTO, SQLBaseParserSYSTEM, SQLBaseParserBERNOULLI, SQLBaseParserPOISSONIZED, SQLBaseParserTABLESAMPLE, SQLBaseParserARRAY, SQLBaseParserMAP, SQLBaseParserSET, SQLBaseParserRESET, SQLBaseParserSESSION, SQLBaseParserDATA, SQLBaseParserSTART, SQLBaseParserTRANSACTION, SQLBaseParserCOMMIT, SQLBaseParserROLLBACK, SQLBaseParserWORK, SQLBaseParserISOLATION, SQLBaseParserLEVEL, SQLBaseParserSERIALIZABLE, SQLBaseParserREPEATABLE, SQLBaseParserCOMMITTED, SQLBaseParserUNCOMMITTED, SQLBaseParserREAD, SQLBaseParserWRITE, SQLBaseParserONLY, SQLBaseParserCALL, SQLBaseParserINPUT, SQLBaseParserOUTPUT, SQLBaseParserCASCADE, SQLBaseParserRESTRICT, SQLBaseParserINCLUDING, SQLBaseParserEXCLUDING, SQLBaseParserPROPERTIES, SQLBaseParserNORMALIZE, SQLBaseParserNFD, SQLBaseParserNFC, SQLBaseParserNFKD, SQLBaseParserNFKC, SQLBaseParserIF, SQLBaseParserNULLIF, SQLBaseParserCOALESCE, SQLBaseParserTIME_WITH_TIME_ZONE, SQLBaseParserTIMESTAMP_WITH_TIME_ZONE, SQLBaseParserDOUBLE_PRECISION, SQLBaseParserSTRING, SQLBaseParserBINARY_LITERAL, SQLBaseParserINTEGER_VALUE, SQLBaseParserDECIMAL_VALUE, SQLBaseParserIDENTIFIER, SQLBaseParserDIGIT_IDENTIFIER, SQLBaseParserQUOTED_IDENTIFIER, SQLBaseParserBACKQUOTED_IDENTIFIER:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(863)
			p.primaryExpression(0)
		}

	case SQLBaseParserPLUS, SQLBaseParserMINUS:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(864)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*ArithmeticUnaryContext).operator = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserPLUS || _la == SQLBaseParserMINUS) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*ArithmeticUnaryContext).operator = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(865)
			p.valueExpression(3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(877)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SQLBaseParserRULE_valueExpression)
				p.SetState(868)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				p.SetState(869)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ArithmeticBinaryContext).operator = _lt

				_la = p.GetTokenStream().LA(1)

				if !(((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQLBaseParserPLUS-195))|(1<<(SQLBaseParserMINUS-195))|(1<<(SQLBaseParserASTERISK-195))|(1<<(SQLBaseParserSLASH-195))|(1<<(SQLBaseParserPERCENT-195)))) != 0) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ArithmeticBinaryContext).operator = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
				{
					p.SetState(870)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewConcatenationContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatenationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SQLBaseParserRULE_valueExpression)
				p.SetState(871)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(872)
					p.Match(SQLBaseParserCONCAT)
				}
				{
					p.SetState(873)

					var _x = p.valueExpression(2)

					localctx.(*ConcatenationContext).right = _x
				}

			case 3:
				localctx = NewAtTimeZoneContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SQLBaseParserRULE_valueExpression)
				p.SetState(874)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(875)
					p.Match(SQLBaseParserAT)
				}
				{
					p.SetState(876)
					p.TimeZoneSpecifier()
				}

			}

		}
		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyFrom(ctx *PrimaryExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	*PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitDereference(s)
	}
}

type DecimalLiteralContext struct {
	*PrimaryExpressionContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

type TypeConstructorContext struct {
	*PrimaryExpressionContext
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) STRING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSTRING, 0)
}

func (s *TypeConstructorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeConstructorContext) DOUBLE_PRECISION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDOUBLE_PRECISION, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

type SpecialDateTimeFunctionContext struct {
	*PrimaryExpressionContext
	name      antlr.Token
	precision antlr.Token
}

func NewSpecialDateTimeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDateTimeFunctionContext {
	var p = new(SpecialDateTimeFunctionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SpecialDateTimeFunctionContext) GetName() antlr.Token { return s.name }

func (s *SpecialDateTimeFunctionContext) GetPrecision() antlr.Token { return s.precision }

func (s *SpecialDateTimeFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *SpecialDateTimeFunctionContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *SpecialDateTimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeFunctionContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCURRENT_DATE, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCURRENT_TIME, 0)
}

func (s *SpecialDateTimeFunctionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINTEGER_VALUE, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCURRENT_TIMESTAMP, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLOCALTIME, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLOCALTIMESTAMP, 0)
}

func (s *SpecialDateTimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSpecialDateTimeFunction(s)
	}
}

func (s *SpecialDateTimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSpecialDateTimeFunction(s)
	}
}

type BoolLiteralContext struct {
	*PrimaryExpressionContext
}

func NewBoolLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoolLiteralContext {
	var p = new(BoolLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BoolLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolLiteralContext) Booleanliteral() IBooleanliteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanliteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanliteralContext)
}

func (s *BoolLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterBoolLiteral(s)
	}
}

func (s *BoolLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitBoolLiteral(s)
	}
}

type SubstringContext struct {
	*PrimaryExpressionContext
	subterm  IValueExpressionContext
	baseterm IValueExpressionContext
	forterm  IValueExpressionContext
}

func NewSubstringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstringContext {
	var p = new(SubstringContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubstringContext) GetSubterm() IValueExpressionContext { return s.subterm }

func (s *SubstringContext) GetBaseterm() IValueExpressionContext { return s.baseterm }

func (s *SubstringContext) GetForterm() IValueExpressionContext { return s.forterm }

func (s *SubstringContext) SetSubterm(v IValueExpressionContext) { s.subterm = v }

func (s *SubstringContext) SetBaseterm(v IValueExpressionContext) { s.baseterm = v }

func (s *SubstringContext) SetForterm(v IValueExpressionContext) { s.forterm = v }

func (s *SubstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstringContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSUBSTRING, 0)
}

func (s *SubstringContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFROM, 0)
}

func (s *SubstringContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *SubstringContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubstringContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFOR, 0)
}

func (s *SubstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSubstring(s)
	}
}

func (s *SubstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSubstring(s)
	}
}

type CastContext struct {
	*PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserAS, 0)
}

func (s *CastContext) Type_t() IType_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_tContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_tContext)
}

func (s *CastContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTRY_CAST, 0)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitCast(s)
	}
}

type LambdaContext struct {
	*PrimaryExpressionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *LambdaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitLambda(s)
	}
}

type ParenthesizedExpressionContext struct {
	*PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type ParameterContext struct {
	*PrimaryExpressionContext
}

func NewParameterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParameterContext {
	var p = new(ParameterContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitParameter(s)
	}
}

type NormalizeContext struct {
	*PrimaryExpressionContext
	normalform antlr.Token
}

func NewNormalizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NormalizeContext {
	var p = new(NormalizeContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NormalizeContext) GetNormalform() antlr.Token { return s.normalform }

func (s *NormalizeContext) SetNormalform(v antlr.Token) { s.normalform = v }

func (s *NormalizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizeContext) NORMALIZE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNORMALIZE, 0)
}

func (s *NormalizeContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *NormalizeContext) NFD() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNFD, 0)
}

func (s *NormalizeContext) NFC() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNFC, 0)
}

func (s *NormalizeContext) NFKD() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNFKD, 0)
}

func (s *NormalizeContext) NFKC() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNFKC, 0)
}

func (s *NormalizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterNormalize(s)
	}
}

func (s *NormalizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitNormalize(s)
	}
}

type IntervalLiteralContext struct {
	*PrimaryExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

type SimpleCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCASE, 0)
}

func (s *SimpleCaseContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEND, 0)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserELSE, 0)
}

func (s *SimpleCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type ColumnReferenceContext struct {
	*PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type NullLiteralContext struct {
	*PrimaryExpressionContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type TypedLiteralContext struct {
	*PrimaryExpressionContext
}

func NewTypedLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypedLiteralContext {
	var p = new(TypedLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TypedLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedLiteralContext) BaseType() IBaseTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBaseTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *TypedLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSTRING, 0)
}

func (s *TypedLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterTypedLiteral(s)
	}
}

func (s *TypedLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitTypedLiteral(s)
	}
}

type RowConstructorContext struct {
	*PrimaryExpressionContext
}

func NewRowConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowConstructorContext {
	var p = new(RowConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *RowConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RowConstructorContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserROW, 0)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

type SubscriptContext struct {
	*PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSubscript(s)
	}
}

type SubqueryExpressionContext struct {
	*PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

type BinaryLiteralContext struct {
	*PrimaryExpressionContext
}

func NewBinaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryLiteralContext {
	var p = new(BinaryLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BinaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryLiteralContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserBINARY_LITERAL, 0)
}

func (s *BinaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitBinaryLiteral(s)
	}
}

type ExtractContext struct {
	*PrimaryExpressionContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEXTRACT, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFROM, 0)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitExtract(s)
	}
}

type StringLiteralContext struct {
	*PrimaryExpressionContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSTRING, 0)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type ArrayConstructorContext struct {
	*PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserARRAY, 0)
}

func (s *ArrayConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

type FunctionCallContext struct {
	*PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *FunctionCallContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserASTERISK, 0)
}

func (s *FunctionCallContext) Filter() IFilterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilterContext)
}

func (s *FunctionCallContext) Over() IOverContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOverContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *FunctionCallContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type IntegerLiteralContext struct {
	*PrimaryExpressionContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

type ExistsContext struct {
	*PrimaryExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEXISTS, 0)
}

func (s *ExistsContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitExists(s)
	}
}

type PositionContext struct {
	*PrimaryExpressionContext
}

func NewPositionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionContext {
	var p = new(PositionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *PositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPOSITION, 0)
}

func (s *PositionContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *PositionContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PositionContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIN, 0)
}

func (s *PositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterPosition(s)
	}
}

func (s *PositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitPosition(s)
	}
}

type SearchedCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (p *SQLBaseParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *SQLBaseParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 66
	p.EnterRecursionRule(localctx, 66, SQLBaseParserRULE_primaryExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(883)
			p.Match(SQLBaseParserNULL)
		}

	case 2:
		localctx = NewStringLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(884)
			p.Match(SQLBaseParserSTRING)
		}

	case 3:
		localctx = NewBinaryLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(885)
			p.Match(SQLBaseParserBINARY_LITERAL)
		}

	case 4:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(886)
			p.Match(SQLBaseParserDECIMAL_VALUE)
		}

	case 5:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(887)
			p.Match(SQLBaseParserINTEGER_VALUE)
		}

	case 6:
		localctx = NewBoolLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(888)
			p.Booleanliteral()
		}

	case 7:
		localctx = NewTypedLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(889)
			p.BaseType()
		}
		{
			p.SetState(890)
			p.Match(SQLBaseParserSTRING)
		}

	case 8:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(892)
			p.Interval()
		}

	case 9:
		localctx = NewParameterContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(893)
			p.Match(SQLBaseParserT__3)
		}

	case 10:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(896)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLBaseParserADD, SQLBaseParserALL, SQLBaseParserSOME, SQLBaseParserANY, SQLBaseParserAT, SQLBaseParserNO, SQLBaseParserSUBSTRING, SQLBaseParserPOSITION, SQLBaseParserTINYINT, SQLBaseParserSMALLINT, SQLBaseParserINTEGER, SQLBaseParserDATE, SQLBaseParserTIME, SQLBaseParserTIMESTAMP, SQLBaseParserINTERVAL, SQLBaseParserYEAR, SQLBaseParserMONTH, SQLBaseParserDAY, SQLBaseParserHOUR, SQLBaseParserMINUTE, SQLBaseParserSECOND, SQLBaseParserZONE, SQLBaseParserFILTER, SQLBaseParserOVER, SQLBaseParserPARTITION, SQLBaseParserRANGE, SQLBaseParserROWS, SQLBaseParserPRECEDING, SQLBaseParserFOLLOWING, SQLBaseParserCURRENT, SQLBaseParserROW, SQLBaseParserSCHEMA, SQLBaseParserCOMMENT, SQLBaseParserVIEW, SQLBaseParserREPLACE, SQLBaseParserGRANT, SQLBaseParserREVOKE, SQLBaseParserPRIVILEGES, SQLBaseParserPUBLIC, SQLBaseParserOPTION, SQLBaseParserEXPLAIN, SQLBaseParserANALYZE, SQLBaseParserFORMAT, SQLBaseParserTYPE, SQLBaseParserTEXT, SQLBaseParserGRAPHVIZ, SQLBaseParserLOGICAL, SQLBaseParserDISTRIBUTED, SQLBaseParserVALIDATE, SQLBaseParserSHOW, SQLBaseParserTABLES, SQLBaseParserSCHEMAS, SQLBaseParserCATALOGS, SQLBaseParserCOLUMNS, SQLBaseParserCOLUMN, SQLBaseParserUSE, SQLBaseParserPARTITIONS, SQLBaseParserFUNCTIONS, SQLBaseParserTO, SQLBaseParserSYSTEM, SQLBaseParserBERNOULLI, SQLBaseParserPOISSONIZED, SQLBaseParserTABLESAMPLE, SQLBaseParserARRAY, SQLBaseParserMAP, SQLBaseParserSET, SQLBaseParserRESET, SQLBaseParserSESSION, SQLBaseParserDATA, SQLBaseParserSTART, SQLBaseParserTRANSACTION, SQLBaseParserCOMMIT, SQLBaseParserROLLBACK, SQLBaseParserWORK, SQLBaseParserISOLATION, SQLBaseParserLEVEL, SQLBaseParserSERIALIZABLE, SQLBaseParserREPEATABLE, SQLBaseParserCOMMITTED, SQLBaseParserUNCOMMITTED, SQLBaseParserREAD, SQLBaseParserWRITE, SQLBaseParserONLY, SQLBaseParserCALL, SQLBaseParserINPUT, SQLBaseParserOUTPUT, SQLBaseParserCASCADE, SQLBaseParserRESTRICT, SQLBaseParserINCLUDING, SQLBaseParserEXCLUDING, SQLBaseParserPROPERTIES, SQLBaseParserNFD, SQLBaseParserNFC, SQLBaseParserNFKD, SQLBaseParserNFKC, SQLBaseParserIF, SQLBaseParserNULLIF, SQLBaseParserCOALESCE, SQLBaseParserIDENTIFIER, SQLBaseParserDIGIT_IDENTIFIER, SQLBaseParserQUOTED_IDENTIFIER, SQLBaseParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(894)
				p.Identifier()
			}

		case SQLBaseParserDOUBLE_PRECISION:
			{
				p.SetState(895)
				p.Match(SQLBaseParserDOUBLE_PRECISION)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(898)
			p.Match(SQLBaseParserSTRING)
		}

	case 11:
		localctx = NewPositionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(899)
			p.Match(SQLBaseParserPOSITION)
		}
		{
			p.SetState(900)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(901)
			p.valueExpression(0)
		}
		{
			p.SetState(902)
			p.Match(SQLBaseParserIN)
		}
		{
			p.SetState(903)
			p.valueExpression(0)
		}
		{
			p.SetState(904)
			p.Match(SQLBaseParserT__2)
		}

	case 12:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(906)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(907)
			p.Expression()
		}
		p.SetState(910)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SQLBaseParserT__1 {
			{
				p.SetState(908)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(909)
				p.Expression()
			}

			p.SetState(912)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(914)
			p.Match(SQLBaseParserT__2)
		}

	case 13:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(916)
			p.Match(SQLBaseParserROW)
		}
		{
			p.SetState(917)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(918)
			p.Expression()
		}
		p.SetState(923)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLBaseParserT__1 {
			{
				p.SetState(919)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(920)
				p.Expression()
			}

			p.SetState(925)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(926)
			p.Match(SQLBaseParserT__2)
		}

	case 14:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(928)
			p.QualifiedName()
		}
		{
			p.SetState(929)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(930)
			p.Match(SQLBaseParserASTERISK)
		}
		{
			p.SetState(931)
			p.Match(SQLBaseParserT__2)
		}
		p.SetState(933)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(932)
				p.Filter()
			}

		}
		p.SetState(936)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(935)
				p.Over()
			}

		}

	case 15:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(938)
			p.QualifiedName()
		}
		{
			p.SetState(939)
			p.Match(SQLBaseParserT__0)
		}
		p.SetState(951)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQLBaseParserT__0)|(1<<SQLBaseParserT__3)|(1<<SQLBaseParserADD)|(1<<SQLBaseParserALL)|(1<<SQLBaseParserSOME)|(1<<SQLBaseParserANY)|(1<<SQLBaseParserDISTINCT)|(1<<SQLBaseParserAT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SQLBaseParserNOT-32))|(1<<(SQLBaseParserNO-32))|(1<<(SQLBaseParserEXISTS-32))|(1<<(SQLBaseParserNULL-32))|(1<<(SQLBaseParserTRUE-32))|(1<<(SQLBaseParserFALSE-32))|(1<<(SQLBaseParserSUBSTRING-32))|(1<<(SQLBaseParserPOSITION-32))|(1<<(SQLBaseParserTINYINT-32))|(1<<(SQLBaseParserSMALLINT-32))|(1<<(SQLBaseParserINTEGER-32))|(1<<(SQLBaseParserDATE-32))|(1<<(SQLBaseParserTIME-32))|(1<<(SQLBaseParserTIMESTAMP-32))|(1<<(SQLBaseParserINTERVAL-32))|(1<<(SQLBaseParserYEAR-32))|(1<<(SQLBaseParserMONTH-32))|(1<<(SQLBaseParserDAY-32))|(1<<(SQLBaseParserHOUR-32))|(1<<(SQLBaseParserMINUTE-32))|(1<<(SQLBaseParserSECOND-32))|(1<<(SQLBaseParserZONE-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SQLBaseParserCURRENT_DATE-64))|(1<<(SQLBaseParserCURRENT_TIME-64))|(1<<(SQLBaseParserCURRENT_TIMESTAMP-64))|(1<<(SQLBaseParserLOCALTIME-64))|(1<<(SQLBaseParserLOCALTIMESTAMP-64))|(1<<(SQLBaseParserEXTRACT-64))|(1<<(SQLBaseParserCASE-64))|(1<<(SQLBaseParserFILTER-64))|(1<<(SQLBaseParserOVER-64))|(1<<(SQLBaseParserPARTITION-64))|(1<<(SQLBaseParserRANGE-64))|(1<<(SQLBaseParserROWS-64))|(1<<(SQLBaseParserPRECEDING-64))|(1<<(SQLBaseParserFOLLOWING-64))|(1<<(SQLBaseParserCURRENT-64))|(1<<(SQLBaseParserROW-64)))) != 0) || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(SQLBaseParserSCHEMA-99))|(1<<(SQLBaseParserCOMMENT-99))|(1<<(SQLBaseParserVIEW-99))|(1<<(SQLBaseParserREPLACE-99))|(1<<(SQLBaseParserGRANT-99))|(1<<(SQLBaseParserREVOKE-99))|(1<<(SQLBaseParserPRIVILEGES-99))|(1<<(SQLBaseParserPUBLIC-99))|(1<<(SQLBaseParserOPTION-99))|(1<<(SQLBaseParserEXPLAIN-99))|(1<<(SQLBaseParserANALYZE-99))|(1<<(SQLBaseParserFORMAT-99))|(1<<(SQLBaseParserTYPE-99))|(1<<(SQLBaseParserTEXT-99))|(1<<(SQLBaseParserGRAPHVIZ-99))|(1<<(SQLBaseParserLOGICAL-99))|(1<<(SQLBaseParserDISTRIBUTED-99))|(1<<(SQLBaseParserVALIDATE-99))|(1<<(SQLBaseParserCAST-99))|(1<<(SQLBaseParserTRY_CAST-99))|(1<<(SQLBaseParserSHOW-99))|(1<<(SQLBaseParserTABLES-99))|(1<<(SQLBaseParserSCHEMAS-99))|(1<<(SQLBaseParserCATALOGS-99))|(1<<(SQLBaseParserCOLUMNS-99))|(1<<(SQLBaseParserCOLUMN-99)))) != 0) || (((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(SQLBaseParserUSE-131))|(1<<(SQLBaseParserPARTITIONS-131))|(1<<(SQLBaseParserFUNCTIONS-131))|(1<<(SQLBaseParserTO-131))|(1<<(SQLBaseParserSYSTEM-131))|(1<<(SQLBaseParserBERNOULLI-131))|(1<<(SQLBaseParserPOISSONIZED-131))|(1<<(SQLBaseParserTABLESAMPLE-131))|(1<<(SQLBaseParserARRAY-131))|(1<<(SQLBaseParserMAP-131))|(1<<(SQLBaseParserSET-131))|(1<<(SQLBaseParserRESET-131))|(1<<(SQLBaseParserSESSION-131))|(1<<(SQLBaseParserDATA-131))|(1<<(SQLBaseParserSTART-131))|(1<<(SQLBaseParserTRANSACTION-131))|(1<<(SQLBaseParserCOMMIT-131))|(1<<(SQLBaseParserROLLBACK-131))|(1<<(SQLBaseParserWORK-131))|(1<<(SQLBaseParserISOLATION-131))|(1<<(SQLBaseParserLEVEL-131))|(1<<(SQLBaseParserSERIALIZABLE-131))|(1<<(SQLBaseParserREPEATABLE-131))|(1<<(SQLBaseParserCOMMITTED-131)))) != 0) || (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQLBaseParserUNCOMMITTED-163))|(1<<(SQLBaseParserREAD-163))|(1<<(SQLBaseParserWRITE-163))|(1<<(SQLBaseParserONLY-163))|(1<<(SQLBaseParserCALL-163))|(1<<(SQLBaseParserINPUT-163))|(1<<(SQLBaseParserOUTPUT-163))|(1<<(SQLBaseParserCASCADE-163))|(1<<(SQLBaseParserRESTRICT-163))|(1<<(SQLBaseParserINCLUDING-163))|(1<<(SQLBaseParserEXCLUDING-163))|(1<<(SQLBaseParserPROPERTIES-163))|(1<<(SQLBaseParserNORMALIZE-163))|(1<<(SQLBaseParserNFD-163))|(1<<(SQLBaseParserNFC-163))|(1<<(SQLBaseParserNFKD-163))|(1<<(SQLBaseParserNFKC-163))|(1<<(SQLBaseParserIF-163))|(1<<(SQLBaseParserNULLIF-163))|(1<<(SQLBaseParserCOALESCE-163))|(1<<(SQLBaseParserTIME_WITH_TIME_ZONE-163))|(1<<(SQLBaseParserTIMESTAMP_WITH_TIME_ZONE-163))|(1<<(SQLBaseParserDOUBLE_PRECISION-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQLBaseParserPLUS-195))|(1<<(SQLBaseParserMINUS-195))|(1<<(SQLBaseParserSTRING-195))|(1<<(SQLBaseParserBINARY_LITERAL-195))|(1<<(SQLBaseParserINTEGER_VALUE-195))|(1<<(SQLBaseParserDECIMAL_VALUE-195))|(1<<(SQLBaseParserIDENTIFIER-195))|(1<<(SQLBaseParserDIGIT_IDENTIFIER-195))|(1<<(SQLBaseParserQUOTED_IDENTIFIER-195))|(1<<(SQLBaseParserBACKQUOTED_IDENTIFIER-195)))) != 0) {
			p.SetState(941)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(940)
					p.SetQuantifier()
				}

			}
			{
				p.SetState(943)
				p.Expression()
			}
			p.SetState(948)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(944)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(945)
					p.Expression()
				}

				p.SetState(950)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(953)
			p.Match(SQLBaseParserT__2)
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(954)
				p.Filter()
			}

		}
		p.SetState(958)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(957)
				p.Over()
			}

		}

	case 16:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(960)
			p.Identifier()
		}
		{
			p.SetState(961)
			p.Match(SQLBaseParserT__4)
		}
		{
			p.SetState(962)
			p.Expression()
		}

	case 17:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(964)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(965)
			p.Identifier()
		}
		p.SetState(970)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLBaseParserT__1 {
			{
				p.SetState(966)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(967)
				p.Identifier()
			}

			p.SetState(972)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(973)
			p.Match(SQLBaseParserT__2)
		}
		{
			p.SetState(974)
			p.Match(SQLBaseParserT__4)
		}
		{
			p.SetState(975)
			p.Expression()
		}

	case 18:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(977)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(978)
			p.Query()
		}
		{
			p.SetState(979)
			p.Match(SQLBaseParserT__2)
		}

	case 19:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(981)
			p.Match(SQLBaseParserEXISTS)
		}
		{
			p.SetState(982)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(983)
			p.Query()
		}
		{
			p.SetState(984)
			p.Match(SQLBaseParserT__2)
		}

	case 20:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(986)
			p.Match(SQLBaseParserCASE)
		}
		{
			p.SetState(987)
			p.valueExpression(0)
		}
		p.SetState(989)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SQLBaseParserWHEN {
			{
				p.SetState(988)
				p.WhenClause()
			}

			p.SetState(991)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(995)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserELSE {
			{
				p.SetState(993)
				p.Match(SQLBaseParserELSE)
			}
			{
				p.SetState(994)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(997)
			p.Match(SQLBaseParserEND)
		}

	case 21:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(999)
			p.Match(SQLBaseParserCASE)
		}
		p.SetState(1001)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SQLBaseParserWHEN {
			{
				p.SetState(1000)
				p.WhenClause()
			}

			p.SetState(1003)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1007)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserELSE {
			{
				p.SetState(1005)
				p.Match(SQLBaseParserELSE)
			}
			{
				p.SetState(1006)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(1009)
			p.Match(SQLBaseParserEND)
		}

	case 22:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1011)
			p.Match(SQLBaseParserCAST)
		}
		{
			p.SetState(1012)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(1013)
			p.Expression()
		}
		{
			p.SetState(1014)
			p.Match(SQLBaseParserAS)
		}
		{
			p.SetState(1015)
			p.type_t(0)
		}
		{
			p.SetState(1016)
			p.Match(SQLBaseParserT__2)
		}

	case 23:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1018)
			p.Match(SQLBaseParserTRY_CAST)
		}
		{
			p.SetState(1019)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(1020)
			p.Expression()
		}
		{
			p.SetState(1021)
			p.Match(SQLBaseParserAS)
		}
		{
			p.SetState(1022)
			p.type_t(0)
		}
		{
			p.SetState(1023)
			p.Match(SQLBaseParserT__2)
		}

	case 24:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1025)
			p.Match(SQLBaseParserARRAY)
		}
		{
			p.SetState(1026)
			p.Match(SQLBaseParserT__5)
		}
		p.SetState(1035)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQLBaseParserT__0)|(1<<SQLBaseParserT__3)|(1<<SQLBaseParserADD)|(1<<SQLBaseParserALL)|(1<<SQLBaseParserSOME)|(1<<SQLBaseParserANY)|(1<<SQLBaseParserAT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SQLBaseParserNOT-32))|(1<<(SQLBaseParserNO-32))|(1<<(SQLBaseParserEXISTS-32))|(1<<(SQLBaseParserNULL-32))|(1<<(SQLBaseParserTRUE-32))|(1<<(SQLBaseParserFALSE-32))|(1<<(SQLBaseParserSUBSTRING-32))|(1<<(SQLBaseParserPOSITION-32))|(1<<(SQLBaseParserTINYINT-32))|(1<<(SQLBaseParserSMALLINT-32))|(1<<(SQLBaseParserINTEGER-32))|(1<<(SQLBaseParserDATE-32))|(1<<(SQLBaseParserTIME-32))|(1<<(SQLBaseParserTIMESTAMP-32))|(1<<(SQLBaseParserINTERVAL-32))|(1<<(SQLBaseParserYEAR-32))|(1<<(SQLBaseParserMONTH-32))|(1<<(SQLBaseParserDAY-32))|(1<<(SQLBaseParserHOUR-32))|(1<<(SQLBaseParserMINUTE-32))|(1<<(SQLBaseParserSECOND-32))|(1<<(SQLBaseParserZONE-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SQLBaseParserCURRENT_DATE-64))|(1<<(SQLBaseParserCURRENT_TIME-64))|(1<<(SQLBaseParserCURRENT_TIMESTAMP-64))|(1<<(SQLBaseParserLOCALTIME-64))|(1<<(SQLBaseParserLOCALTIMESTAMP-64))|(1<<(SQLBaseParserEXTRACT-64))|(1<<(SQLBaseParserCASE-64))|(1<<(SQLBaseParserFILTER-64))|(1<<(SQLBaseParserOVER-64))|(1<<(SQLBaseParserPARTITION-64))|(1<<(SQLBaseParserRANGE-64))|(1<<(SQLBaseParserROWS-64))|(1<<(SQLBaseParserPRECEDING-64))|(1<<(SQLBaseParserFOLLOWING-64))|(1<<(SQLBaseParserCURRENT-64))|(1<<(SQLBaseParserROW-64)))) != 0) || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(SQLBaseParserSCHEMA-99))|(1<<(SQLBaseParserCOMMENT-99))|(1<<(SQLBaseParserVIEW-99))|(1<<(SQLBaseParserREPLACE-99))|(1<<(SQLBaseParserGRANT-99))|(1<<(SQLBaseParserREVOKE-99))|(1<<(SQLBaseParserPRIVILEGES-99))|(1<<(SQLBaseParserPUBLIC-99))|(1<<(SQLBaseParserOPTION-99))|(1<<(SQLBaseParserEXPLAIN-99))|(1<<(SQLBaseParserANALYZE-99))|(1<<(SQLBaseParserFORMAT-99))|(1<<(SQLBaseParserTYPE-99))|(1<<(SQLBaseParserTEXT-99))|(1<<(SQLBaseParserGRAPHVIZ-99))|(1<<(SQLBaseParserLOGICAL-99))|(1<<(SQLBaseParserDISTRIBUTED-99))|(1<<(SQLBaseParserVALIDATE-99))|(1<<(SQLBaseParserCAST-99))|(1<<(SQLBaseParserTRY_CAST-99))|(1<<(SQLBaseParserSHOW-99))|(1<<(SQLBaseParserTABLES-99))|(1<<(SQLBaseParserSCHEMAS-99))|(1<<(SQLBaseParserCATALOGS-99))|(1<<(SQLBaseParserCOLUMNS-99))|(1<<(SQLBaseParserCOLUMN-99)))) != 0) || (((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(SQLBaseParserUSE-131))|(1<<(SQLBaseParserPARTITIONS-131))|(1<<(SQLBaseParserFUNCTIONS-131))|(1<<(SQLBaseParserTO-131))|(1<<(SQLBaseParserSYSTEM-131))|(1<<(SQLBaseParserBERNOULLI-131))|(1<<(SQLBaseParserPOISSONIZED-131))|(1<<(SQLBaseParserTABLESAMPLE-131))|(1<<(SQLBaseParserARRAY-131))|(1<<(SQLBaseParserMAP-131))|(1<<(SQLBaseParserSET-131))|(1<<(SQLBaseParserRESET-131))|(1<<(SQLBaseParserSESSION-131))|(1<<(SQLBaseParserDATA-131))|(1<<(SQLBaseParserSTART-131))|(1<<(SQLBaseParserTRANSACTION-131))|(1<<(SQLBaseParserCOMMIT-131))|(1<<(SQLBaseParserROLLBACK-131))|(1<<(SQLBaseParserWORK-131))|(1<<(SQLBaseParserISOLATION-131))|(1<<(SQLBaseParserLEVEL-131))|(1<<(SQLBaseParserSERIALIZABLE-131))|(1<<(SQLBaseParserREPEATABLE-131))|(1<<(SQLBaseParserCOMMITTED-131)))) != 0) || (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQLBaseParserUNCOMMITTED-163))|(1<<(SQLBaseParserREAD-163))|(1<<(SQLBaseParserWRITE-163))|(1<<(SQLBaseParserONLY-163))|(1<<(SQLBaseParserCALL-163))|(1<<(SQLBaseParserINPUT-163))|(1<<(SQLBaseParserOUTPUT-163))|(1<<(SQLBaseParserCASCADE-163))|(1<<(SQLBaseParserRESTRICT-163))|(1<<(SQLBaseParserINCLUDING-163))|(1<<(SQLBaseParserEXCLUDING-163))|(1<<(SQLBaseParserPROPERTIES-163))|(1<<(SQLBaseParserNORMALIZE-163))|(1<<(SQLBaseParserNFD-163))|(1<<(SQLBaseParserNFC-163))|(1<<(SQLBaseParserNFKD-163))|(1<<(SQLBaseParserNFKC-163))|(1<<(SQLBaseParserIF-163))|(1<<(SQLBaseParserNULLIF-163))|(1<<(SQLBaseParserCOALESCE-163))|(1<<(SQLBaseParserTIME_WITH_TIME_ZONE-163))|(1<<(SQLBaseParserTIMESTAMP_WITH_TIME_ZONE-163))|(1<<(SQLBaseParserDOUBLE_PRECISION-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQLBaseParserPLUS-195))|(1<<(SQLBaseParserMINUS-195))|(1<<(SQLBaseParserSTRING-195))|(1<<(SQLBaseParserBINARY_LITERAL-195))|(1<<(SQLBaseParserINTEGER_VALUE-195))|(1<<(SQLBaseParserDECIMAL_VALUE-195))|(1<<(SQLBaseParserIDENTIFIER-195))|(1<<(SQLBaseParserDIGIT_IDENTIFIER-195))|(1<<(SQLBaseParserQUOTED_IDENTIFIER-195))|(1<<(SQLBaseParserBACKQUOTED_IDENTIFIER-195)))) != 0) {
			{
				p.SetState(1027)
				p.Expression()
			}
			p.SetState(1032)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(1028)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(1029)
					p.Expression()
				}

				p.SetState(1034)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1037)
			p.Match(SQLBaseParserT__6)
		}

	case 25:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1038)
			p.Identifier()
		}

	case 26:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1039)

			var _m = p.Match(SQLBaseParserCURRENT_DATE)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}

	case 27:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1040)

			var _m = p.Match(SQLBaseParserCURRENT_TIME)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(1044)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1041)
				p.Match(SQLBaseParserT__0)
			}
			{
				p.SetState(1042)

				var _m = p.Match(SQLBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(1043)
				p.Match(SQLBaseParserT__2)
			}

		}

	case 28:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1046)

			var _m = p.Match(SQLBaseParserCURRENT_TIMESTAMP)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(1050)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1047)
				p.Match(SQLBaseParserT__0)
			}
			{
				p.SetState(1048)

				var _m = p.Match(SQLBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(1049)
				p.Match(SQLBaseParserT__2)
			}

		}

	case 29:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1052)

			var _m = p.Match(SQLBaseParserLOCALTIME)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(1056)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1053)
				p.Match(SQLBaseParserT__0)
			}
			{
				p.SetState(1054)

				var _m = p.Match(SQLBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(1055)
				p.Match(SQLBaseParserT__2)
			}

		}

	case 30:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1058)

			var _m = p.Match(SQLBaseParserLOCALTIMESTAMP)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(1062)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1059)
				p.Match(SQLBaseParserT__0)
			}
			{
				p.SetState(1060)

				var _m = p.Match(SQLBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(1061)
				p.Match(SQLBaseParserT__2)
			}

		}

	case 31:
		localctx = NewSubstringContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1064)
			p.Match(SQLBaseParserSUBSTRING)
		}
		{
			p.SetState(1065)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(1066)

			var _x = p.valueExpression(0)

			localctx.(*SubstringContext).subterm = _x
		}
		{
			p.SetState(1067)
			p.Match(SQLBaseParserFROM)
		}
		{
			p.SetState(1068)

			var _x = p.valueExpression(0)

			localctx.(*SubstringContext).baseterm = _x
		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserFOR {
			{
				p.SetState(1069)
				p.Match(SQLBaseParserFOR)
			}
			{
				p.SetState(1070)

				var _x = p.valueExpression(0)

				localctx.(*SubstringContext).forterm = _x
			}

		}
		{
			p.SetState(1073)
			p.Match(SQLBaseParserT__2)
		}

	case 32:
		localctx = NewNormalizeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1075)
			p.Match(SQLBaseParserNORMALIZE)
		}
		{
			p.SetState(1076)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(1077)
			p.valueExpression(0)
		}
		p.SetState(1080)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLBaseParserT__1 {
			{
				p.SetState(1078)
				p.Match(SQLBaseParserT__1)
			}
			p.SetState(1079)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NormalizeContext).normalform = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-179)&-(0x1f+1)) == 0 && ((1<<uint((_la-179)))&((1<<(SQLBaseParserNFD-179))|(1<<(SQLBaseParserNFC-179))|(1<<(SQLBaseParserNFKD-179))|(1<<(SQLBaseParserNFKC-179)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NormalizeContext).normalform = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}

		}
		{
			p.SetState(1082)
			p.Match(SQLBaseParserT__2)
		}

	case 33:
		localctx = NewExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1084)
			p.Match(SQLBaseParserEXTRACT)
		}
		{
			p.SetState(1085)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(1086)
			p.Identifier()
		}
		{
			p.SetState(1087)
			p.Match(SQLBaseParserFROM)
		}
		{
			p.SetState(1088)
			p.valueExpression(0)
		}
		{
			p.SetState(1089)
			p.Match(SQLBaseParserT__2)
		}

	case 34:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1091)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(1092)
			p.Expression()
		}
		{
			p.SetState(1093)
			p.Match(SQLBaseParserT__2)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1107)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1105)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SQLBaseParserRULE_primaryExpression)
				p.SetState(1097)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(1098)
					p.Match(SQLBaseParserT__5)
				}
				{
					p.SetState(1099)

					var _x = p.valueExpression(0)

					localctx.(*SubscriptContext).index = _x
				}
				{
					p.SetState(1100)
					p.Match(SQLBaseParserT__6)
				}

			case 2:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SQLBaseParserRULE_primaryExpression)
				p.SetState(1102)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1103)
					p.Match(SQLBaseParserDOT)
				}
				{
					p.SetState(1104)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			}

		}
		p.SetState(1109)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())
	}

	return localctx
}

// ITimeZoneSpecifierContext is an interface to support dynamic dispatch.
type ITimeZoneSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeZoneSpecifierContext differentiates from other interfaces.
	IsTimeZoneSpecifierContext()
}

type TimeZoneSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeZoneSpecifierContext() *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_timeZoneSpecifier
	return p
}

func (*TimeZoneSpecifierContext) IsTimeZoneSpecifierContext() {}

func NewTimeZoneSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_timeZoneSpecifier

	return p
}

func (s *TimeZoneSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeZoneSpecifierContext) CopyFrom(ctx *TimeZoneSpecifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TimeZoneSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TimeZoneIntervalContext struct {
	*TimeZoneSpecifierContext
}

func NewTimeZoneIntervalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneIntervalContext {
	var p = new(TimeZoneIntervalContext)

	p.TimeZoneSpecifierContext = NewEmptyTimeZoneSpecifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneIntervalContext) TIME() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTIME, 0)
}

func (s *TimeZoneIntervalContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserZONE, 0)
}

func (s *TimeZoneIntervalContext) Interval() IIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *TimeZoneIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterTimeZoneInterval(s)
	}
}

func (s *TimeZoneIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitTimeZoneInterval(s)
	}
}

type TimeZoneStringContext struct {
	*TimeZoneSpecifierContext
}

func NewTimeZoneStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneStringContext {
	var p = new(TimeZoneStringContext)

	p.TimeZoneSpecifierContext = NewEmptyTimeZoneSpecifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneStringContext) TIME() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTIME, 0)
}

func (s *TimeZoneStringContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserZONE, 0)
}

func (s *TimeZoneStringContext) STRING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSTRING, 0)
}

func (s *TimeZoneStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitTimeZoneString(s)
	}
}

func (p *SQLBaseParser) TimeZoneSpecifier() (localctx ITimeZoneSpecifierContext) {
	localctx = NewTimeZoneSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SQLBaseParserRULE_timeZoneSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1116)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTimeZoneIntervalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1110)
			p.Match(SQLBaseParserTIME)
		}
		{
			p.SetState(1111)
			p.Match(SQLBaseParserZONE)
		}
		{
			p.SetState(1112)
			p.Interval()
		}

	case 2:
		localctx = NewTimeZoneStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1113)
			p.Match(SQLBaseParserTIME)
		}
		{
			p.SetState(1114)
			p.Match(SQLBaseParserZONE)
		}
		{
			p.SetState(1115)
			p.Match(SQLBaseParserSTRING)
		}

	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserGTE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *SQLBaseParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SQLBaseParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1118)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-189)&-(0x1f+1)) == 0 && ((1<<uint((_la-189)))&((1<<(SQLBaseParserEQ-189))|(1<<(SQLBaseParserNEQ-189))|(1<<(SQLBaseParserLT-189))|(1<<(SQLBaseParserLTE-189))|(1<<(SQLBaseParserGT-189))|(1<<(SQLBaseParserGTE-189)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IComparisonQuantifierContext is an interface to support dynamic dispatch.
type IComparisonQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonQuantifierContext differentiates from other interfaces.
	IsComparisonQuantifierContext()
}

type ComparisonQuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonQuantifierContext() *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_comparisonQuantifier
	return p
}

func (*ComparisonQuantifierContext) IsComparisonQuantifierContext() {}

func NewComparisonQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_comparisonQuantifier

	return p
}

func (s *ComparisonQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserALL, 0)
}

func (s *ComparisonQuantifierContext) SOME() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSOME, 0)
}

func (s *ComparisonQuantifierContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserANY, 0)
}

func (s *ComparisonQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterComparisonQuantifier(s)
	}
}

func (s *ComparisonQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitComparisonQuantifier(s)
	}
}

func (p *SQLBaseParser) ComparisonQuantifier() (localctx IComparisonQuantifierContext) {
	localctx = NewComparisonQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SQLBaseParserRULE_comparisonQuantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1120)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQLBaseParserALL)|(1<<SQLBaseParserSOME)|(1<<SQLBaseParserANY))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSign returns the sign token.
	GetSign() antlr.Token

	// SetSign sets the sign token.
	SetSign(antlr.Token)

	// GetFrom returns the from rule contexts.
	GetFrom() IIntervalFieldContext

	// GetTo returns the to rule contexts.
	GetTo() IIntervalFieldContext

	// SetFrom sets the from rule contexts.
	SetFrom(IIntervalFieldContext)

	// SetTo sets the to rule contexts.
	SetTo(IIntervalFieldContext)

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	sign   antlr.Token
	from   IIntervalFieldContext
	to     IIntervalFieldContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_interval
	return p
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetSign() antlr.Token { return s.sign }

func (s *IntervalContext) SetSign(v antlr.Token) { s.sign = v }

func (s *IntervalContext) GetFrom() IIntervalFieldContext { return s.from }

func (s *IntervalContext) GetTo() IIntervalFieldContext { return s.to }

func (s *IntervalContext) SetFrom(v IIntervalFieldContext) { s.from = v }

func (s *IntervalContext) SetTo(v IIntervalFieldContext) { s.to = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINTERVAL, 0)
}

func (s *IntervalContext) STRING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSTRING, 0)
}

func (s *IntervalContext) AllIntervalField() []IIntervalFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem())
	var tst = make([]IIntervalFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntervalFieldContext)
		}
	}

	return tst
}

func (s *IntervalContext) IntervalField(i int) IIntervalFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntervalFieldContext)
}

func (s *IntervalContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTO, 0)
}

func (s *IntervalContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPLUS, 0)
}

func (s *IntervalContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserMINUS, 0)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (p *SQLBaseParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SQLBaseParserRULE_interval)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1122)
		p.Match(SQLBaseParserINTERVAL)
	}
	p.SetState(1124)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserPLUS || _la == SQLBaseParserMINUS {
		p.SetState(1123)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IntervalContext).sign = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserPLUS || _la == SQLBaseParserMINUS) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IntervalContext).sign = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(1126)
		p.Match(SQLBaseParserSTRING)
	}
	{
		p.SetState(1127)

		var _x = p.IntervalField()

		localctx.(*IntervalContext).from = _x
	}
	p.SetState(1130)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1128)
			p.Match(SQLBaseParserTO)
		}
		{
			p.SetState(1129)

			var _x = p.IntervalField()

			localctx.(*IntervalContext).to = _x
		}

	}

	return localctx
}

// IIntervalFieldContext is an interface to support dynamic dispatch.
type IIntervalFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalFieldContext differentiates from other interfaces.
	IsIntervalFieldContext()
}

type IntervalFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalFieldContext() *IntervalFieldContext {
	var p = new(IntervalFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_intervalField
	return p
}

func (*IntervalFieldContext) IsIntervalFieldContext() {}

func NewIntervalFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalFieldContext {
	var p = new(IntervalFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_intervalField

	return p
}

func (s *IntervalFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalFieldContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserYEAR, 0)
}

func (s *IntervalFieldContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserMONTH, 0)
}

func (s *IntervalFieldContext) DAY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDAY, 0)
}

func (s *IntervalFieldContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserHOUR, 0)
}

func (s *IntervalFieldContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserMINUTE, 0)
}

func (s *IntervalFieldContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSECOND, 0)
}

func (s *IntervalFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterIntervalField(s)
	}
}

func (s *IntervalFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitIntervalField(s)
	}
}

func (p *SQLBaseParser) IntervalField() (localctx IIntervalFieldContext) {
	localctx = NewIntervalFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SQLBaseParserRULE_intervalField)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1132)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(SQLBaseParserYEAR-57))|(1<<(SQLBaseParserMONTH-57))|(1<<(SQLBaseParserDAY-57))|(1<<(SQLBaseParserHOUR-57))|(1<<(SQLBaseParserMINUTE-57))|(1<<(SQLBaseParserSECOND-57)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IType_tContext is an interface to support dynamic dispatch.
type IType_tContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_type_t returns the _type_t rule contexts.
	Get_type_t() IType_tContext

	// Get_identifier returns the _identifier rule contexts.
	Get_identifier() IIdentifierContext

	// Get_typeParameter returns the _typeParameter rule contexts.
	Get_typeParameter() ITypeParameterContext

	// Set_type_t sets the _type_t rule contexts.
	Set_type_t(IType_tContext)

	// Set_identifier sets the _identifier rule contexts.
	Set_identifier(IIdentifierContext)

	// Set_typeParameter sets the _typeParameter rule contexts.
	Set_typeParameter(ITypeParameterContext)

	// GetMapelem returns the mapelem rule context list.
	GetMapelem() []IType_tContext

	// GetRowidelem returns the rowidelem rule context list.
	GetRowidelem() []IIdentifierContext

	// GetRowelem returns the rowelem rule context list.
	GetRowelem() []IType_tContext

	// GetTypeelem returns the typeelem rule context list.
	GetTypeelem() []ITypeParameterContext

	// SetMapelem sets the mapelem rule context list.
	SetMapelem([]IType_tContext)

	// SetRowidelem sets the rowidelem rule context list.
	SetRowidelem([]IIdentifierContext)

	// SetRowelem sets the rowelem rule context list.
	SetRowelem([]IType_tContext)

	// SetTypeelem sets the typeelem rule context list.
	SetTypeelem([]ITypeParameterContext)

	// IsType_tContext differentiates from other interfaces.
	IsType_tContext()
}

type Type_tContext struct {
	*antlr.BaseParserRuleContext
	parser         antlr.Parser
	_type_t        IType_tContext
	mapelem        []IType_tContext
	_identifier    IIdentifierContext
	rowidelem      []IIdentifierContext
	rowelem        []IType_tContext
	_typeParameter ITypeParameterContext
	typeelem       []ITypeParameterContext
}

func NewEmptyType_tContext() *Type_tContext {
	var p = new(Type_tContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_type_t
	return p
}

func (*Type_tContext) IsType_tContext() {}

func NewType_tContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_tContext {
	var p = new(Type_tContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_type_t

	return p
}

func (s *Type_tContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_tContext) Get_type_t() IType_tContext { return s._type_t }

func (s *Type_tContext) Get_identifier() IIdentifierContext { return s._identifier }

func (s *Type_tContext) Get_typeParameter() ITypeParameterContext { return s._typeParameter }

func (s *Type_tContext) Set_type_t(v IType_tContext) { s._type_t = v }

func (s *Type_tContext) Set_identifier(v IIdentifierContext) { s._identifier = v }

func (s *Type_tContext) Set_typeParameter(v ITypeParameterContext) { s._typeParameter = v }

func (s *Type_tContext) GetMapelem() []IType_tContext { return s.mapelem }

func (s *Type_tContext) GetRowidelem() []IIdentifierContext { return s.rowidelem }

func (s *Type_tContext) GetRowelem() []IType_tContext { return s.rowelem }

func (s *Type_tContext) GetTypeelem() []ITypeParameterContext { return s.typeelem }

func (s *Type_tContext) SetMapelem(v []IType_tContext) { s.mapelem = v }

func (s *Type_tContext) SetRowidelem(v []IIdentifierContext) { s.rowidelem = v }

func (s *Type_tContext) SetRowelem(v []IType_tContext) { s.rowelem = v }

func (s *Type_tContext) SetTypeelem(v []ITypeParameterContext) { s.typeelem = v }

func (s *Type_tContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserARRAY, 0)
}

func (s *Type_tContext) AllType_t() []IType_tContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_tContext)(nil)).Elem())
	var tst = make([]IType_tContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_tContext)
		}
	}

	return tst
}

func (s *Type_tContext) Type_t(i int) IType_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_tContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_tContext)
}

func (s *Type_tContext) MAP() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserMAP, 0)
}

func (s *Type_tContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserROW, 0)
}

func (s *Type_tContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Type_tContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Type_tContext) BaseType() IBaseTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBaseTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *Type_tContext) AllTypeParameter() []ITypeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem())
	var tst = make([]ITypeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterContext)
		}
	}

	return tst
}

func (s *Type_tContext) TypeParameter(i int) ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *Type_tContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_tContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_tContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterType_t(s)
	}
}

func (s *Type_tContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitType_t(s)
	}
}

func (p *SQLBaseParser) Type_t() (localctx IType_tContext) {
	return p.type_t(0)
}

func (p *SQLBaseParser) type_t(_p int) (localctx IType_tContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewType_tContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IType_tContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 78
	p.EnterRecursionRule(localctx, 78, SQLBaseParserRULE_type_t, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1176)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1135)
			p.Match(SQLBaseParserARRAY)
		}
		{
			p.SetState(1136)
			p.Match(SQLBaseParserLT)
		}
		{
			p.SetState(1137)
			p.type_t(0)
		}
		{
			p.SetState(1138)
			p.Match(SQLBaseParserGT)
		}

	case 2:
		{
			p.SetState(1140)
			p.Match(SQLBaseParserMAP)
		}
		{
			p.SetState(1141)
			p.Match(SQLBaseParserLT)
		}
		{
			p.SetState(1142)

			var _x = p.type_t(0)

			localctx.(*Type_tContext)._type_t = _x
		}
		localctx.(*Type_tContext).mapelem = append(localctx.(*Type_tContext).mapelem, localctx.(*Type_tContext)._type_t)
		{
			p.SetState(1143)
			p.Match(SQLBaseParserT__1)
		}
		{
			p.SetState(1144)

			var _x = p.type_t(0)

			localctx.(*Type_tContext)._type_t = _x
		}
		localctx.(*Type_tContext).mapelem = append(localctx.(*Type_tContext).mapelem, localctx.(*Type_tContext)._type_t)
		{
			p.SetState(1145)
			p.Match(SQLBaseParserGT)
		}

	case 3:
		{
			p.SetState(1147)
			p.Match(SQLBaseParserROW)
		}
		{
			p.SetState(1148)
			p.Match(SQLBaseParserT__0)
		}
		{
			p.SetState(1149)

			var _x = p.Identifier()

			localctx.(*Type_tContext)._identifier = _x
		}
		localctx.(*Type_tContext).rowidelem = append(localctx.(*Type_tContext).rowidelem, localctx.(*Type_tContext)._identifier)
		{
			p.SetState(1150)

			var _x = p.type_t(0)

			localctx.(*Type_tContext)._type_t = _x
		}
		localctx.(*Type_tContext).rowelem = append(localctx.(*Type_tContext).rowelem, localctx.(*Type_tContext)._type_t)
		p.SetState(1157)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLBaseParserT__1 {
			{
				p.SetState(1151)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(1152)

				var _x = p.Identifier()

				localctx.(*Type_tContext)._identifier = _x
			}
			localctx.(*Type_tContext).rowidelem = append(localctx.(*Type_tContext).rowidelem, localctx.(*Type_tContext)._identifier)
			{
				p.SetState(1153)

				var _x = p.type_t(0)

				localctx.(*Type_tContext)._type_t = _x
			}
			localctx.(*Type_tContext).rowelem = append(localctx.(*Type_tContext).rowelem, localctx.(*Type_tContext)._type_t)

			p.SetState(1159)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1160)
			p.Match(SQLBaseParserT__2)
		}

	case 4:
		{
			p.SetState(1162)
			p.BaseType()
		}
		p.SetState(1174)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1163)
				p.Match(SQLBaseParserT__0)
			}
			{
				p.SetState(1164)

				var _x = p.TypeParameter()

				localctx.(*Type_tContext)._typeParameter = _x
			}
			localctx.(*Type_tContext).typeelem = append(localctx.(*Type_tContext).typeelem, localctx.(*Type_tContext)._typeParameter)
			p.SetState(1169)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLBaseParserT__1 {
				{
					p.SetState(1165)
					p.Match(SQLBaseParserT__1)
				}
				{
					p.SetState(1166)

					var _x = p.TypeParameter()

					localctx.(*Type_tContext)._typeParameter = _x
				}
				localctx.(*Type_tContext).typeelem = append(localctx.(*Type_tContext).typeelem, localctx.(*Type_tContext)._typeParameter)

				p.SetState(1171)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1172)
				p.Match(SQLBaseParserT__2)
			}

		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1182)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewType_tContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SQLBaseParserRULE_type_t)
			p.SetState(1178)

			if !(p.Precpred(p.GetParserRuleContext(), 5)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
			}
			{
				p.SetState(1179)
				p.Match(SQLBaseParserARRAY)
			}

		}
		p.SetState(1184)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) Type_t() IType_tContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_tContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_tContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *SQLBaseParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SQLBaseParserRULE_typeParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1187)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLBaseParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1185)
			p.Match(SQLBaseParserINTEGER_VALUE)
		}

	case SQLBaseParserADD, SQLBaseParserALL, SQLBaseParserSOME, SQLBaseParserANY, SQLBaseParserAT, SQLBaseParserNO, SQLBaseParserSUBSTRING, SQLBaseParserPOSITION, SQLBaseParserTINYINT, SQLBaseParserSMALLINT, SQLBaseParserINTEGER, SQLBaseParserDATE, SQLBaseParserTIME, SQLBaseParserTIMESTAMP, SQLBaseParserINTERVAL, SQLBaseParserYEAR, SQLBaseParserMONTH, SQLBaseParserDAY, SQLBaseParserHOUR, SQLBaseParserMINUTE, SQLBaseParserSECOND, SQLBaseParserZONE, SQLBaseParserFILTER, SQLBaseParserOVER, SQLBaseParserPARTITION, SQLBaseParserRANGE, SQLBaseParserROWS, SQLBaseParserPRECEDING, SQLBaseParserFOLLOWING, SQLBaseParserCURRENT, SQLBaseParserROW, SQLBaseParserSCHEMA, SQLBaseParserCOMMENT, SQLBaseParserVIEW, SQLBaseParserREPLACE, SQLBaseParserGRANT, SQLBaseParserREVOKE, SQLBaseParserPRIVILEGES, SQLBaseParserPUBLIC, SQLBaseParserOPTION, SQLBaseParserEXPLAIN, SQLBaseParserANALYZE, SQLBaseParserFORMAT, SQLBaseParserTYPE, SQLBaseParserTEXT, SQLBaseParserGRAPHVIZ, SQLBaseParserLOGICAL, SQLBaseParserDISTRIBUTED, SQLBaseParserVALIDATE, SQLBaseParserSHOW, SQLBaseParserTABLES, SQLBaseParserSCHEMAS, SQLBaseParserCATALOGS, SQLBaseParserCOLUMNS, SQLBaseParserCOLUMN, SQLBaseParserUSE, SQLBaseParserPARTITIONS, SQLBaseParserFUNCTIONS, SQLBaseParserTO, SQLBaseParserSYSTEM, SQLBaseParserBERNOULLI, SQLBaseParserPOISSONIZED, SQLBaseParserTABLESAMPLE, SQLBaseParserARRAY, SQLBaseParserMAP, SQLBaseParserSET, SQLBaseParserRESET, SQLBaseParserSESSION, SQLBaseParserDATA, SQLBaseParserSTART, SQLBaseParserTRANSACTION, SQLBaseParserCOMMIT, SQLBaseParserROLLBACK, SQLBaseParserWORK, SQLBaseParserISOLATION, SQLBaseParserLEVEL, SQLBaseParserSERIALIZABLE, SQLBaseParserREPEATABLE, SQLBaseParserCOMMITTED, SQLBaseParserUNCOMMITTED, SQLBaseParserREAD, SQLBaseParserWRITE, SQLBaseParserONLY, SQLBaseParserCALL, SQLBaseParserINPUT, SQLBaseParserOUTPUT, SQLBaseParserCASCADE, SQLBaseParserRESTRICT, SQLBaseParserINCLUDING, SQLBaseParserEXCLUDING, SQLBaseParserPROPERTIES, SQLBaseParserNFD, SQLBaseParserNFC, SQLBaseParserNFKD, SQLBaseParserNFKC, SQLBaseParserIF, SQLBaseParserNULLIF, SQLBaseParserCOALESCE, SQLBaseParserTIME_WITH_TIME_ZONE, SQLBaseParserTIMESTAMP_WITH_TIME_ZONE, SQLBaseParserDOUBLE_PRECISION, SQLBaseParserIDENTIFIER, SQLBaseParserDIGIT_IDENTIFIER, SQLBaseParserQUOTED_IDENTIFIER, SQLBaseParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1186)
			p.type_t(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_baseType
	return p
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) TIME_WITH_TIME_ZONE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTIME_WITH_TIME_ZONE, 0)
}

func (s *BaseTypeContext) TIMESTAMP_WITH_TIME_ZONE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTIMESTAMP_WITH_TIME_ZONE, 0)
}

func (s *BaseTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDATE, 0)
}

func (s *BaseTypeContext) DOUBLE_PRECISION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDOUBLE_PRECISION, 0)
}

func (s *BaseTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (p *SQLBaseParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SQLBaseParserRULE_baseType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1194)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1189)
			p.Match(SQLBaseParserTIME_WITH_TIME_ZONE)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1190)
			p.Match(SQLBaseParserTIMESTAMP_WITH_TIME_ZONE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1191)
			p.Match(SQLBaseParserDATE)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1192)
			p.Match(SQLBaseParserDOUBLE_PRECISION)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1193)
			p.Identifier()
		}

	}

	return localctx
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_whenClause
	return p
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *SQLBaseParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SQLBaseParserRULE_whenClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1196)
		p.Match(SQLBaseParserWHEN)
	}
	{
		p.SetState(1197)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(1198)
		p.Match(SQLBaseParserTHEN)
	}
	{
		p.SetState(1199)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

	return localctx
}

// IFilterContext is an interface to support dynamic dispatch.
type IFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilterContext differentiates from other interfaces.
	IsFilterContext()
}

type FilterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterContext() *FilterContext {
	var p = new(FilterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_filter
	return p
}

func (*FilterContext) IsFilterContext() {}

func NewFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterContext {
	var p = new(FilterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_filter

	return p
}

func (s *FilterContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFILTER, 0)
}

func (s *FilterContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWHERE, 0)
}

func (s *FilterContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *FilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterFilter(s)
	}
}

func (s *FilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitFilter(s)
	}
}

func (p *SQLBaseParser) Filter() (localctx IFilterContext) {
	localctx = NewFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SQLBaseParserRULE_filter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1201)
		p.Match(SQLBaseParserFILTER)
	}
	{
		p.SetState(1202)
		p.Match(SQLBaseParserT__0)
	}
	{
		p.SetState(1203)
		p.Match(SQLBaseParserWHERE)
	}
	{
		p.SetState(1204)
		p.booleanExpression(0)
	}
	{
		p.SetState(1205)
		p.Match(SQLBaseParserT__2)
	}

	return localctx
}

// IOverContext is an interface to support dynamic dispatch.
type IOverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Get_sortItem returns the _sortItem rule contexts.
	Get_sortItem() ISortItemContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// Set_sortItem sets the _sortItem rule contexts.
	Set_sortItem(ISortItemContext)

	// GetPartition returns the partition rule context list.
	GetPartition() []IExpressionContext

	// GetOrderitem returns the orderitem rule context list.
	GetOrderitem() []ISortItemContext

	// SetPartition sets the partition rule context list.
	SetPartition([]IExpressionContext)

	// SetOrderitem sets the orderitem rule context list.
	SetOrderitem([]ISortItemContext)

	// IsOverContext differentiates from other interfaces.
	IsOverContext()
}

type OverContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	partition   []IExpressionContext
	_sortItem   ISortItemContext
	orderitem   []ISortItemContext
}

func NewEmptyOverContext() *OverContext {
	var p = new(OverContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_over
	return p
}

func (*OverContext) IsOverContext() {}

func NewOverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverContext {
	var p = new(OverContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_over

	return p
}

func (s *OverContext) GetParser() antlr.Parser { return s.parser }

func (s *OverContext) Get_expression() IExpressionContext { return s._expression }

func (s *OverContext) Get_sortItem() ISortItemContext { return s._sortItem }

func (s *OverContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *OverContext) Set_sortItem(v ISortItemContext) { s._sortItem = v }

func (s *OverContext) GetPartition() []IExpressionContext { return s.partition }

func (s *OverContext) GetOrderitem() []ISortItemContext { return s.orderitem }

func (s *OverContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *OverContext) SetOrderitem(v []ISortItemContext) { s.orderitem = v }

func (s *OverContext) OVER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserOVER, 0)
}

func (s *OverContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPARTITION, 0)
}

func (s *OverContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SQLBaseParserBY)
}

func (s *OverContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SQLBaseParserBY, i)
}

func (s *OverContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserORDER, 0)
}

func (s *OverContext) WindowFrame() IWindowFrameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowFrameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *OverContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *OverContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OverContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *OverContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *OverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterOver(s)
	}
}

func (s *OverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitOver(s)
	}
}

func (p *SQLBaseParser) Over() (localctx IOverContext) {
	localctx = NewOverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SQLBaseParserRULE_over)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1207)
		p.Match(SQLBaseParserOVER)
	}
	{
		p.SetState(1208)
		p.Match(SQLBaseParserT__0)
	}
	p.SetState(1219)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserPARTITION {
		{
			p.SetState(1209)
			p.Match(SQLBaseParserPARTITION)
		}
		{
			p.SetState(1210)
			p.Match(SQLBaseParserBY)
		}
		{
			p.SetState(1211)

			var _x = p.Expression()

			localctx.(*OverContext)._expression = _x
		}
		localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)
		p.SetState(1216)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLBaseParserT__1 {
			{
				p.SetState(1212)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(1213)

				var _x = p.Expression()

				localctx.(*OverContext)._expression = _x
			}
			localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)

			p.SetState(1218)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1231)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserORDER {
		{
			p.SetState(1221)
			p.Match(SQLBaseParserORDER)
		}
		{
			p.SetState(1222)
			p.Match(SQLBaseParserBY)
		}
		{
			p.SetState(1223)

			var _x = p.SortItem()

			localctx.(*OverContext)._sortItem = _x
		}
		localctx.(*OverContext).orderitem = append(localctx.(*OverContext).orderitem, localctx.(*OverContext)._sortItem)
		p.SetState(1228)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLBaseParserT__1 {
			{
				p.SetState(1224)
				p.Match(SQLBaseParserT__1)
			}
			{
				p.SetState(1225)

				var _x = p.SortItem()

				localctx.(*OverContext)._sortItem = _x
			}
			localctx.(*OverContext).orderitem = append(localctx.(*OverContext).orderitem, localctx.(*OverContext)._sortItem)

			p.SetState(1230)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1234)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLBaseParserRANGE || _la == SQLBaseParserROWS {
		{
			p.SetState(1233)
			p.WindowFrame()
		}

	}
	{
		p.SetState(1236)
		p.Match(SQLBaseParserT__2)
	}

	return localctx
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrameType returns the frameType token.
	GetFrameType() antlr.Token

	// SetFrameType sets the frameType token.
	SetFrameType(antlr.Token)

	// GetStartFrame returns the startFrame rule contexts.
	GetStartFrame() IFrameBoundContext

	// GetEndFrame returns the endFrame rule contexts.
	GetEndFrame() IFrameBoundContext

	// SetStartFrame sets the startFrame rule contexts.
	SetStartFrame(IFrameBoundContext)

	// SetEndFrame sets the endFrame rule contexts.
	SetEndFrame(IFrameBoundContext)

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	frameType  antlr.Token
	startFrame IFrameBoundContext
	endFrame   IFrameBoundContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_windowFrame
	return p
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetFrameType() antlr.Token { return s.frameType }

func (s *WindowFrameContext) SetFrameType(v antlr.Token) { s.frameType = v }

func (s *WindowFrameContext) GetStartFrame() IFrameBoundContext { return s.startFrame }

func (s *WindowFrameContext) GetEndFrame() IFrameBoundContext { return s.endFrame }

func (s *WindowFrameContext) SetStartFrame(v IFrameBoundContext) { s.startFrame = v }

func (s *WindowFrameContext) SetEndFrame(v IFrameBoundContext) { s.endFrame = v }

func (s *WindowFrameContext) AllFrameBound() []IFrameBoundContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFrameBoundContext)(nil)).Elem())
	var tst = make([]IFrameBoundContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFrameBoundContext)
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBound(i int) IFrameBoundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFrameBoundContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *WindowFrameContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserRANGE, 0)
}

func (s *WindowFrameContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserROWS, 0)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (p *SQLBaseParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SQLBaseParserRULE_windowFrame)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1246)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1238)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*WindowFrameContext).frameType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserRANGE || _la == SQLBaseParserROWS) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*WindowFrameContext).frameType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(1239)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).startFrame = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1240)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*WindowFrameContext).frameType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserRANGE || _la == SQLBaseParserROWS) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*WindowFrameContext).frameType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(1241)
			p.Match(SQLBaseParserBETWEEN)
		}
		{
			p.SetState(1242)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).startFrame = _x
		}
		{
			p.SetState(1243)
			p.Match(SQLBaseParserAND)
		}
		{
			p.SetState(1244)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).endFrame = _x
		}

	}

	return localctx
}

// IFrameBoundContext is an interface to support dynamic dispatch.
type IFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFrameBoundContext differentiates from other interfaces.
	IsFrameBoundContext()
}

type FrameBoundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBoundContext() *FrameBoundContext {
	var p = new(FrameBoundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_frameBound
	return p
}

func (*FrameBoundContext) IsFrameBoundContext() {}

func NewFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundContext {
	var p = new(FrameBoundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_frameBound

	return p
}

func (s *FrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundContext) CopyFrom(ctx *FrameBoundContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *FrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BoundedFrameContext struct {
	*FrameBoundContext
	boundType antlr.Token
}

func NewBoundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoundedFrameContext {
	var p = new(BoundedFrameContext)

	p.FrameBoundContext = NewEmptyFrameBoundContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FrameBoundContext))

	return p
}

func (s *BoundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *BoundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *BoundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoundedFrameContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BoundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPRECEDING, 0)
}

func (s *BoundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFOLLOWING, 0)
}

func (s *BoundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitBoundedFrame(s)
	}
}

type UnboundedFrameContext struct {
	*FrameBoundContext
	boundType antlr.Token
}

func NewUnboundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnboundedFrameContext {
	var p = new(UnboundedFrameContext)

	p.FrameBoundContext = NewEmptyFrameBoundContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FrameBoundContext))

	return p
}

func (s *UnboundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *UnboundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *UnboundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnboundedFrameContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserUNBOUNDED, 0)
}

func (s *UnboundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPRECEDING, 0)
}

func (s *UnboundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFOLLOWING, 0)
}

func (s *UnboundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitUnboundedFrame(s)
	}
}

type CurrentRowBoundContext struct {
	*FrameBoundContext
}

func NewCurrentRowBoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRowBoundContext {
	var p = new(CurrentRowBoundContext)

	p.FrameBoundContext = NewEmptyFrameBoundContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FrameBoundContext))

	return p
}

func (s *CurrentRowBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRowBoundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCURRENT, 0)
}

func (s *CurrentRowBoundContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserROW, 0)
}

func (s *CurrentRowBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitCurrentRowBound(s)
	}
}

func (p *SQLBaseParser) FrameBound() (localctx IFrameBoundContext) {
	localctx = NewFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SQLBaseParserRULE_frameBound)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1248)
			p.Match(SQLBaseParserUNBOUNDED)
		}
		p.SetState(1249)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*UnboundedFrameContext).boundType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserPRECEDING || _la == SQLBaseParserFOLLOWING) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*UnboundedFrameContext).boundType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	case 2:
		localctx = NewCurrentRowBoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1250)
			p.Match(SQLBaseParserCURRENT)
		}
		{
			p.SetState(1251)
			p.Match(SQLBaseParserROW)
		}

	case 3:
		localctx = NewBoundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1252)
			p.Expression()
		}
		p.SetState(1253)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*BoundedFrameContext).boundType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserPRECEDING || _la == SQLBaseParserFOLLOWING) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*BoundedFrameContext).boundType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IExplainOptionContext is an interface to support dynamic dispatch.
type IExplainOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplainOptionContext differentiates from other interfaces.
	IsExplainOptionContext()
}

type ExplainOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainOptionContext() *ExplainOptionContext {
	var p = new(ExplainOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_explainOption
	return p
}

func (*ExplainOptionContext) IsExplainOptionContext() {}

func NewExplainOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainOptionContext {
	var p = new(ExplainOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_explainOption

	return p
}

func (s *ExplainOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainOptionContext) CopyFrom(ctx *ExplainOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExplainOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExplainFormatContext struct {
	*ExplainOptionContext
	value antlr.Token
}

func NewExplainFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainFormatContext {
	var p = new(ExplainFormatContext)

	p.ExplainOptionContext = NewEmptyExplainOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExplainOptionContext))

	return p
}

func (s *ExplainFormatContext) GetValue() antlr.Token { return s.value }

func (s *ExplainFormatContext) SetValue(v antlr.Token) { s.value = v }

func (s *ExplainFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFORMAT, 0)
}

func (s *ExplainFormatContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTEXT, 0)
}

func (s *ExplainFormatContext) GRAPHVIZ() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserGRAPHVIZ, 0)
}

func (s *ExplainFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterExplainFormat(s)
	}
}

func (s *ExplainFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitExplainFormat(s)
	}
}

type ExplainTypeContext struct {
	*ExplainOptionContext
	value antlr.Token
}

func NewExplainTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainTypeContext {
	var p = new(ExplainTypeContext)

	p.ExplainOptionContext = NewEmptyExplainOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExplainOptionContext))

	return p
}

func (s *ExplainTypeContext) GetValue() antlr.Token { return s.value }

func (s *ExplainTypeContext) SetValue(v antlr.Token) { s.value = v }

func (s *ExplainTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTYPE, 0)
}

func (s *ExplainTypeContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLOGICAL, 0)
}

func (s *ExplainTypeContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDISTRIBUTED, 0)
}

func (s *ExplainTypeContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserVALIDATE, 0)
}

func (s *ExplainTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterExplainType(s)
	}
}

func (s *ExplainTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitExplainType(s)
	}
}

func (p *SQLBaseParser) ExplainOption() (localctx IExplainOptionContext) {
	localctx = NewExplainOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SQLBaseParserRULE_explainOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1261)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLBaseParserFORMAT:
		localctx = NewExplainFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1257)
			p.Match(SQLBaseParserFORMAT)
		}
		p.SetState(1258)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*ExplainFormatContext).value = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserTEXT || _la == SQLBaseParserGRAPHVIZ) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*ExplainFormatContext).value = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	case SQLBaseParserTYPE:
		localctx = NewExplainTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1259)
			p.Match(SQLBaseParserTYPE)
		}
		p.SetState(1260)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*ExplainTypeContext).value = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((_la-120)&-(0x1f+1)) == 0 && ((1<<uint((_la-120)))&((1<<(SQLBaseParserLOGICAL-120))|(1<<(SQLBaseParserDISTRIBUTED-120))|(1<<(SQLBaseParserVALIDATE-120)))) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*ExplainTypeContext).value = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITransactionModeContext is an interface to support dynamic dispatch.
type ITransactionModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransactionModeContext differentiates from other interfaces.
	IsTransactionModeContext()
}

type TransactionModeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionModeContext() *TransactionModeContext {
	var p = new(TransactionModeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_transactionMode
	return p
}

func (*TransactionModeContext) IsTransactionModeContext() {}

func NewTransactionModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionModeContext {
	var p = new(TransactionModeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_transactionMode

	return p
}

func (s *TransactionModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionModeContext) CopyFrom(ctx *TransactionModeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TransactionModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TransactionAccessModeContext struct {
	*TransactionModeContext
	accessMode antlr.Token
}

func NewTransactionAccessModeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	p.TransactionModeContext = NewEmptyTransactionModeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TransactionModeContext))

	return p
}

func (s *TransactionAccessModeContext) GetAccessMode() antlr.Token { return s.accessMode }

func (s *TransactionAccessModeContext) SetAccessMode(v antlr.Token) { s.accessMode = v }

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) READ() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserREAD, 0)
}

func (s *TransactionAccessModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserONLY, 0)
}

func (s *TransactionAccessModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWRITE, 0)
}

func (s *TransactionAccessModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitTransactionAccessMode(s)
	}
}

type IsolationLevelContext struct {
	*TransactionModeContext
}

func NewIsolationLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsolationLevelContext {
	var p = new(IsolationLevelContext)

	p.TransactionModeContext = NewEmptyTransactionModeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TransactionModeContext))

	return p
}

func (s *IsolationLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsolationLevelContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserISOLATION, 0)
}

func (s *IsolationLevelContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLEVEL, 0)
}

func (s *IsolationLevelContext) LevelOfIsolation() ILevelOfIsolationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelOfIsolationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILevelOfIsolationContext)
}

func (s *IsolationLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitIsolationLevel(s)
	}
}

func (p *SQLBaseParser) TransactionMode() (localctx ITransactionModeContext) {
	localctx = NewTransactionModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SQLBaseParserRULE_transactionMode)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1268)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLBaseParserISOLATION:
		localctx = NewIsolationLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1263)
			p.Match(SQLBaseParserISOLATION)
		}
		{
			p.SetState(1264)
			p.Match(SQLBaseParserLEVEL)
		}
		{
			p.SetState(1265)
			p.LevelOfIsolation()
		}

	case SQLBaseParserREAD:
		localctx = NewTransactionAccessModeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1266)
			p.Match(SQLBaseParserREAD)
		}
		p.SetState(1267)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*TransactionAccessModeContext).accessMode = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLBaseParserWRITE || _la == SQLBaseParserONLY) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*TransactionAccessModeContext).accessMode = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILevelOfIsolationContext is an interface to support dynamic dispatch.
type ILevelOfIsolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLevelOfIsolationContext differentiates from other interfaces.
	IsLevelOfIsolationContext()
}

type LevelOfIsolationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelOfIsolationContext() *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_levelOfIsolation
	return p
}

func (*LevelOfIsolationContext) IsLevelOfIsolationContext() {}

func NewLevelOfIsolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_levelOfIsolation

	return p
}

func (s *LevelOfIsolationContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelOfIsolationContext) CopyFrom(ctx *LevelOfIsolationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LevelOfIsolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelOfIsolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ReadUncommittedContext struct {
	*LevelOfIsolationContext
}

func NewReadUncommittedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReadUncommittedContext {
	var p = new(ReadUncommittedContext)

	p.LevelOfIsolationContext = NewEmptyLevelOfIsolationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *ReadUncommittedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadUncommittedContext) READ() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserREAD, 0)
}

func (s *ReadUncommittedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserUNCOMMITTED, 0)
}

func (s *ReadUncommittedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterReadUncommitted(s)
	}
}

func (s *ReadUncommittedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitReadUncommitted(s)
	}
}

type SerializableContext struct {
	*LevelOfIsolationContext
}

func NewSerializableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SerializableContext {
	var p = new(SerializableContext)

	p.LevelOfIsolationContext = NewEmptyLevelOfIsolationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *SerializableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerializableContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSERIALIZABLE, 0)
}

func (s *SerializableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterSerializable(s)
	}
}

func (s *SerializableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitSerializable(s)
	}
}

type ReadCommittedContext struct {
	*LevelOfIsolationContext
}

func NewReadCommittedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReadCommittedContext {
	var p = new(ReadCommittedContext)

	p.LevelOfIsolationContext = NewEmptyLevelOfIsolationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *ReadCommittedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadCommittedContext) READ() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserREAD, 0)
}

func (s *ReadCommittedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCOMMITTED, 0)
}

func (s *ReadCommittedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterReadCommitted(s)
	}
}

func (s *ReadCommittedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitReadCommitted(s)
	}
}

type RepeatableReadContext struct {
	*LevelOfIsolationContext
}

func NewRepeatableReadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RepeatableReadContext {
	var p = new(RepeatableReadContext)

	p.LevelOfIsolationContext = NewEmptyLevelOfIsolationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *RepeatableReadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatableReadContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserREPEATABLE, 0)
}

func (s *RepeatableReadContext) READ() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserREAD, 0)
}

func (s *RepeatableReadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterRepeatableRead(s)
	}
}

func (s *RepeatableReadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitRepeatableRead(s)
	}
}

func (p *SQLBaseParser) LevelOfIsolation() (localctx ILevelOfIsolationContext) {
	localctx = NewLevelOfIsolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SQLBaseParserRULE_levelOfIsolation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1277)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		localctx = NewReadUncommittedContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1270)
			p.Match(SQLBaseParserREAD)
		}
		{
			p.SetState(1271)
			p.Match(SQLBaseParserUNCOMMITTED)
		}

	case 2:
		localctx = NewReadCommittedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1272)
			p.Match(SQLBaseParserREAD)
		}
		{
			p.SetState(1273)
			p.Match(SQLBaseParserCOMMITTED)
		}

	case 3:
		localctx = NewRepeatableReadContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1274)
			p.Match(SQLBaseParserREPEATABLE)
		}
		{
			p.SetState(1275)
			p.Match(SQLBaseParserREAD)
		}

	case 4:
		localctx = NewSerializableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1276)
			p.Match(SQLBaseParserSERIALIZABLE)
		}

	}

	return localctx
}

// ICallArgumentContext is an interface to support dynamic dispatch.
type ICallArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallArgumentContext differentiates from other interfaces.
	IsCallArgumentContext()
}

type CallArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallArgumentContext() *CallArgumentContext {
	var p = new(CallArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_callArgument
	return p
}

func (*CallArgumentContext) IsCallArgumentContext() {}

func NewCallArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallArgumentContext {
	var p = new(CallArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_callArgument

	return p
}

func (s *CallArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *CallArgumentContext) CopyFrom(ctx *CallArgumentContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *CallArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PositionalArgumentContext struct {
	*CallArgumentContext
}

func NewPositionalArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionalArgumentContext {
	var p = new(PositionalArgumentContext)

	p.CallArgumentContext = NewEmptyCallArgumentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CallArgumentContext))

	return p
}

func (s *PositionalArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionalArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PositionalArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterPositionalArgument(s)
	}
}

func (s *PositionalArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitPositionalArgument(s)
	}
}

type NamedArgumentContext struct {
	*CallArgumentContext
}

func NewNamedArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NamedArgumentContext {
	var p = new(NamedArgumentContext)

	p.CallArgumentContext = NewEmptyCallArgumentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CallArgumentContext))

	return p
}

func (s *NamedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterNamedArgument(s)
	}
}

func (s *NamedArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitNamedArgument(s)
	}
}

func (p *SQLBaseParser) CallArgument() (localctx ICallArgumentContext) {
	localctx = NewCallArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SQLBaseParserRULE_callArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1284)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPositionalArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1279)
			p.Expression()
		}

	case 2:
		localctx = NewNamedArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1280)
			p.Identifier()
		}
		{
			p.SetState(1281)
			p.Match(SQLBaseParserT__7)
		}
		{
			p.SetState(1282)
			p.Expression()
		}

	}

	return localctx
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_privilege
	return p
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSELECT, 0)
}

func (s *PrivilegeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDELETE, 0)
}

func (s *PrivilegeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINSERT, 0)
}

func (s *PrivilegeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (p *SQLBaseParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SQLBaseParserRULE_privilege)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1290)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLBaseParserSELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1286)
			p.Match(SQLBaseParserSELECT)
		}

	case SQLBaseParserDELETE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1287)
			p.Match(SQLBaseParserDELETE)
		}

	case SQLBaseParserINSERT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1288)
			p.Match(SQLBaseParserINSERT)
		}

	case SQLBaseParserADD, SQLBaseParserALL, SQLBaseParserSOME, SQLBaseParserANY, SQLBaseParserAT, SQLBaseParserNO, SQLBaseParserSUBSTRING, SQLBaseParserPOSITION, SQLBaseParserTINYINT, SQLBaseParserSMALLINT, SQLBaseParserINTEGER, SQLBaseParserDATE, SQLBaseParserTIME, SQLBaseParserTIMESTAMP, SQLBaseParserINTERVAL, SQLBaseParserYEAR, SQLBaseParserMONTH, SQLBaseParserDAY, SQLBaseParserHOUR, SQLBaseParserMINUTE, SQLBaseParserSECOND, SQLBaseParserZONE, SQLBaseParserFILTER, SQLBaseParserOVER, SQLBaseParserPARTITION, SQLBaseParserRANGE, SQLBaseParserROWS, SQLBaseParserPRECEDING, SQLBaseParserFOLLOWING, SQLBaseParserCURRENT, SQLBaseParserROW, SQLBaseParserSCHEMA, SQLBaseParserCOMMENT, SQLBaseParserVIEW, SQLBaseParserREPLACE, SQLBaseParserGRANT, SQLBaseParserREVOKE, SQLBaseParserPRIVILEGES, SQLBaseParserPUBLIC, SQLBaseParserOPTION, SQLBaseParserEXPLAIN, SQLBaseParserANALYZE, SQLBaseParserFORMAT, SQLBaseParserTYPE, SQLBaseParserTEXT, SQLBaseParserGRAPHVIZ, SQLBaseParserLOGICAL, SQLBaseParserDISTRIBUTED, SQLBaseParserVALIDATE, SQLBaseParserSHOW, SQLBaseParserTABLES, SQLBaseParserSCHEMAS, SQLBaseParserCATALOGS, SQLBaseParserCOLUMNS, SQLBaseParserCOLUMN, SQLBaseParserUSE, SQLBaseParserPARTITIONS, SQLBaseParserFUNCTIONS, SQLBaseParserTO, SQLBaseParserSYSTEM, SQLBaseParserBERNOULLI, SQLBaseParserPOISSONIZED, SQLBaseParserTABLESAMPLE, SQLBaseParserARRAY, SQLBaseParserMAP, SQLBaseParserSET, SQLBaseParserRESET, SQLBaseParserSESSION, SQLBaseParserDATA, SQLBaseParserSTART, SQLBaseParserTRANSACTION, SQLBaseParserCOMMIT, SQLBaseParserROLLBACK, SQLBaseParserWORK, SQLBaseParserISOLATION, SQLBaseParserLEVEL, SQLBaseParserSERIALIZABLE, SQLBaseParserREPEATABLE, SQLBaseParserCOMMITTED, SQLBaseParserUNCOMMITTED, SQLBaseParserREAD, SQLBaseParserWRITE, SQLBaseParserONLY, SQLBaseParserCALL, SQLBaseParserINPUT, SQLBaseParserOUTPUT, SQLBaseParserCASCADE, SQLBaseParserRESTRICT, SQLBaseParserINCLUDING, SQLBaseParserEXCLUDING, SQLBaseParserPROPERTIES, SQLBaseParserNFD, SQLBaseParserNFC, SQLBaseParserNFKD, SQLBaseParserNFKC, SQLBaseParserIF, SQLBaseParserNULLIF, SQLBaseParserCOALESCE, SQLBaseParserIDENTIFIER, SQLBaseParserDIGIT_IDENTIFIER, SQLBaseParserQUOTED_IDENTIFIER, SQLBaseParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1289)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_qualifiedName
	return p
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) CopyFrom(ctx *QualifiedNameContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DotQualifiedNameContext struct {
	*QualifiedNameContext
}

func NewDotQualifiedNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DotQualifiedNameContext {
	var p = new(DotQualifiedNameContext)

	p.QualifiedNameContext = NewEmptyQualifiedNameContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QualifiedNameContext))

	return p
}

func (s *DotQualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DotQualifiedNameContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *DotQualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DotQualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterDotQualifiedName(s)
	}
}

func (s *DotQualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitDotQualifiedName(s)
	}
}

func (p *SQLBaseParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SQLBaseParserRULE_qualifiedName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	localctx = NewDotQualifiedNameContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1292)
		p.Identifier()
	}
	p.SetState(1297)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1293)
				p.Match(SQLBaseParserDOT)
			}
			{
				p.SetState(1294)
				p.Identifier()
			}

		}
		p.SetState(1299)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyFrom(ctx *IdentifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BackQuotedIdentifierContext struct {
	*IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

type QuotedIdentifierAlternativeContext struct {
	*IdentifierContext
}

func NewQuotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierAlternativeContext {
	var p = new(QuotedIdentifierAlternativeContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierAlternativeContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterQuotedIdentifierAlternative(s)
	}
}

func (s *QuotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitQuotedIdentifierAlternative(s)
	}
}

type DigitIdentifierContext struct {
	*IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

type UnquotedIdentifierContext struct {
	*IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

type NonReservedIdentifierContext struct {
	*IdentifierContext
}

func NewNonReservedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NonReservedIdentifierContext {
	var p = new(NonReservedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *NonReservedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedIdentifierContext) NonReserved() INonReservedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonReservedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *NonReservedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterNonReservedIdentifier(s)
	}
}

func (s *NonReservedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitNonReservedIdentifier(s)
	}
}

func (p *SQLBaseParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SQLBaseParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1305)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLBaseParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1300)
			p.Match(SQLBaseParserIDENTIFIER)
		}

	case SQLBaseParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1301)
			p.Match(SQLBaseParserDIGIT_IDENTIFIER)
		}

	case SQLBaseParserQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1302)
			p.Match(SQLBaseParserQUOTED_IDENTIFIER)
		}

	case SQLBaseParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1303)
			p.Match(SQLBaseParserBACKQUOTED_IDENTIFIER)
		}

	case SQLBaseParserADD, SQLBaseParserALL, SQLBaseParserSOME, SQLBaseParserANY, SQLBaseParserAT, SQLBaseParserNO, SQLBaseParserSUBSTRING, SQLBaseParserPOSITION, SQLBaseParserTINYINT, SQLBaseParserSMALLINT, SQLBaseParserINTEGER, SQLBaseParserDATE, SQLBaseParserTIME, SQLBaseParserTIMESTAMP, SQLBaseParserINTERVAL, SQLBaseParserYEAR, SQLBaseParserMONTH, SQLBaseParserDAY, SQLBaseParserHOUR, SQLBaseParserMINUTE, SQLBaseParserSECOND, SQLBaseParserZONE, SQLBaseParserFILTER, SQLBaseParserOVER, SQLBaseParserPARTITION, SQLBaseParserRANGE, SQLBaseParserROWS, SQLBaseParserPRECEDING, SQLBaseParserFOLLOWING, SQLBaseParserCURRENT, SQLBaseParserROW, SQLBaseParserSCHEMA, SQLBaseParserCOMMENT, SQLBaseParserVIEW, SQLBaseParserREPLACE, SQLBaseParserGRANT, SQLBaseParserREVOKE, SQLBaseParserPRIVILEGES, SQLBaseParserPUBLIC, SQLBaseParserOPTION, SQLBaseParserEXPLAIN, SQLBaseParserANALYZE, SQLBaseParserFORMAT, SQLBaseParserTYPE, SQLBaseParserTEXT, SQLBaseParserGRAPHVIZ, SQLBaseParserLOGICAL, SQLBaseParserDISTRIBUTED, SQLBaseParserVALIDATE, SQLBaseParserSHOW, SQLBaseParserTABLES, SQLBaseParserSCHEMAS, SQLBaseParserCATALOGS, SQLBaseParserCOLUMNS, SQLBaseParserCOLUMN, SQLBaseParserUSE, SQLBaseParserPARTITIONS, SQLBaseParserFUNCTIONS, SQLBaseParserTO, SQLBaseParserSYSTEM, SQLBaseParserBERNOULLI, SQLBaseParserPOISSONIZED, SQLBaseParserTABLESAMPLE, SQLBaseParserARRAY, SQLBaseParserMAP, SQLBaseParserSET, SQLBaseParserRESET, SQLBaseParserSESSION, SQLBaseParserDATA, SQLBaseParserSTART, SQLBaseParserTRANSACTION, SQLBaseParserCOMMIT, SQLBaseParserROLLBACK, SQLBaseParserWORK, SQLBaseParserISOLATION, SQLBaseParserLEVEL, SQLBaseParserSERIALIZABLE, SQLBaseParserREPEATABLE, SQLBaseParserCOMMITTED, SQLBaseParserUNCOMMITTED, SQLBaseParserREAD, SQLBaseParserWRITE, SQLBaseParserONLY, SQLBaseParserCALL, SQLBaseParserINPUT, SQLBaseParserOUTPUT, SQLBaseParserCASCADE, SQLBaseParserRESTRICT, SQLBaseParserINCLUDING, SQLBaseParserEXCLUDING, SQLBaseParserPROPERTIES, SQLBaseParserNFD, SQLBaseParserNFC, SQLBaseParserNFKD, SQLBaseParserNFKC, SQLBaseParserIF, SQLBaseParserNULLIF, SQLBaseParserCOALESCE:
		localctx = NewNonReservedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1304)
			p.NonReserved()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLBaseParserRULE_nonReserved
	return p
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLBaseParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSHOW, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLES, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCOLUMNS, 0)
}

func (s *NonReservedContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCOLUMN, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPARTITIONS, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFUNCTIONS, 0)
}

func (s *NonReservedContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSCHEMAS, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCATALOGS, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSESSION, 0)
}

func (s *NonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserADD, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFILTER, 0)
}

func (s *NonReservedContext) AT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserAT, 0)
}

func (s *NonReservedContext) OVER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserOVER, 0)
}

func (s *NonReservedContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPARTITION, 0)
}

func (s *NonReservedContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserRANGE, 0)
}

func (s *NonReservedContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserROWS, 0)
}

func (s *NonReservedContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPRECEDING, 0)
}

func (s *NonReservedContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFOLLOWING, 0)
}

func (s *NonReservedContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCURRENT, 0)
}

func (s *NonReservedContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserROW, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserMAP, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserARRAY, 0)
}

func (s *NonReservedContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTINYINT, 0)
}

func (s *NonReservedContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSMALLINT, 0)
}

func (s *NonReservedContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINTEGER, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDATE, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTIMESTAMP, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINTERVAL, 0)
}

func (s *NonReservedContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserZONE, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserYEAR, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserMONTH, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDAY, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserHOUR, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserMINUTE, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSECOND, 0)
}

func (s *NonReservedContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEXPLAIN, 0)
}

func (s *NonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserANALYZE, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserFORMAT, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTYPE, 0)
}

func (s *NonReservedContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTEXT, 0)
}

func (s *NonReservedContext) GRAPHVIZ() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserGRAPHVIZ, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLOGICAL, 0)
}

func (s *NonReservedContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDISTRIBUTED, 0)
}

func (s *NonReservedContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserVALIDATE, 0)
}

func (s *NonReservedContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTABLESAMPLE, 0)
}

func (s *NonReservedContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSYSTEM, 0)
}

func (s *NonReservedContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserBERNOULLI, 0)
}

func (s *NonReservedContext) POISSONIZED() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPOISSONIZED, 0)
}

func (s *NonReservedContext) USE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserUSE, 0)
}

func (s *NonReservedContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTO, 0)
}

func (s *NonReservedContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSET, 0)
}

func (s *NonReservedContext) RESET() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserRESET, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserVIEW, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserREPLACE, 0)
}

func (s *NonReservedContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserIF, 0)
}

func (s *NonReservedContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNULLIF, 0)
}

func (s *NonReservedContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCOALESCE, 0)
}

func (s *NonReservedContext) NFD() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNFD, 0)
}

func (s *NonReservedContext) NFC() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNFC, 0)
}

func (s *NonReservedContext) NFKD() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNFKD, 0)
}

func (s *NonReservedContext) NFKC() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNFKC, 0)
}

func (s *NonReservedContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPOSITION, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserNO, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserDATA, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSTART, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserTRANSACTION, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCOMMIT, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserROLLBACK, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWORK, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserISOLATION, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserLEVEL, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserREPEATABLE, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCOMMITTED, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) READ() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserREAD, 0)
}

func (s *NonReservedContext) WRITE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserWRITE, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserONLY, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCOMMENT, 0)
}

func (s *NonReservedContext) CALL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCALL, 0)
}

func (s *NonReservedContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserGRANT, 0)
}

func (s *NonReservedContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserREVOKE, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPUBLIC, 0)
}

func (s *NonReservedContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserOPTION, 0)
}

func (s *NonReservedContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSUBSTRING, 0)
}

func (s *NonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSCHEMA, 0)
}

func (s *NonReservedContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserCASCADE, 0)
}

func (s *NonReservedContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserRESTRICT, 0)
}

func (s *NonReservedContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINPUT, 0)
}

func (s *NonReservedContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserOUTPUT, 0)
}

func (s *NonReservedContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserINCLUDING, 0)
}

func (s *NonReservedContext) EXCLUDING() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserEXCLUDING, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserPROPERTIES, 0)
}

func (s *NonReservedContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserALL, 0)
}

func (s *NonReservedContext) SOME() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserSOME, 0)
}

func (s *NonReservedContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLBaseParserANY, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLBaseListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (p *SQLBaseParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SQLBaseParserRULE_nonReserved)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1307)
	_la = p.GetTokenStream().LA(1)

	if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQLBaseParserADD)|(1<<SQLBaseParserALL)|(1<<SQLBaseParserSOME)|(1<<SQLBaseParserANY)|(1<<SQLBaseParserAT))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(SQLBaseParserNO-33))|(1<<(SQLBaseParserSUBSTRING-33))|(1<<(SQLBaseParserPOSITION-33))|(1<<(SQLBaseParserTINYINT-33))|(1<<(SQLBaseParserSMALLINT-33))|(1<<(SQLBaseParserINTEGER-33))|(1<<(SQLBaseParserDATE-33))|(1<<(SQLBaseParserTIME-33))|(1<<(SQLBaseParserTIMESTAMP-33))|(1<<(SQLBaseParserINTERVAL-33))|(1<<(SQLBaseParserYEAR-33))|(1<<(SQLBaseParserMONTH-33))|(1<<(SQLBaseParserDAY-33))|(1<<(SQLBaseParserHOUR-33))|(1<<(SQLBaseParserMINUTE-33))|(1<<(SQLBaseParserSECOND-33))|(1<<(SQLBaseParserZONE-33)))) != 0) || (((_la-85)&-(0x1f+1)) == 0 && ((1<<uint((_la-85)))&((1<<(SQLBaseParserFILTER-85))|(1<<(SQLBaseParserOVER-85))|(1<<(SQLBaseParserPARTITION-85))|(1<<(SQLBaseParserRANGE-85))|(1<<(SQLBaseParserROWS-85))|(1<<(SQLBaseParserPRECEDING-85))|(1<<(SQLBaseParserFOLLOWING-85))|(1<<(SQLBaseParserCURRENT-85))|(1<<(SQLBaseParserROW-85))|(1<<(SQLBaseParserSCHEMA-85))|(1<<(SQLBaseParserCOMMENT-85))|(1<<(SQLBaseParserVIEW-85))|(1<<(SQLBaseParserREPLACE-85))|(1<<(SQLBaseParserGRANT-85))|(1<<(SQLBaseParserREVOKE-85))|(1<<(SQLBaseParserPRIVILEGES-85))|(1<<(SQLBaseParserPUBLIC-85))|(1<<(SQLBaseParserOPTION-85))|(1<<(SQLBaseParserEXPLAIN-85))|(1<<(SQLBaseParserANALYZE-85))|(1<<(SQLBaseParserFORMAT-85)))) != 0) || (((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(SQLBaseParserTYPE-117))|(1<<(SQLBaseParserTEXT-117))|(1<<(SQLBaseParserGRAPHVIZ-117))|(1<<(SQLBaseParserLOGICAL-117))|(1<<(SQLBaseParserDISTRIBUTED-117))|(1<<(SQLBaseParserVALIDATE-117))|(1<<(SQLBaseParserSHOW-117))|(1<<(SQLBaseParserTABLES-117))|(1<<(SQLBaseParserSCHEMAS-117))|(1<<(SQLBaseParserCATALOGS-117))|(1<<(SQLBaseParserCOLUMNS-117))|(1<<(SQLBaseParserCOLUMN-117))|(1<<(SQLBaseParserUSE-117))|(1<<(SQLBaseParserPARTITIONS-117))|(1<<(SQLBaseParserFUNCTIONS-117))|(1<<(SQLBaseParserTO-117))|(1<<(SQLBaseParserSYSTEM-117))|(1<<(SQLBaseParserBERNOULLI-117))|(1<<(SQLBaseParserPOISSONIZED-117))|(1<<(SQLBaseParserTABLESAMPLE-117))|(1<<(SQLBaseParserARRAY-117))|(1<<(SQLBaseParserMAP-117)))) != 0) || (((_la-149)&-(0x1f+1)) == 0 && ((1<<uint((_la-149)))&((1<<(SQLBaseParserSET-149))|(1<<(SQLBaseParserRESET-149))|(1<<(SQLBaseParserSESSION-149))|(1<<(SQLBaseParserDATA-149))|(1<<(SQLBaseParserSTART-149))|(1<<(SQLBaseParserTRANSACTION-149))|(1<<(SQLBaseParserCOMMIT-149))|(1<<(SQLBaseParserROLLBACK-149))|(1<<(SQLBaseParserWORK-149))|(1<<(SQLBaseParserISOLATION-149))|(1<<(SQLBaseParserLEVEL-149))|(1<<(SQLBaseParserSERIALIZABLE-149))|(1<<(SQLBaseParserREPEATABLE-149))|(1<<(SQLBaseParserCOMMITTED-149))|(1<<(SQLBaseParserUNCOMMITTED-149))|(1<<(SQLBaseParserREAD-149))|(1<<(SQLBaseParserWRITE-149))|(1<<(SQLBaseParserONLY-149))|(1<<(SQLBaseParserCALL-149))|(1<<(SQLBaseParserINPUT-149))|(1<<(SQLBaseParserOUTPUT-149))|(1<<(SQLBaseParserCASCADE-149))|(1<<(SQLBaseParserRESTRICT-149))|(1<<(SQLBaseParserINCLUDING-149))|(1<<(SQLBaseParserEXCLUDING-149))|(1<<(SQLBaseParserPROPERTIES-149))|(1<<(SQLBaseParserNFD-149))|(1<<(SQLBaseParserNFC-149)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(SQLBaseParserNFKD-181))|(1<<(SQLBaseParserNFKC-181))|(1<<(SQLBaseParserIF-181))|(1<<(SQLBaseParserNULLIF-181))|(1<<(SQLBaseParserCOALESCE-181)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

func (p *SQLBaseParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 10:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 21:
		var t *RelationContext = nil
		if localctx != nil {
			t = localctx.(*RelationContext)
		}
		return p.Relation_Sempred(t, predIndex)

	case 29:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 32:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 33:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	case 39:
		var t *Type_tContext = nil
		if localctx != nil {
			t = localctx.(*Type_tContext)
		}
		return p.Type_t_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SQLBaseParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SQLBaseParser) Relation_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SQLBaseParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SQLBaseParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SQLBaseParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 10)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SQLBaseParser) Type_t_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
